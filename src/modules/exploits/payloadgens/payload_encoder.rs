// File: src/modules/payloadgens/payload_encoder.rs
//
// Payload Encoder for Exploit Development
// Encodes payloads using various schemes for AV evasion and constrained inputs
// Supports shellcode, commands, and text with multiple encoding options
// 
// Usage:
//   rsf> u payloadgens/payload_encoder
//   rsf> run

use anyhow::{Context, Result};
use colored::*;
use std::io::{self, Write};
use std::path::Path;
use tokio::fs;
use tokio::io::AsyncWriteExt;
use tokio::process::Command;
use data_encoding::{BASE32, BASE32HEX, BASE64, BASE64URL};

#[derive(Debug, Clone)]
enum EncodingType {
    Base16,      // Hex
    Base32,      // RFC 4648
    Base32Hex,   // RFC 4648 with hex alphabet
    Base64,      // Standard
    Base64Url,   // URL-safe
    UrlEncode,   // Percent encoding
    ShellEscape, // Shell metacharacter escaping
    HtmlEncode,  // HTML entity encoding
    ZeroWidth,   // Zero-width Unicode steganography
}

impl EncodingType {
    fn from_choice(choice: &str) -> Option<Self> {
        match choice {
            "1" => Some(EncodingType::Base16),
            "2" => Some(EncodingType::Base32),
            "3" => Some(EncodingType::Base32Hex),
            "4" => Some(EncodingType::Base64),
            "5" => Some(EncodingType::Base64Url),
            "6" => Some(EncodingType::UrlEncode),
            "7" => Some(EncodingType::ShellEscape),
            "8" => Some(EncodingType::HtmlEncode),
            "9" => Some(EncodingType::ZeroWidth),
            "" => Some(EncodingType::Base64), // Default
            _ => None,
        }
    }

    fn name(&self) -> &str {
        match self {
            EncodingType::Base16 => "Base16 (Hex)",
            EncodingType::Base32 => "Base32 (RFC 4648)",
            EncodingType::Base32Hex => "Base32Hex",
            EncodingType::Base64 => "Base64",
            EncodingType::Base64Url => "Base64 URL-safe",
            EncodingType::UrlEncode => "URL Encode",
            EncodingType::ShellEscape => "Shell Escape",
            EncodingType::HtmlEncode => "HTML Encode",
            EncodingType::ZeroWidth => "Zero-Width Unicode",
        }
    }

    fn description(&self) -> &str {
        match self {
            EncodingType::Base16 => "Hexadecimal encoding (0-9, A-F)",
            EncodingType::Base32 => "Base32 with A-Z, 2-7",
            EncodingType::Base32Hex => "Base32 with hex alphabet",
            EncodingType::Base64 => "Base64 with A-Z, a-z, 0-9, +, /",
            EncodingType::Base64Url => "Base64 URL-safe (no + or /)",
            EncodingType::UrlEncode => "Percent encoding for URLs",
            EncodingType::ShellEscape => "Escape shell metacharacters",
            EncodingType::HtmlEncode => "HTML entity encoding",
            EncodingType::ZeroWidth => "Zero-width Unicode - completely invisible steganography",
        }
    }
}

#[derive(Debug, Clone)]
enum InputType {
    Text,      // Regular text/command
    Hex,       // Hex string (shellcode)
    Base64,    // Base64 input
    File,      // Read from file
}

#[derive(Debug, Clone, Copy)]
enum ClipboardType {
    X11,      // xclip/xsel
    Wayland,  // wl-copy/wl-paste
    None,
}

/// Main entry point for the module
pub async fn run(_target: &str) -> Result<()> {
    run_interactive().await
}

/// Interactive entry point with menu system
pub async fn run_interactive() -> Result<()> {
    print_banner();
    
    loop {
        println!();
        let input_type = select_input_type().await?;
        let input = get_input(&input_type).await?;
        let encodings = select_encodings().await?;

        println!("{}", "\n[*] Encoding...".yellow());

        let result = apply_encodings(&input, &encodings)?;

        display_result(&result, &encodings, input.len())?;

        handle_output(result).await?;
        
        println!();
        println!("{}", "=".repeat(70).bright_black());

        if !ask_continue()? {
            break;
        }
    }
    
    Ok(())
}

fn print_banner() {
    println!("{}", "╔════════════════════════════════════════════════════════════════════╗".bright_cyan());
    println!("{}", "║               Payload Encoder - Rustsploit Module                 ║".bright_cyan());
    println!("{}", "║           Multiple Encodings for Exploit Development              ║".bright_cyan());
    println!("{}", "╚════════════════════════════════════════════════════════════════════╝".bright_cyan());
    println!("{}", "\n[!] Use this tool to encode payloads for bypassing AV, WAF, or input constraints".yellow());
}

async fn select_input_type() -> Result<InputType> {
    loop {
        println!("{}", "\n[Input Type]".bright_yellow().bold());
        println!("  {} Text/Command", "1.".bright_white());
        println!("  {} Hex Shellcode", "2.".bright_white());
        println!("  {} Base64 Input", "3.".bright_white());
        println!("  {} File (binary)", "4.".bright_white());
    
        print!("{}", "\nSelect input type [1-4]: ".bright_green());
    io::stdout().flush()?;
    
    let mut choice = String::new();
    io::stdin().read_line(&mut choice)?;
    let choice = choice.trim();
    
        match choice {
            "1" => return Ok(InputType::Text),
            "2" => return Ok(InputType::Hex),
            "3" => return Ok(InputType::Base64),
            "4" => return Ok(InputType::File),
            _ => {
                println!("{}", "[!] Invalid choice. Please select 1-4.".red());
                continue;
            }
        }
    }
}

async fn get_input(input_type: &InputType) -> Result<Vec<u8>> {
    match input_type {
        InputType::Text => {
            print!("{}", "\nEnter text/command to encode: ".bright_green());
            io::stdout().flush()?;
            let mut input = String::new();
            io::stdin().read_line(&mut input)?;
            Ok(input.trim().as_bytes().to_vec())
        }
        InputType::Hex => {
            print!("{}", "\nEnter hex shellcode (no spaces): ".bright_green());
    io::stdout().flush()?;
    let mut input = String::new();
    io::stdin().read_line(&mut input)?;
            let hex_str = input.trim();
    
            if hex_str.is_empty() {
                return Ok(Vec::new());
    }
    
            // Validate hex string length (must be even)
            if hex_str.len() % 2 != 0 {
                anyhow::bail!("Hex string must have even length (each byte requires 2 hex characters)");
            }

            // Parse hex string safely
            let mut bytes = Vec::new();
            for i in (0..hex_str.len()).step_by(2) {
                let hex_pair = &hex_str[i..i + 2];
                match u8::from_str_radix(hex_pair, 16) {
                    Ok(byte) => bytes.push(byte),
                    Err(_) => anyhow::bail!(
                        "Invalid hex character at position {}: '{}' (expected 0-9, A-F, or a-f)",
                        i,
                        hex_pair
                    ),
                }
            }

            Ok(bytes)
        }
        InputType::Base64 => {
            print!("{}", "\nEnter base64 to decode: ".bright_green());
            io::stdout().flush()?;
            let mut input = String::new();
            io::stdin().read_line(&mut input)?;
            let b64_str = input.trim();

            if b64_str.is_empty() {
                Ok(Vec::new())
            } else {
                BASE64.decode(b64_str.as_bytes()).context("Invalid base64")
        }
        }
        InputType::File => {
            print!("{}", "\nEnter file path: ".bright_green());
            io::stdout().flush()?;
            let mut path = String::new();
            io::stdin().read_line(&mut path)?;
            let path = path.trim();

            if path.is_empty() {
                anyhow::bail!("No file path provided");
            }

            fs::read(path).await.context("Failed to read file")
        }
    }
}

async fn select_encodings() -> Result<Vec<EncodingType>> {
    loop {
        println!("{}", "\n[Encoding Methods]".bright_yellow().bold());
        println!("  {} Base16 (Hex)       {}", "1.".bright_white(), EncodingType::Base16.description().bright_black());
        println!("  {} Base32             {}", "2.".bright_white(), EncodingType::Base32.description().bright_black());
        println!("  {} Base32Hex          {}", "3.".bright_white(), EncodingType::Base32Hex.description().bright_black());
        println!("  {} Base64             {}", "4.".bright_white(), "A-Z, a-z, 0-9, +, / [DEFAULT]".bright_cyan());
        println!("  {} Base64 URL-safe    {}", "5.".bright_white(), EncodingType::Base64Url.description().bright_black());
        println!("  {} URL Encode         {}", "6.".bright_white(), EncodingType::UrlEncode.description().bright_black());
        println!("  {} Shell Escape       {}", "7.".bright_white(), EncodingType::ShellEscape.description().bright_black());
        println!("  {} HTML Encode        {}", "8.".bright_white(), EncodingType::HtmlEncode.description().bright_black());
        println!("  {} Zero-Width Unicode {}", "9.".bright_white(), EncodingType::ZeroWidth.description().bright_magenta());

        print!("{}", "\nSelect encoding(s) [comma-separated or ENTER for Base64, 9 for invisible]: ".bright_green());
    io::stdout().flush()?;
    
        let mut choices = String::new();
        io::stdin().read_line(&mut choices)?;
        let choices = choices.trim();
    
        if choices.is_empty() {
            return Ok(vec![EncodingType::Base64]);
        }

        let mut encodings = Vec::new();
        let mut has_error = false;

        for choice in choices.split(',') {
            let choice = choice.trim();
            match EncodingType::from_choice(choice) {
                Some(encoding) => encodings.push(encoding),
                None => {
                    println!("{} {}", "[!] Invalid choice:".red(), choice);
                    has_error = true;
                    break;
                }
            }
        }

        if !has_error {
            return Ok(encodings);
    }
        // Loop continues on error
    }
}

fn apply_encodings(input: &[u8], encodings: &[EncodingType]) -> Result<String> {
    // Guard against empty encoding list
    if encodings.is_empty() {
        return String::from_utf8(input.to_vec())
            .context("Input contains invalid UTF-8 and no encoding was specified");
    }

    let mut data = input.to_vec();

    for encoding in encodings {
        let encoded = match encoding {
            EncodingType::Base16 => encode_base16(&data),
            EncodingType::Base32 => BASE32.encode(&data),
            EncodingType::Base32Hex => BASE32HEX.encode(&data),
            EncodingType::Base64 => BASE64.encode(&data),
            EncodingType::Base64Url => BASE64URL.encode(&data),
            EncodingType::UrlEncode => encode_url(&String::from_utf8_lossy(&data)),
            EncodingType::ShellEscape => encode_shell_escape(&String::from_utf8_lossy(&data)),
            EncodingType::HtmlEncode => encode_html(&String::from_utf8_lossy(&data)),
            EncodingType::ZeroWidth => encode_zero_width(&data),
        };

        data = encoded.into_bytes();
    }

    // Convert final result back to string
    String::from_utf8(data).context("Final encoding produced invalid UTF-8")
}

fn display_result(result: &str, encodings: &[EncodingType], input_length: usize) -> Result<()> {
            println!();
            println!("{}", "╔══════════════════════════════════════════════════════════════════════╗".bright_green());
    println!("{}", "║                           ENCODED PAYLOAD                           ║".bright_green());
            println!("{}", "╚══════════════════════════════════════════════════════════════════════╝".bright_green());
            println!();

    // Show encoding chain
    if encodings.len() > 1 {
        println!("{}", "Encoding chain:".bright_cyan());
        for (i, encoding) in encodings.iter().enumerate() {
            println!("  {}. {}", i + 1, encoding.name());
        }
            println!();
    } else if let Some(encoding) = encodings.first() {
        println!("{} {}", "Encoding:".bright_cyan(), encoding.name());
        println!();
    }

    if encodings.iter().any(|e| matches!(e, EncodingType::ZeroWidth)) {
        println!("{}", "\n[!] WARNING: Output contains INVISIBLE zero-width Unicode characters!".yellow().bold());
        println!("{}", "[!] The characters below are invisible but contain your encoded data.".yellow());
        println!("{}", "[!] They have been copied to clipboard as actual invisible Unicode characters.\n".yellow());

        // Show a visual representation
        println!("{} {}", "Visualization:".bright_cyan(), visualize_zero_width(&result).bright_magenta());
        println!();
        println!("{}", "[Invisible Unicode characters copied to clipboard]".bright_white());
    } else {
        println!("{}", result.bright_white());
        }

    if result.len() > 200 {
        println!();
        println!("{} {} chars", "[+] Length:".green(), result.len());
    } else {
        println!();
        println!("{} {} chars", "[+] Length:".green(), result.len());
    }

    // Show some stats
    let compressed_ratio = if input_length > 0 {
        format!("{:.1}%", (result.len() as f64 / input_length as f64) * 100.0)
    } else {
        "N/A".to_string()
    };

    println!("{} {}", "[+] Size ratio:".green(), compressed_ratio);
    println!("{}", "─".repeat(70).bright_black());
    
    Ok(())
}

async fn handle_output(output: String) -> Result<()> {
    // Detect clipboard system
    let clipboard_type = detect_clipboard_system().await;
    
    // Ask about clipboard
    match clipboard_type {
        ClipboardType::X11 => {
            print!("{}", "\nCopy to clipboard (xclip)? [y/N]: ".bright_green());
        }
        ClipboardType::Wayland => {
            print!("{}", "\nCopy to clipboard (wl-copy)? [y/N]: ".bright_green());
        }
        ClipboardType::None => {
            println!("{}", "\n[!] No clipboard tool found (install xclip or wl-clipboard)".yellow());
        }
    }
    
    if !matches!(clipboard_type, ClipboardType::None) {
        io::stdout().flush()?;
        
        let mut choice = String::new();
        io::stdin().read_line(&mut choice)?;
        
        if choice.trim().eq_ignore_ascii_case("y") {
            if copy_to_clipboard(&output, clipboard_type).await? {
                if output.chars().any(|c| matches!(c, '\u{200B}'..='\u{200F}' | '\u{2060}' | '\u{FEFF}' | '\u{034F}')) {
                    println!("{}", "[+] ✓ Invisible zero-width Unicode characters copied to clipboard!".green().bold());
                    println!("{}", "[!] The clipboard now contains truly invisible encoded data.".bright_black());
                } else {
                println!("{}", "[+] ✓ Copied to clipboard!".green().bold());
                }
            } else {
                println!("{}", "[!] Failed to copy to clipboard".red());
            }
        }
    }
    
    // Ask about saving to file
    print!("{}", "\nSave to file? [y/N]: ".bright_green());
    io::stdout().flush()?;
    
    let mut choice = String::new();
    io::stdin().read_line(&mut choice)?;
    
    if choice.trim().eq_ignore_ascii_case("y") {
        save_to_file(&output).await?;
    }
    
    Ok(())
}

fn ask_continue() -> Result<bool> {
    print!("{}", "\nEncode another payload? [Y/n]: ".bright_green());
    io::stdout().flush()?;

    let mut choice = String::new();
    io::stdin().read_line(&mut choice)?;

    Ok(!choice.trim().eq_ignore_ascii_case("n"))
}

async fn detect_clipboard_system() -> ClipboardType {
    // Check for Wayland first
    if let Ok(output) = Command::new("which")
        .arg("wl-copy")
        .output()
        .await
    {
        if output.status.success() {
            return ClipboardType::Wayland;
        }
    }
    
    // Check for X11
    if let Ok(output) = Command::new("which")
        .arg("xclip")
        .output()
        .await
    {
        if output.status.success() {
            return ClipboardType::X11;
        }
    }
    
    ClipboardType::None
}

async fn copy_to_clipboard(text: &str, clipboard_type: ClipboardType) -> Result<bool> {
    // Ensure we copy the raw Unicode characters, especially for zero-width encoding
    // The text should already contain the correct UTF-8 encoded characters
    match clipboard_type {
        ClipboardType::X11 => copy_to_clipboard_x11(text).await,
        ClipboardType::Wayland => copy_to_clipboard_wayland(text).await,
        ClipboardType::None => Ok(false),
    }
}

async fn copy_to_clipboard_x11(text: &str) -> Result<bool> {
    // Use UTF-8 encoding explicitly and ensure proper handling of Unicode characters
    let mut child = Command::new("xclip")
        .arg("-selection")
        .arg("clipboard")
        .arg("-t")
        .arg("text/plain;charset=utf-8")
        .stdin(std::process::Stdio::piped())
        .spawn()
        .context("Failed to spawn xclip")?;
    
    if let Some(mut stdin) = child.stdin.take() {
        // Write as UTF-8 bytes to preserve Unicode characters including zero-width ones
        stdin.write_all(text.as_bytes()).await?;
        stdin.shutdown().await?;
    }
    
    let status = child.wait().await?;
    Ok(status.success())
}

async fn copy_to_clipboard_wayland(text: &str) -> Result<bool> {
    // Explicitly set MIME type for proper Unicode handling
    let mut child = Command::new("wl-copy")
        .arg("-t")
        .arg("text/plain;charset=utf-8")
        .stdin(std::process::Stdio::piped())
        .spawn()
        .context("Failed to spawn wl-copy")?;
    
    if let Some(mut stdin) = child.stdin.take() {
        // Write UTF-8 bytes to preserve zero-width Unicode characters
        stdin.write_all(text.as_bytes()).await?;
        stdin.shutdown().await?;
    }
    
    let status = child.wait().await?;
    Ok(status.success())
}

async fn save_to_file(content: &str) -> Result<()> {
    let default_name = "encoded_payload.txt";
    
    print!("{} [{}]: ", 
        "Enter filename".bright_green(), 
        default_name.bright_black()
    );
    io::stdout().flush()?;
    
    let mut filename = String::new();
    io::stdin().read_line(&mut filename)?;
    let filename = filename.trim();
    
    // Prevent path traversal: only use the filename component, strip directory separators
    let safe_filename = if filename.is_empty() {
        default_name.to_string()
    } else {
        Path::new(filename)
            .file_name()
            .and_then(|f| f.to_str())
            .map(|s| s.to_string())
            .unwrap_or_else(|| {
                // If filename extraction fails, sanitize by removing path separators
                filename.replace('/', "_").replace('\\', "_")
            })
    };
    
    fs::write(&safe_filename, content)
        .await
        .context("Failed to write file")?;
    
    println!("{} {}", "[+] ✓ Saved to:".green().bold(), safe_filename.bright_white());
    
    Ok(())
}

// ============================================================================
// ENCODING FUNCTIONS
// ============================================================================

fn encode_base16(data: &[u8]) -> String {
    let mut result = String::with_capacity(data.len() * 2);
    for &byte in data {
        result.push_str(&format!("{:02X}", byte));
        }
    result
}

fn encode_url(text: &str) -> String {
    // Worst case: all bytes encoded as %XX (3 chars per byte)
    let mut result = String::with_capacity(text.len() * 3);
    
    for byte in text.as_bytes() {
        match *byte {
            b' ' => result.push('+'),
            // RFC 3986 unreserved characters (all ASCII, so byte-to-char cast is safe)
            b'A'..=b'Z' | b'a'..=b'z' | b'0'..=b'9' | b'-' | b'_' | b'.' | b'~' => {
                // Safe: these are all ASCII characters (0-127), so byte as char is valid
                result.push(*byte as char);
            }
            // All other bytes (including multi-byte UTF-8 sequences) are percent-encoded
            _ => {
                result.push('%');
                result.push_str(&format!("{:02X}", byte));
    }
        }
    }

    result
}

fn encode_shell_escape(text: &str) -> String {
    // Estimate capacity: most characters don't need escaping, but escaped ones double in size
    let mut result = String::with_capacity(text.len() * 2);

    for c in text.chars() {
        match c {
            // Critical: space and asterisk must be escaped to prevent command injection
            ' ' | '*' | '$' | '`' | '|' | '&' | ';' | '>' | '<' | '(' | ')' | '{' | '}' | '[' | ']' | ',' | '?' | '~' | '!' | '#' => {
                result.push('\\');
                result.push(c);
            }
            '"' => result.push_str("\\\""),
            '\'' => result.push_str("\\'"),
            '\\' => result.push_str("\\\\"),
            '\n' => result.push_str("\\n"),
            '\r' => result.push_str("\\r"),
            '\t' => result.push_str("\\t"),
            _ => result.push(c),
        }
    }
    
    result
}

fn encode_html(text: &str) -> String {
    // Worst case: all '&' characters become "&amp;" (5 chars each)
    // Other encoded chars are shorter, but this is the worst case
    let mut result = String::with_capacity(text.len() * 5);
    
    for c in text.chars() {
        match c {
            '&' => result.push_str("&amp;"),
            '<' => result.push_str("&lt;"),
            '>' => result.push_str("&gt;"),
            '"' => result.push_str("&quot;"),
            '\'' => result.push_str("&#x27;"),
            '/' => result.push_str("&#x2F;"),
            _ => result.push(c),
        }
    }
    
    result
}

// ============================================================================
// ZERO-WIDTH UNICODE STEGANOGRAPHY
// ============================================================================

/// Zero-width Unicode characters for invisible steganography
/// These characters don't render visually but can store binary data
const ZERO_WIDTH_CHARS: [char; 8] = [
    '\u{200B}', // Zero-width space (ZWSP) - represents 000
    '\u{200C}', // Zero-width non-joiner (ZWNJ) - represents 001
    '\u{200D}', // Zero-width joiner (ZWJ) - represents 010
    '\u{200E}', // Left-to-right mark (LTRM) - represents 011
    '\u{200F}', // Right-to-left mark (RTLM) - represents 100
    '\u{2060}', // Word joiner (WJ) - represents 101
    '\u{FEFF}', // Zero-width no-break space (BOM) - represents 110
    '\u{034F}', // Combining grapheme joiner (CGJ) - represents 111
];

fn encode_zero_width(data: &[u8]) -> String {
    // Calculate exact capacity: (total_bits + 2) / 3 rounded up
    // Each byte contributes 8 bits, each char takes 3 bits
    let total_bits = data.len() as u64 * 8;
    let estimated_chars = ((total_bits + 2) / 3) as usize;
    let mut result = String::with_capacity(estimated_chars);

    let mut buffer: u32 = 0;
    let mut bits_in_buffer = 0;

    for &byte in data {
        // Add byte to buffer (shift left by 8, add byte)
        buffer = (buffer << 8) | (byte as u32);
        bits_in_buffer += 8;

        // Extract 3-bit chunks while we have at least 3 bits
        while bits_in_buffer >= 3 {
            bits_in_buffer -= 3;
            // Extract highest 3 bits (MSB first for proper encoding)
            let bit_value = ((buffer >> bits_in_buffer) & 0x07) as usize;
            result.push(ZERO_WIDTH_CHARS[bit_value]);
        }
    }

    // Handle remaining bits (less than 3 bits in buffer)
    // Pad with zeros to make exactly 3 bits for the final character
    if bits_in_buffer > 0 {
        // Shift the remaining bits to the left to align with MSB of 3-bit chunk
        // Then mask to get exactly 3 bits (padding with zeros on the right)
        let padded_bits = (buffer << (3 - bits_in_buffer)) & 0x07;
        let bit_value = padded_bits as usize;
        result.push(ZERO_WIDTH_CHARS[bit_value]);
    }

    result
}

fn visualize_zero_width(text: &str) -> String {
    let mut result = String::with_capacity(text.len() * 5); // Each char becomes ~5 chars
    
    for ch in text.chars() {
        match ch {
            '\u{200B}' => result.push_str("[000]"),
            '\u{200C}' => result.push_str("[001]"),
            '\u{200D}' => result.push_str("[010]"),
            '\u{200E}' => result.push_str("[011]"),
            '\u{200F}' => result.push_str("[100]"),
            '\u{2060}' => result.push_str("[101]"),
            '\u{FEFF}' => result.push_str("[110]"),
            '\u{034F}' => result.push_str("[111]"),
            _ => result.push_str(&format!("[{:04X}]", ch as u32)),
        }
    }
    
    result
}