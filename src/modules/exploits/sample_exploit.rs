use anyhow::{Context, Result};
use colored::*;
use reqwest::Client;
use std::time::Duration;

const DEFAULT_TIMEOUT_SECS: u64 = 10;

/// A basic demonstration exploit that checks if a specific endpoint is "vulnerable"
pub async fn run(target: &str) -> Result<()> {
    println!("{}", "╔═══════════════════════════════════════════════════════════╗".cyan());
    println!("{}", "║   Sample Exploit Module - Demonstration                   ║".cyan());
    println!("{}", "╚═══════════════════════════════════════════════════════════╝".cyan());
    println!("{}", format!("[*] Target: {}", target).yellow());

    let client = Client::builder()
        .timeout(Duration::from_secs(DEFAULT_TIMEOUT_SECS))
        .danger_accept_invalid_certs(true)
        .build()
        .context("Failed to build HTTP client")?;

    let url = format!("http://{}/vulnerable_endpoint", target);
    println!("{}", format!("[*] Checking: {}", url).cyan());

    let resp = client
        .get(&url)
        .send()
        .await
        .context("Failed to send request")?
        .text()
        .await
        .context("Failed to read response")?;

    if resp.contains("Vulnerable!") {
        println!("{}", "[+] Target is vulnerable!".green().bold());
    } else {
        println!("{}", "[-] Target does not appear to be vulnerable.".red());
    }

    Ok(())
}
