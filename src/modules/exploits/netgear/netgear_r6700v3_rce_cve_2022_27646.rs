use anyhow::Result;
use colored::*;
use tokio::net::TcpStream;
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use std::time::Duration;
use crate::utils::{prompt_required, normalize_target, prompt_default};

/// Netgear R6700v3 Pre-Auth RCE via Circled Daemon (CVE-2022-27646)
/// 
/// Exploits a buffer overflow in `/bin/circled` when fetching `circleinfo.txt`.
/// This is a WAN-side pre-authentication vulnerability.
/// 
/// Based on Pwn2Own Austin 2021 exploit by Synacktiv.
/// Target: TCP port 8888/8889/8890 (circled daemon)

pub async fn run(target: &str) -> Result<()> {
    print_banner();
    
    let raw_ip = if target.is_empty() {
        prompt_required("Target IP")?
    } else {
        target.to_string()
    };
    let target_ip = normalize_target(&raw_ip)?;
    
    // Circled listens on ports 8888, 8889, 8890
    let port_str = prompt_default("Target port (8888/8889/8890)", "8888")?;
    let port: u16 = port_str.parse().unwrap_or(8888);
    
    let target_addr = format!("{}:{}", target_ip, port);
    
    println!("{} Target: {}", "[*]".blue(), target_addr);
    println!("{} Checking if circled daemon is accessible...", "[*]".blue());
    
    // Try to connect to the circled daemon
    let connect_result = tokio::time::timeout(
        Duration::from_secs(10),
        TcpStream::connect(&target_addr)
    ).await;
    
    match connect_result {
        Ok(Ok(mut stream)) => {
            println!("{} Connected to circled daemon!", "[+]".green());
            
            // The vulnerability is triggered when circled fetches circleinfo.txt
            // from a malicious server. For detection, we check if the port is open
            // and potentially responsive.
            
            // Send a probe to see if it responds
            let probe = b"GET / HTTP/1.0\r\n\r\n";
            if let Err(e) = stream.write_all(probe).await {
                println!("{} Write failed: {} (daemon may be unresponsive)", "[*]".yellow(), e);
            }
            
            let mut buf = vec![0u8; 512];
            match tokio::time::timeout(Duration::from_secs(5), stream.read(&mut buf)).await {
                Ok(Ok(n)) if n > 0 => {
                    let response = String::from_utf8_lossy(&buf[..n]);
                    println!("{} Response: {}", "[*]".blue(), response.chars().take(100).collect::<String>());
                },
                _ => {
                    println!("{} No response (expected - circled uses binary protocol)", "[*]".yellow());
                }
            }
            
            println!();
            println!("{} Port {} is open - circled may be running!", "[VULN]".red().bold(), port);
            println!("{} Full exploitation requires:", "[*]".cyan());
            println!("  1. Set up a malicious web server hosting poisoned circleinfo.txt");
            println!("  2. Perform DNS poisoning or MITM to redirect circle.meetcircle.co");
            println!("  3. Trigger the buffer overflow via crafted circleinfo.txt");
            println!();
            println!("{} Reference: github.com/synacktiv/Netgear_Pwn2Own2021", "[*]".dimmed());
        },
        Ok(Err(e)) => {
            println!("{} Connection failed: {}", "[-]".red(), e);
            println!("{} Circled daemon may not be running or port is filtered.", "[*]".yellow());
        },
        Err(_) => {
            println!("{} Connection timed out.", "[-]".red());
        }
    }

    Ok(())
}

fn print_banner() {
    println!("{}", "╔═══════════════════════════════════════════════════════════╗".cyan());
    println!("{}", "║    Netgear R6700v3 Pre-Auth RCE (CVE-2022-27646)          ║".cyan());
    println!("{}", "╚═══════════════════════════════════════════════════════════╝".cyan());
}
