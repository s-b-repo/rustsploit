use anyhow::{anyhow, Result};
use colored::*;
use suppaftp::tokio::AsyncFtpStream;
use suppaftp::Status;
use std::time::Duration;
use std::sync::Arc;
use std::sync::atomic::{AtomicUsize, Ordering};
use tokio::sync::Semaphore;
use tokio::fs::OpenOptions;
use tokio::io::AsyncWriteExt;
use tokio::time::timeout;
use regex::Regex;

use crate::utils::{
    prompt_existing_file, prompt_default, prompt_int_range,
    load_lines
};

const DEFAULT_TIMEOUT_SECS: u64 = 8;
const CONNECT_TIMEOUT_MS: u64 = 4000;

struct FtpCreds {
    ip: String,
    port: u16,
    user: String,
    pass: String,
}

pub async fn run(target: &str) -> Result<()> {
    println!("{}", "╔═══════════════════════════════════════════════════════════╗".cyan());
    println!("{}", "║   FTP Bounce Vulnerability Scanner                        ║".cyan());
    println!("{}", "║   Tests for PORT command abuse (External/Internal)        ║".cyan());
    println!("{}", "╚═══════════════════════════════════════════════════════════╝".cyan());
    println!();

    // Interactive Mode Check
    let effective_target = if target.is_empty() || target == "interactive" || target == "load" {
         println!("{}", "[*] Interactive Mode".cyan());
         println!("[1] Load targets from file (supporting 'IP:PORT:USER:PASS')");
         println!("[2] Scan single target");
         
         let choice = prompt_int_range("Select mode", 1, 1, 2).await?;
         if choice == 1 {
             let f = prompt_existing_file("Path to credentials file").await?;
             f
         } else {
             let t = prompt_default("Target (IP:PORT or IP:PORT:USER:PASS)", "").await?;
             t
         }
    } else {
        target.to_string()
    };

    // Check if target is a file or single target
    let targets = if std::path::Path::new(&effective_target).is_file() {
         println!("{}", format!("[!] Parsing file '{}'", effective_target).yellow());
         parse_ftp_results(&effective_target).await?
    } else {
        // Single target handling
        parse_single_target(&effective_target)?
    };

    if targets.is_empty() {
        return Err(anyhow!("No valid targets found."));
    }
    println!("{}", format!("[*] Loaded {} credential/target sets.", targets.len()).green());

    let concurrency = prompt_int_range("Max concurrent checks", 50, 1, 500).await? as usize;
    let output_file = prompt_default("Output file for vulnerabilities", "ftp_bounce_results.txt").await?;

    let semaphore = Arc::new(Semaphore::new(concurrency));
    let stats_checked = Arc::new(AtomicUsize::new(0));
    let stats_vuln = Arc::new(AtomicUsize::new(0));

    let total = targets.len();
    
    // Stats loop
    let s_checked = stats_checked.clone();
    let s_vuln = stats_vuln.clone();
    tokio::spawn(async move {
        loop {
            tokio::time::sleep(Duration::from_secs(3)).await;
            let checked = s_checked.load(Ordering::Relaxed);
            let vuln = s_vuln.load(Ordering::Relaxed);
            println!(
                "[*] Progress: {}/{} checked, {} Vulnerable found",
                checked, total, vuln.to_string().red().bold()
            );
            if checked >= total { break; }
        }
    });

    // Run Scans
    let mut tasks = Vec::new();

    for target_creds in targets {
        // Safe permit acquisition
        let permit = match semaphore.clone().acquire_owned().await {
            Ok(p) => p,
            Err(_) => break, // Check if semaphore closed
        };
        let sc = stats_checked.clone();
        let sv = stats_vuln.clone();
        let of = output_file.clone();
        
        tasks.push(tokio::spawn(async move {
            if check_bounce_vulnerability(&target_creds, &of).await {
                sv.fetch_add(1, Ordering::Relaxed);
            }
            sc.fetch_add(1, Ordering::Relaxed);
            drop(permit);
        }));
    }

    // Wait all
    for t in tasks {
        let _ = t.await;
    }

    println!("\n{}", "[*] Scan Completed.".green().bold());
    println!("[+] Results saved to {}", output_file.cyan());

    Ok(())
}

fn parse_single_target(raw: &str) -> Result<Vec<FtpCreds>> {
    // Attempt parse as "IP:PORT:USER:PASS"
    // Regex matches 4 groups separated by colons
    let re_full = Regex::new(r"^([^:]+):(\d+):([^:]+):(.*)$").map_err(|e| anyhow!("Regex error: {}", e))?;
    
    if let Some(caps) = re_full.captures(raw) {
        let ip = caps.get(1).map_or("", |m| m.as_str()).to_string();
        let port = caps.get(2).map_or("21", |m| m.as_str()).parse().unwrap_or(21);
        let user = caps.get(3).map_or("", |m| m.as_str()).to_string();
        let pass = caps.get(4).map_or("", |m| m.as_str()).to_string();
        return Ok(vec![FtpCreds { ip, port, user, pass }]);
    }
    
    // Fallback: Just IP or IP:PORT, assumes anonymous
    let (ip, port) = if raw.matches(':').count() == 1 {
        let parts: Vec<&str> = raw.split(':').collect();
        let p_val = parts.get(1).unwrap_or(&"21").parse().unwrap_or(21);
        (parts[0].to_string(), p_val)
    } else if !raw.contains(':') {
        (raw.to_string(), 21)
    } else {
        // Ambiguous format, possibly IPv6? Ignore for now or treat as string
        (raw.to_string(), 21)
    };
    
    // If it *looks* like an IP, return default creds
    if !ip.is_empty() {
         return Ok(vec![FtpCreds { ip, port, user: "anonymous".to_string(), pass: "anonymous".to_string() }]);
    }
    
    Err(anyhow!("Invalid target format. Expected IP:PORT:USER:PASS or IP/IP:PORT"))
}

async fn parse_ftp_results(path: &str) -> Result<Vec<FtpCreds>> {
    let lines = load_lines(path)?;
    let mut creds = Vec::new();
    
    // Standard Format: IP:PORT:USER:PASS
    let re_std = Regex::new(r"^([^:]+):(\d+):([^:]+):(.*)$").map_err(|e| anyhow!("Regex error: {}", e))?;
    
    // Legacy/Old formats support (optional but good for transitions)
    // IP:PORT [ANONYMOUS...]
    let re_anon_old = Regex::new(r"^([^:]+):(\d+)\s+\[ANONYMOUS").map_err(|e| anyhow!("Regex error: {}", e))?;
    
    for line in lines {
        if let Some(caps) = re_std.captures(&line) {
             let ip = caps.get(1).map_or("", |m| m.as_str()).to_string();
             let port = caps.get(2).map_or("21", |m| m.as_str()).parse().unwrap_or(21);
             let user = caps.get(3).map_or("", |m| m.as_str()).to_string();
             let pass = caps.get(4).map_or("", |m| m.as_str()).to_string();
             creds.push(FtpCreds { ip, port, user, pass });
        } else if let Some(caps) = re_anon_old.captures(&line) {
             let ip = caps.get(1).map_or("", |m| m.as_str()).to_string();
             let port = caps.get(2).map_or("21", |m| m.as_str()).parse().unwrap_or(21);
             creds.push(FtpCreds { ip, port, user: "anonymous".to_string(), pass: "anonymous".to_string() });
        }
    }
    
    Ok(creds)
}

async fn check_bounce_vulnerability(creds: &FtpCreds, output_file: &str) -> bool {
    let addr = format!("{}:{}", creds.ip, creds.port);
    
    // Connect
    let mut ftp = match timeout(Duration::from_millis(CONNECT_TIMEOUT_MS), AsyncFtpStream::connect(&addr)).await {
        Ok(Ok(f)) => f,
        _ => return false,
    };

    // Login
    if ftp.login(&creds.user, &creds.pass).await.is_err() {
        return false;
    }

    // Set Checks
    let mut is_vuln = false;
    let mut ext_vuln = false;
    let mut int_vuln = false;

    // Test 1: External Bounce (Google DNS 8.8.8.8:53)
    // PORT command format: h1,h2,h3,h4,p1,p2
    let ext_test = "PORT 8,8,8,8,0,53"; 
    match timeout(Duration::from_secs(DEFAULT_TIMEOUT_SECS), ftp.custom_command(ext_test, &[Status::CommandOk])).await {
        Ok(Ok(resp)) => {
            // Check for 200 OK
            if (resp.status as u32) == 200 {
                ext_vuln = true;
                is_vuln = true;
            }
        },
        _ => {}
    }

    // Test 2: Internal Bounce (Common Gateways)
    // 192.168.1.1:80 => 192,168,1,1,0,80
    // 10.0.0.1:80    => 10,0,0,1,0,80
    // We try a few. If ANY work, we flag it.
    let int_tests = vec![
        "PORT 192,168,1,1,0,80", 
        "PORT 10,0,0,1,0,80",
        "PORT 172,16,0,1,0,80",
        "PORT 127,0,0,1,0,22" // Bounce to self?
    ];

    for cmd in int_tests {
        if timeout(Duration::from_secs(DEFAULT_TIMEOUT_SECS), ftp.custom_command(cmd, &[Status::CommandOk])).await
            .ok()
            .and_then(|r| r.ok())
            .map(|r| (r.status as u32) == 200)
            .unwrap_or(false) 
        {
            int_vuln = true;
            is_vuln = true;
            break; 
        }
    }

    let _ = ftp.quit().await;

    if is_vuln {
        let msg = format!(
            "{} -> {}:{} [VULNERABLE] [Ext Bounce: {}] [Int Bounce: {}]",
            addr, creds.user, creds.pass, 
            if ext_vuln { "YES".red().bold() } else { "NO".dimmed() }, 
            if int_vuln { "YES".red().bold() } else { "NO".dimmed() }
        );
        println!("\r[+] Found: {}", msg);
        
        let file_log = format!("{} -> {}:{} [VULNERABLE] [Ext Bounce: {}] [Int Bounce: {}]\n", 
                               addr, creds.user, creds.pass, 
                               if ext_vuln { "YES" } else { "NO" }, 
                               if int_vuln { "YES" } else { "NO" });
                               
        if let Ok(mut file) = OpenOptions::new().create(true).append(true).open(output_file).await {
            let _ = file.write_all(file_log.as_bytes()).await;
        }
    }

    is_vuln
}
