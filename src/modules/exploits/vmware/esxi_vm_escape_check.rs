// ESXi VM Escape Vulnerability Checker
// CVE-2025-22224 / CVE-2025-22225 / CVE-2025-22226
//
// Checks ESXi hosts for vulnerability to the VM escape chain and
// detects indicators of compromise (IOCs) from known exploitation.
//
// Affected versions:
// - ESXi 8.0 < 8.0 U2b (Build 23305546)
// - ESXi 7.0 < 7.0 U3q (Build 23307199)
//
// For authorized penetration testing only.

use anyhow::{anyhow, Result};
use colored::*;
use ssh2::Session;
use std::io::{Read, Write};
use std::net::TcpStream;
use std::time::Duration;

use crate::utils::{normalize_target, prompt_default, prompt_port};

const DEFAULT_TIMEOUT_SECS: u64 = 30;

// Patched build numbers
const ESXI_80_PATCHED_BUILD: u64 = 23305546; // 8.0 U2b
const ESXI_70_PATCHED_BUILD: u64 = 23307199; // 7.0 U3q

fn display_banner() {
    println!("{}", "╔═══════════════════════════════════════════════════════════════════╗".cyan());
    println!("{}", "║   ESXi VM Escape Vulnerability Checker                            ║".cyan());
    println!("{}", "║   CVE-2025-22224 / CVE-2025-22225 / CVE-2025-22226                 ║".cyan());
    println!("{}", "║                                                                   ║".cyan());
    println!("{}", "║   Checks for vulnerability and IOCs                               ║".cyan());
    println!("{}", "╚═══════════════════════════════════════════════════════════════════╝".cyan());
    println!();
}

/// Create SSH session to ESXi host
fn create_esxi_ssh_session(host: &str, port: u16, username: &str, password: &str) -> Result<(TcpStream, Session)> {
    let addr = format!("{}:{}", host, port);
    let tcp = TcpStream::connect_timeout(
        &addr.parse().map_err(|_| anyhow!("Invalid address"))?,
        Duration::from_secs(DEFAULT_TIMEOUT_SECS),
    ).map_err(|e| anyhow!("Connection failed: {}", e))?;
    
    tcp.set_read_timeout(Some(Duration::from_secs(DEFAULT_TIMEOUT_SECS)))?;
    tcp.set_write_timeout(Some(Duration::from_secs(DEFAULT_TIMEOUT_SECS)))?;
    
    let mut sess = Session::new()?;
    sess.set_tcp_stream(tcp.try_clone()?);
    sess.handshake()?;
    
    sess.userauth_password(username, password)?;
    
    if !sess.authenticated() {
        return Err(anyhow!("Authentication failed"));
    }
    
    Ok((tcp, sess))
}

/// Execute command on ESXi
fn esxi_exec(sess: &Session, cmd: &str) -> Result<(i32, String, String)> {
    let mut channel = sess.channel_session()?;
    channel.exec(cmd)?;
    
    let mut stdout = String::new();
    let mut stderr = String::new();
    
    sess.set_blocking(true);
    
    channel.read_to_string(&mut stdout)?;
    channel.stderr().read_to_string(&mut stderr)?;
    
    channel.wait_close()?;
    let exit_code = channel.exit_status()?;
    
    Ok((exit_code, stdout, stderr))
}

/// Parse ESXi version string to extract version and build
fn parse_esxi_version(version_str: &str) -> Option<(String, u64)> {
    // Format: "VMware ESXi 8.0.0 build-24022510"
    let parts: Vec<&str> = version_str.split_whitespace().collect();
    
    let mut version = String::new();
    let mut build: u64 = 0;
    
    for (i, part) in parts.iter().enumerate() {
        if *part == "ESXi" && i + 1 < parts.len() {
            version = parts[i + 1].to_string();
        }
        if part.starts_with("build-") {
            if let Ok(b) = part.trim_start_matches("build-").parse::<u64>() {
                build = b;
            }
        }
    }
    
    if !version.is_empty() && build > 0 {
        Some((version, build))
    } else {
        None
    }
}

/// Check if ESXi version is vulnerable
fn is_vulnerable(version: &str, build: u64) -> bool {
    if version.starts_with("8.") {
        build < ESXI_80_PATCHED_BUILD
    } else if version.starts_with("7.") {
        build < ESXI_70_PATCHED_BUILD
    } else if version.starts_with("6.") || version.starts_with("5.") {
        // ESXi 6.x and 5.x are EOL and vulnerable
        true
    } else {
        false
    }
}

/// Check for IOCs of exploitation
pub async fn check_iocs(host: &str, port: u16, username: &str, password: &str) -> Result<bool> {
    println!("{}", "[*] Checking for Indicators of Compromise (IOCs)...".cyan());
    
    let (_, sess) = create_esxi_ssh_session(host, port, username, password)?;
    
    let mut found_ioc = false;
    
    // IOC 1: Check for backdoor file /var/run/a
    println!("{}", "[*] Checking for backdoor file /var/run/a...".dimmed());
    match esxi_exec(&sess, "ls -la /var/run/a 2>/dev/null") {
        Ok((0, stdout, _)) if !stdout.is_empty() => {
            println!("{}", "[!] IOC FOUND: /var/run/a exists!".red().bold());
            println!("    {}", stdout.trim());
            found_ioc = true;
        }
        _ => println!("{}", "    [OK] /var/run/a not found".green()),
    }
    
    // IOC 2: Check inetd.conf for suspicious entries
    println!("{}", "[*] Checking inetd.conf for malicious entries...".dimmed());
    match esxi_exec(&sess, "grep -E 'ftp.*stream.*tcp.*root.*/var/run' /var/run/inetd.conf 2>/dev/null") {
        Ok((0, stdout, _)) if !stdout.is_empty() => {
            println!("{}", "[!] IOC FOUND: Suspicious inetd.conf entry!".red().bold());
            println!("    {}", stdout.trim());
            found_ioc = true;
        }
        _ => println!("{}", "    [OK] No suspicious inetd entries".green()),
    }
    
    // IOC 3: Check for VSOCK listeners on port 10000
    println!("{}", "[*] Checking for VSOCK backdoor listeners...".dimmed());
    match esxi_exec(&sess, "lsof -a 2>/dev/null | grep -i vsock") {
        Ok((0, stdout, _)) if !stdout.is_empty() => {
            println!("{}", "[!] VSOCK processes found (review manually):".yellow());
            for line in stdout.lines().take(5) {
                println!("    {}", line);
            }
        }
        _ => println!("{}", "    [OK] No obvious VSOCK backdoors".green()),
    }
    
    // IOC 4: Check for suspicious processes
    println!("{}", "[*] Checking for suspicious processes in /var/run...".dimmed());
    match esxi_exec(&sess, "ps -c | grep '/var/run' 2>/dev/null") {
        Ok((0, stdout, _)) if !stdout.is_empty() => {
            println!("{}", "[!] Suspicious process running from /var/run:".red().bold());
            println!("    {}", stdout.trim());
            found_ioc = true;
        }
        _ => println!("{}", "    [OK] No suspicious /var/run processes".green()),
    }
    
    Ok(found_ioc)
}

/// Check ESXi version and vulnerability status
pub async fn check_vulnerability(host: &str, port: u16, username: &str, password: &str) -> Result<bool> {
    println!("{}", "[*] Checking ESXi version...".cyan());
    
    let (_, sess) = create_esxi_ssh_session(host, port, username, password)?;
    println!("{}", format!("[+] Connected to {}", host).green());
    
    // Get ESXi version
    let version_cmd = "vmware -v";
    match esxi_exec(&sess, version_cmd) {
        Ok((0, stdout, _)) => {
            let version_str = stdout.trim();
            println!("{}", format!("[*] Version: {}", version_str).cyan());
            
            if let Some((version, build)) = parse_esxi_version(version_str) {
                println!("{}", format!("[*] Parsed: version={}, build={}", version, build).dimmed());
                
                if is_vulnerable(&version, build) {
                    println!();
                    println!("{}", "╔════════════════════════════════════════════════════════════╗".red());
                    println!("{}", "║  [!] VULNERABLE to VM Escape (CVE-2025-22224/22225/22226)  ║".red().bold());
                    println!("{}", "╚════════════════════════════════════════════════════════════╝".red());
                    println!();
                    println!("{}", "Affected CVEs:".yellow());
                    println!("  • CVE-2025-22226 (CVSS 7.1): HGFS OOB Read - Info Leak");
                    println!("  • CVE-2025-22224 (CVSS 9.3): VMCI TOCTOU - OOB Write");
                    println!("  • CVE-2025-22225 (CVSS 8.2): VMX Sandbox Escape");
                    println!();
                    println!("{}", "Recommendation: Patch immediately to ESXi 8.0 U2b or 7.0 U3q".yellow());
                    return Ok(true);
                } else {
                    println!();
                    println!("{}", "[+] NOT VULNERABLE - Patched version detected".green().bold());
                    return Ok(false);
                }
            } else {
                println!("{}", "[-] Could not parse version string".yellow());
            }
        }
        Ok((code, _, stderr)) => {
            println!("{}", format!("[-] Command failed with exit code {}: {}", code, stderr.trim()).red());
        }
        Err(e) => {
            println!("{}", format!("[-] Failed to get version: {}", e).red());
        }
    }
    
    Ok(false)
}

/// Prompt helper
async fn prompt(message: &str) -> Result<String> {
    print!("{}: ", message);
    std::io::stdout().flush()?;
    let mut input = String::new();
    std::io::stdin().read_line(&mut input)?;
    Ok(input.trim().to_string())
}

/// Main entry point
pub async fn run(target: &str) -> Result<()> {
    display_banner();
    
    let host = normalize_target(target)?;
    println!("{}", format!("[*] Target: {}", host).cyan());
    
    // Get connection parameters
    let port: u16 = prompt_port("SSH Port", 22)?;
    let username = prompt_default("ESXi Username", "root")?;
    let password = prompt("ESXi Password").await?;
    if password.is_empty() {
        return Err(anyhow!("Password is required"));
    }
    
    println!();
    println!("{}", "Select mode:".yellow().bold());
    println!("  1. Check Vulnerability (version check)");
    println!("  2. Scan for IOCs (compromise indicators)");
    println!("  3. Full Scan (both)");
    println!();
    
    let mode = prompt_default("Mode", "3")?;
    
    match mode.as_str() {
        "1" => {
            check_vulnerability(&host, port, &username, &password).await?;
        }
        "2" => {
            check_iocs(&host, port, &username, &password).await?;
        }
        "3" | _ => {
            let vuln = check_vulnerability(&host, port, &username, &password).await?;
            println!();
            let ioc = check_iocs(&host, port, &username, &password).await?;
            
            println!();
            println!("{}", "═══════════════════════════════════════════════════════════".cyan());
            println!("{}", "                        SUMMARY                            ".cyan().bold());
            println!("{}", "═══════════════════════════════════════════════════════════".cyan());
            println!("  Vulnerable:    {}", if vuln { "YES".red().bold() } else { "NO".green() });
            println!("  IOCs Found:    {}", if ioc { "YES".red().bold() } else { "NO".green() });
        }
    }
    
    println!();
    println!("{}", "[*] ESXi vulnerability check complete".green());
    
    Ok(())
}
