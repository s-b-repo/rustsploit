// Include generated dispatch code in a submodule to avoid name collisions if any
// But `include!` effectively pastes code.
// The error says `AVAILABLE_MODULES` is defined multiple times. 
// Ah, `exploit.rs` likely includes `scanner_dispatch.rs` inadvertently?
// No, look at error:
// `scanner_dispatch.rs:4:1` defined `AVAILABLE_MODULES`
// `exploit_dispatch.rs:4:1` defined `AVAILABLE_MODULES`
// And `src/commands/mod.rs` likely imports both via `mod exploit` and `mod scanner`?
// No, they are separate modules `exploit.rs` and `scanner.rs`.
// 
// Wait, `exploit.rs` has: include!(... exploit_dispatch.rs)
// `scanner.rs` has: include!(... scanner_dispatch.rs)
// They are in separate files `src/commands/exploit.rs` and `src/commands/scanner.rs`.
// They should be separate namespaces.
// 
// Error: `error[E0428]: the name AVAILABLE_MODULES is defined multiple times`
// Location: `scanner_dispatch.rs` defined, previous `exploit_dispatch.rs`.
// THIS SUGGESTS `scanner.rs` includes BOTH?
// OR `exploit.rs` includes BOTH?
// 
// Let's check `exploit.rs` content again.
// I see I messed up `exploit.rs` in previous step?
// I see:
// ```rust
// use anyhow::Result;
//
// // Include generated dispatch code
// include!(concat!(env!("OUT_DIR"), "/exploit_dispatch.rs"));
//
// // Re-export run function as `run_exploit` to match previous API usage if needed, 
// // or cluse anyhow::Result;
//
// include!(concat!(env!("OUT_DIR"), "/scanner_dispatch.rs"));
//
// pub async fn run_scan(module_name: &str, target: &str) -> Result<()> {
//     dispatch(module_name, target).await
// }
// ```
// OMG, I pasted `scanner` content INTO `exploit.rs` by accident during the `multi_replace` failure recovery!
// `exploit.rs` has garbage content combining exploit and scanner.
// I need to reset `exploit.rs`.

use anyhow::Result;

include!(concat!(env!("OUT_DIR"), "/exploit_dispatch.rs"));

// Re-export run function as `run_exploit` to match previous API usage in mod.rs
pub async fn run_exploit(module_name: &str, target: &str) -> Result<()> {
    dispatch(module_name, target).await
}
