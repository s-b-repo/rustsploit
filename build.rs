use std::collections::HashSet;
use std::env;
use std::fs::File;
use std::io::{Read, Write};
use std::path::Path;
use regex::Regex;
use walkdir::WalkDir;

/// Build script that generates module dispatchers for exploits, scanners, and creds.
fn main() {
    // Tell Cargo to rerun this build script if module directories change
    println!("cargo:rerun-if-changed=src/modules/exploits");
    println!("cargo:rerun-if-changed=src/modules/creds");
    println!("cargo:rerun-if-changed=src/modules/scanners");

    // Generate dispatchers for each module category
    let categories = vec![
        ("src/modules/exploits", "exploit_dispatch.rs", "crate::modules::exploits", "Exploit"),
        ("src/modules/creds", "creds_dispatch.rs", "crate::modules::creds", "Cred"),
        ("src/modules/scanners", "scanner_dispatch.rs", "crate::modules::scanners", "Scanner"),
    ];

    for (root, out_file, mod_prefix, category_name) in categories {
        if let Err(e) = generate_dispatch(root, out_file, mod_prefix, category_name) {
            eprintln!("❌ Error generating {} dispatcher: {}", category_name, e);
            std::process::exit(1);
        }
    }
}

fn generate_dispatch(
    root: &str,
    out_file: &str,
    mod_prefix: &str,
    category_name: &str,
) -> Result<(), Box<dyn std::error::Error>> {
    let out_dir = env::var("OUT_DIR").map_err(|_| "OUT_DIR environment variable not set")?;
    let dest_path = Path::new(&out_dir).join(out_file);
    
    let root_path = Path::new(root);
    if !root_path.exists() {
        return Err(format!("Module directory '{}' does not exist", root).into());
    }

    let mappings = find_modules(root_path)?;
    
    // Sort for deterministic output
    let mut sorted_mappings: Vec<_> = mappings.into_iter().collect();
    sorted_mappings.sort_by(|a, b| a.0.cmp(&b.0));

    let mut file = File::create(&dest_path)?;

    writeln!(file, "// Auto-generated by build.rs - DO NOT EDIT MANUALLY\n")?;
    
    // Generate AVAILABLE_MODULES constant for runtime discovery
    writeln!(file, "/// List of all available modules in this category.")?;
    writeln!(file, "pub const AVAILABLE_MODULES: &[&str] = &[")?;
    for (key, _) in &sorted_mappings {
        writeln!(file, "    \"{}\",", key)?;
    }
    writeln!(file, "];\n")?;

    writeln!(file, "pub async fn dispatch(module_name: &str, target: &str) -> anyhow::Result<()> {{")?;
    writeln!(file, "    match module_name {{")?;

    for (key, mod_path) in &sorted_mappings {
        let short_key = key.rsplit('/').next().unwrap_or(key);
        let mod_code_path = mod_path.replace("/", "::");

        if short_key == *key {
            writeln!(
                file,
                r#"        "{k}" => {{ {p}::{m}::run(target).await? }},"#,
                k = key, m = mod_code_path, p = mod_prefix
            )?;
        } else {
            writeln!(
                file,
                r#"        "{short}" | "{full}" => {{ {p}::{m}::run(target).await? }},"#,
                short = short_key, full = key, m = mod_code_path, p = mod_prefix
            )?;
        }
    }

    writeln!(
        file,
        r#"        _ => anyhow::bail!("{} module '{{}}' not found.", module_name),"#,
        category_name
    )?;
    writeln!(file, "    }}\n    Ok(())\n}}")?;

    println!("✅ Generated {} with {} modules", out_file, sorted_mappings.len());
    Ok(())
}

/// Finds all valid modules recursively using WalkDir
fn find_modules(root: &Path) -> Result<HashSet<(String, String)>, Box<dyn std::error::Error>> {
    let mut mappings = HashSet::new();
    let sig_re = Regex::new(r"pub\s+async\s+fn\s+run\s*\(\s*[^)]*:\s*&str\s*\)")?;

    for entry in WalkDir::new(root).follow_links(false).into_iter().filter_map(|e| e.ok()) {
        let path = entry.path();
        if path.is_file() && path.extension().map_or(false, |e| e == "rs") {
            let file_stem = path.file_stem().and_then(|s| s.to_str()).unwrap_or("");
            if file_stem == "mod" || file_stem == "lib" { continue; }

            // Calculate module path relative to root
            // e.g. path = src/modules/exploits/linux/foo.rs, root = src/modules/exploits
            // relative = linux/foo.rs
            if let Ok(relative) = path.strip_prefix(root) {
                let rel_str = relative.with_extension("").to_string_lossy().replace("\\", "/");
                
                // Read content to check signature
                let mut content = String::new();
                if File::open(path).and_then(|mut f| f.read_to_string(&mut content)).is_ok() {
                    if sig_re.is_match(&content) {
                        mappings.insert((rel_str.clone(), rel_str));
                    }
                }
            }
        }
    }
    Ok(mappings)
}
